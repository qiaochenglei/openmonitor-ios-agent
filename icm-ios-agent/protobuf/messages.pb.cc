// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace org {
namespace umit {
namespace icm {
namespace mobile {
namespace proto {

namespace {

const ::google::protobuf::Descriptor* Trace_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Trace_reflection_ = NULL;
const ::google::protobuf::Descriptor* TraceRoute_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TraceRoute_reflection_ = NULL;
const ::google::protobuf::Descriptor* ICMReport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ICMReport_reflection_ = NULL;
const ::google::protobuf::Descriptor* WebsiteReportDetail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WebsiteReportDetail_reflection_ = NULL;
const ::google::protobuf::Descriptor* WebsiteReport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WebsiteReport_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServiceReportDetail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServiceReportDetail_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServiceReport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServiceReport_reflection_ = NULL;
const ::google::protobuf::Descriptor* RequestHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RequestHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResponseHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResponseHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterAgent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterAgent_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterAgentResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterAgentResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* RSAKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RSAKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckAggregator_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckAggregator_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckAggregatorResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckAggregatorResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* Login_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Login_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginStep1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginStep1_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginStep2_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginStep2_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* Logout_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Logout_reflection_ = NULL;
const ::google::protobuf::Descriptor* LogoutResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LogoutResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetPeerList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetPeerList_reflection_ = NULL;
const ::google::protobuf::Descriptor* AgentData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AgentData_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetPeerListResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetPeerListResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetSuperPeerList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetSuperPeerList_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetSuperPeerListResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetSuperPeerListResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* Location_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Location_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetEvents_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetEvents_reflection_ = NULL;
const ::google::protobuf::Descriptor* Event_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Event_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetEventsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetEventsResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendWebsiteReport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendWebsiteReport_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendServiceReport_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendServiceReport_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendReportResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendReportResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewVersion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewVersion_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewVersionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewVersionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewTests_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewTests_reflection_ = NULL;
const ::google::protobuf::Descriptor* Website_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Website_reflection_ = NULL;
const ::google::protobuf::Descriptor* Service_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Service_reflection_ = NULL;
const ::google::protobuf::Descriptor* Test_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Test_reflection_ = NULL;
const ::google::protobuf::Descriptor* NewTestsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewTestsResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AssignTask_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AssignTask_reflection_ = NULL;
const ::google::protobuf::Descriptor* AssignTaskResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AssignTaskResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpgradeToSuper_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpgradeToSuper_reflection_ = NULL;
const ::google::protobuf::Descriptor* UpgradeToSuperResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpgradeToSuperResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* WebsiteSuggestion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WebsiteSuggestion_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServiceSuggestion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServiceSuggestion_reflection_ = NULL;
const ::google::protobuf::Descriptor* TestSuggestionResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TestSuggestionResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AuthenticatePeer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AuthenticatePeer_reflection_ = NULL;
const ::google::protobuf::Descriptor* AuthenticatePeerResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AuthenticatePeerResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* P2PGetSuperPeerList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  P2PGetSuperPeerList_reflection_ = NULL;
const ::google::protobuf::Descriptor* P2PGetSuperPeerListResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  P2PGetSuperPeerListResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* P2PGetPeerList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  P2PGetPeerList_reflection_ = NULL;
const ::google::protobuf::Descriptor* P2PGetPeerListResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  P2PGetPeerListResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* AgentUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AgentUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* AgentUpdateResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AgentUpdateResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* TestModuleUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TestModuleUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* TestModuleUpdateResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TestModuleUpdateResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ForwardingMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ForwardingMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ForwardingMessageResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ForwardingMessageResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginCredentials_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginCredentials_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetNetlist_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetNetlist_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetworkData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkData_reflection_ = NULL;
const ::google::protobuf::Descriptor* BannedNetworkData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BannedNetworkData_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetNetlistResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetNetlistResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetBanlist_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetBanlist_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetBanlistResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetBanlistResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetBannets_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetBannets_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetBannetsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetBannetsResponse_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  Trace_descriptor_ = file->message_type(0);
  static const int Trace_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trace, hop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trace, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trace, packetstiming_),
  };
  Trace_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Trace_descriptor_,
      Trace::default_instance_,
      Trace_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trace, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Trace, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Trace));
  TraceRoute_descriptor_ = file->message_type(1);
  static const int TraceRoute_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceRoute, target_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceRoute, hops_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceRoute, packetsize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceRoute, traces_),
  };
  TraceRoute_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TraceRoute_descriptor_,
      TraceRoute::default_instance_,
      TraceRoute_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceRoute, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TraceRoute, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TraceRoute));
  ICMReport_descriptor_ = file->message_type(2);
  static const int ICMReport_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, reportid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, agentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, testid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, timezone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, timeutc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, passednode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, traceroute_),
  };
  ICMReport_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ICMReport_descriptor_,
      ICMReport::default_instance_,
      ICMReport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ICMReport, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ICMReport));
  WebsiteReportDetail_descriptor_ = file->message_type(3);
  static const int WebsiteReportDetail_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, websiteurl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, statuscode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, responsetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, bandwidth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, redirectlink_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, htmlresponse_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, htmlmedia_),
  };
  WebsiteReportDetail_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WebsiteReportDetail_descriptor_,
      WebsiteReportDetail::default_instance_,
      WebsiteReportDetail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReportDetail, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WebsiteReportDetail));
  WebsiteReport_descriptor_ = file->message_type(4);
  static const int WebsiteReport_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReport, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReport, report_),
  };
  WebsiteReport_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WebsiteReport_descriptor_,
      WebsiteReport::default_instance_,
      WebsiteReport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReport, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteReport, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WebsiteReport));
  ServiceReportDetail_descriptor_ = file->message_type(5);
  static const int ServiceReportDetail_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, servicename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, statuscode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, responsetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, bandwidth_),
  };
  ServiceReportDetail_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServiceReportDetail_descriptor_,
      ServiceReportDetail::default_instance_,
      ServiceReportDetail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReportDetail, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServiceReportDetail));
  ServiceReport_descriptor_ = file->message_type(6);
  static const int ServiceReport_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReport, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReport, report_),
  };
  ServiceReport_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServiceReport_descriptor_,
      ServiceReport::default_instance_,
      ServiceReport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReport, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceReport, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServiceReport));
  RequestHeader_descriptor_ = file->message_type(7);
  static const int RequestHeader_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, agentid_),
  };
  RequestHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RequestHeader_descriptor_,
      RequestHeader::default_instance_,
      RequestHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RequestHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RequestHeader));
  ResponseHeader_descriptor_ = file->message_type(8);
  static const int ResponseHeader_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, currentversionno_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, currenttestversionno_),
  };
  ResponseHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResponseHeader_descriptor_,
      ResponseHeader::default_instance_,
      ResponseHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResponseHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResponseHeader));
  RegisterAgent_descriptor_ = file->message_type(9);
  static const int RegisterAgent_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, versionno_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, agenttype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, credentials_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, agentpublickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, ip_),
  };
  RegisterAgent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterAgent_descriptor_,
      RegisterAgent::default_instance_,
      RegisterAgent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterAgent));
  RegisterAgentResponse_descriptor_ = file->message_type(10);
  static const int RegisterAgentResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgentResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgentResponse, agentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgentResponse, publickeyhash_),
  };
  RegisterAgentResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterAgentResponse_descriptor_,
      RegisterAgentResponse::default_instance_,
      RegisterAgentResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgentResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterAgentResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterAgentResponse));
  RSAKey_descriptor_ = file->message_type(11);
  static const int RSAKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSAKey, mod_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSAKey, exp_),
  };
  RSAKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RSAKey_descriptor_,
      RSAKey::default_instance_,
      RSAKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSAKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSAKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RSAKey));
  CheckAggregator_descriptor_ = file->message_type(12);
  static const int CheckAggregator_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregator, agenttype_),
  };
  CheckAggregator_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckAggregator_descriptor_,
      CheckAggregator::default_instance_,
      CheckAggregator_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregator, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregator, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckAggregator));
  CheckAggregatorResponse_descriptor_ = file->message_type(13);
  static const int CheckAggregatorResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregatorResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregatorResponse, status_),
  };
  CheckAggregatorResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CheckAggregatorResponse_descriptor_,
      CheckAggregatorResponse::default_instance_,
      CheckAggregatorResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregatorResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckAggregatorResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CheckAggregatorResponse));
  Login_descriptor_ = file->message_type(14);
  static const int Login_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, agentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, challenge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, ip_),
  };
  Login_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Login_descriptor_,
      Login::default_instance_,
      Login_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Login, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Login));
  LoginStep1_descriptor_ = file->message_type(15);
  static const int LoginStep1_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep1, processid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep1, cipheredchallenge_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep1, challenge_),
  };
  LoginStep1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginStep1_descriptor_,
      LoginStep1::default_instance_,
      LoginStep1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginStep1));
  LoginStep2_descriptor_ = file->message_type(16);
  static const int LoginStep2_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep2, processid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep2, cipheredchallenge_),
  };
  LoginStep2_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginStep2_descriptor_,
      LoginStep2::default_instance_,
      LoginStep2_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep2, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginStep2, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginStep2));
  LoginResponse_descriptor_ = file->message_type(17);
  static const int LoginResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginResponse, header_),
  };
  LoginResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginResponse_descriptor_,
      LoginResponse::default_instance_,
      LoginResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginResponse));
  Logout_descriptor_ = file->message_type(18);
  static const int Logout_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Logout, agentid_),
  };
  Logout_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Logout_descriptor_,
      Logout::default_instance_,
      Logout_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Logout, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Logout, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Logout));
  LogoutResponse_descriptor_ = file->message_type(19);
  static const int LogoutResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogoutResponse, status_),
  };
  LogoutResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LogoutResponse_descriptor_,
      LogoutResponse::default_instance_,
      LogoutResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogoutResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LogoutResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LogoutResponse));
  GetPeerList_descriptor_ = file->message_type(20);
  static const int GetPeerList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerList, count_),
  };
  GetPeerList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetPeerList_descriptor_,
      GetPeerList::default_instance_,
      GetPeerList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetPeerList));
  AgentData_descriptor_ = file->message_type(21);
  static const int AgentData_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, agentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, agentip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, agentport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, publickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, peerstatus_),
  };
  AgentData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AgentData_descriptor_,
      AgentData::default_instance_,
      AgentData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AgentData));
  GetPeerListResponse_descriptor_ = file->message_type(22);
  static const int GetPeerListResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerListResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerListResponse, knownpeers_),
  };
  GetPeerListResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetPeerListResponse_descriptor_,
      GetPeerListResponse::default_instance_,
      GetPeerListResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerListResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPeerListResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetPeerListResponse));
  GetSuperPeerList_descriptor_ = file->message_type(23);
  static const int GetSuperPeerList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerList, count_),
  };
  GetSuperPeerList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetSuperPeerList_descriptor_,
      GetSuperPeerList::default_instance_,
      GetSuperPeerList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetSuperPeerList));
  GetSuperPeerListResponse_descriptor_ = file->message_type(24);
  static const int GetSuperPeerListResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerListResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerListResponse, knownsuperpeers_),
  };
  GetSuperPeerListResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetSuperPeerListResponse_descriptor_,
      GetSuperPeerListResponse::default_instance_,
      GetSuperPeerListResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerListResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetSuperPeerListResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetSuperPeerListResponse));
  Location_descriptor_ = file->message_type(25);
  static const int Location_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, longitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, latitude_),
  };
  Location_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Location_descriptor_,
      Location::default_instance_,
      Location_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Location));
  GetEvents_descriptor_ = file->message_type(26);
  static const int GetEvents_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEvents, locations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEvents, agentlocation_),
  };
  GetEvents_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetEvents_descriptor_,
      GetEvents::default_instance_,
      GetEvents_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEvents, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEvents, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetEvents));
  Event_descriptor_ = file->message_type(27);
  static const int Event_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, testtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, eventtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, timeutc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, sincetimeutc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, locations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, websitereport_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, servicereport_),
  };
  Event_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Event_descriptor_,
      Event::default_instance_,
      Event_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Event, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Event));
  GetEventsResponse_descriptor_ = file->message_type(28);
  static const int GetEventsResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEventsResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEventsResponse, events_),
  };
  GetEventsResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetEventsResponse_descriptor_,
      GetEventsResponse::default_instance_,
      GetEventsResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEventsResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEventsResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetEventsResponse));
  SendWebsiteReport_descriptor_ = file->message_type(29);
  static const int SendWebsiteReport_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendWebsiteReport, report_),
  };
  SendWebsiteReport_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendWebsiteReport_descriptor_,
      SendWebsiteReport::default_instance_,
      SendWebsiteReport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendWebsiteReport, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendWebsiteReport, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendWebsiteReport));
  SendServiceReport_descriptor_ = file->message_type(30);
  static const int SendServiceReport_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendServiceReport, report_),
  };
  SendServiceReport_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendServiceReport_descriptor_,
      SendServiceReport::default_instance_,
      SendServiceReport_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendServiceReport, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendServiceReport, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendServiceReport));
  SendReportResponse_descriptor_ = file->message_type(31);
  static const int SendReportResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendReportResponse, header_),
  };
  SendReportResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendReportResponse_descriptor_,
      SendReportResponse::default_instance_,
      SendReportResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendReportResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendReportResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendReportResponse));
  NewVersion_descriptor_ = file->message_type(32);
  static const int NewVersion_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersion, agentversionno_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersion, agenttype_),
  };
  NewVersion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewVersion_descriptor_,
      NewVersion::default_instance_,
      NewVersion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewVersion));
  NewVersionResponse_descriptor_ = file->message_type(33);
  static const int NewVersionResponse_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersionResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersionResponse, downloadurl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersionResponse, update_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersionResponse, versionno_),
  };
  NewVersionResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewVersionResponse_descriptor_,
      NewVersionResponse::default_instance_,
      NewVersionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersionResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewVersionResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewVersionResponse));
  NewTests_descriptor_ = file->message_type(34);
  static const int NewTests_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTests, currenttestversionno_),
  };
  NewTests_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewTests_descriptor_,
      NewTests::default_instance_,
      NewTests_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTests, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTests, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewTests));
  Website_descriptor_ = file->message_type(35);
  static const int Website_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Website, url_),
  };
  Website_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Website_descriptor_,
      Website::default_instance_,
      Website_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Website, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Website, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Website));
  Service_descriptor_ = file->message_type(36);
  static const int Service_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Service, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Service, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Service, ip_),
  };
  Service_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Service_descriptor_,
      Service::default_instance_,
      Service_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Service, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Service, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Service));
  Test_descriptor_ = file->message_type(37);
  static const int Test_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, testid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, website_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, service_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, executeattimeutc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, testtype_),
  };
  Test_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Test_descriptor_,
      Test::default_instance_,
      Test_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Test, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Test));
  NewTestsResponse_descriptor_ = file->message_type(38);
  static const int NewTestsResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTestsResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTestsResponse, tests_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTestsResponse, testversionno_),
  };
  NewTestsResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewTestsResponse_descriptor_,
      NewTestsResponse::default_instance_,
      NewTestsResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTestsResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewTestsResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewTestsResponse));
  AssignTask_descriptor_ = file->message_type(39);
  static const int AssignTask_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTask, header_),
  };
  AssignTask_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AssignTask_descriptor_,
      AssignTask::default_instance_,
      AssignTask_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTask, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTask, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AssignTask));
  AssignTaskResponse_descriptor_ = file->message_type(40);
  static const int AssignTaskResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTaskResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTaskResponse, tests_),
  };
  AssignTaskResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AssignTaskResponse_descriptor_,
      AssignTaskResponse::default_instance_,
      AssignTaskResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTaskResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssignTaskResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AssignTaskResponse));
  UpgradeToSuper_descriptor_ = file->message_type(41);
  static const int UpgradeToSuper_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuper, header_),
  };
  UpgradeToSuper_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpgradeToSuper_descriptor_,
      UpgradeToSuper::default_instance_,
      UpgradeToSuper_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuper, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuper, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpgradeToSuper));
  UpgradeToSuperResponse_descriptor_ = file->message_type(42);
  static const int UpgradeToSuperResponse_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuperResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuperResponse, newtoken_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuperResponse, newprivatekey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuperResponse, newpublickey_),
  };
  UpgradeToSuperResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpgradeToSuperResponse_descriptor_,
      UpgradeToSuperResponse::default_instance_,
      UpgradeToSuperResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuperResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeToSuperResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpgradeToSuperResponse));
  WebsiteSuggestion_descriptor_ = file->message_type(43);
  static const int WebsiteSuggestion_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteSuggestion, websiteurl_),
  };
  WebsiteSuggestion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WebsiteSuggestion_descriptor_,
      WebsiteSuggestion::default_instance_,
      WebsiteSuggestion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteSuggestion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WebsiteSuggestion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WebsiteSuggestion));
  ServiceSuggestion_descriptor_ = file->message_type(44);
  static const int ServiceSuggestion_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceSuggestion, servicename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceSuggestion, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceSuggestion, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceSuggestion, port_),
  };
  ServiceSuggestion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServiceSuggestion_descriptor_,
      ServiceSuggestion::default_instance_,
      ServiceSuggestion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceSuggestion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceSuggestion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServiceSuggestion));
  TestSuggestionResponse_descriptor_ = file->message_type(45);
  static const int TestSuggestionResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestSuggestionResponse, header_),
  };
  TestSuggestionResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TestSuggestionResponse_descriptor_,
      TestSuggestionResponse::default_instance_,
      TestSuggestionResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestSuggestionResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestSuggestionResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TestSuggestionResponse));
  AuthenticatePeer_descriptor_ = file->message_type(46);
  static const int AuthenticatePeer_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeer, agenttype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeer, agentid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeer, cipheredpublickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeer, agentport_),
  };
  AuthenticatePeer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AuthenticatePeer_descriptor_,
      AuthenticatePeer::default_instance_,
      AuthenticatePeer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AuthenticatePeer));
  AuthenticatePeerResponse_descriptor_ = file->message_type(47);
  static const int AuthenticatePeerResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeerResponse, cipheredpublickey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeerResponse, token_),
  };
  AuthenticatePeerResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AuthenticatePeerResponse_descriptor_,
      AuthenticatePeerResponse::default_instance_,
      AuthenticatePeerResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeerResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AuthenticatePeerResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AuthenticatePeerResponse));
  P2PGetSuperPeerList_descriptor_ = file->message_type(48);
  static const int P2PGetSuperPeerList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetSuperPeerList, count_),
  };
  P2PGetSuperPeerList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      P2PGetSuperPeerList_descriptor_,
      P2PGetSuperPeerList::default_instance_,
      P2PGetSuperPeerList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetSuperPeerList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetSuperPeerList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(P2PGetSuperPeerList));
  P2PGetSuperPeerListResponse_descriptor_ = file->message_type(49);
  static const int P2PGetSuperPeerListResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetSuperPeerListResponse, peers_),
  };
  P2PGetSuperPeerListResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      P2PGetSuperPeerListResponse_descriptor_,
      P2PGetSuperPeerListResponse::default_instance_,
      P2PGetSuperPeerListResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetSuperPeerListResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetSuperPeerListResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(P2PGetSuperPeerListResponse));
  P2PGetPeerList_descriptor_ = file->message_type(50);
  static const int P2PGetPeerList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetPeerList, count_),
  };
  P2PGetPeerList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      P2PGetPeerList_descriptor_,
      P2PGetPeerList::default_instance_,
      P2PGetPeerList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetPeerList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetPeerList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(P2PGetPeerList));
  P2PGetPeerListResponse_descriptor_ = file->message_type(51);
  static const int P2PGetPeerListResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetPeerListResponse, peers_),
  };
  P2PGetPeerListResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      P2PGetPeerListResponse_descriptor_,
      P2PGetPeerListResponse::default_instance_,
      P2PGetPeerListResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetPeerListResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(P2PGetPeerListResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(P2PGetPeerListResponse));
  AgentUpdate_descriptor_ = file->message_type(52);
  static const int AgentUpdate_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdate, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdate, downloadurl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdate, checkcode_),
  };
  AgentUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AgentUpdate_descriptor_,
      AgentUpdate::default_instance_,
      AgentUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AgentUpdate));
  AgentUpdateResponse_descriptor_ = file->message_type(53);
  static const int AgentUpdateResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdateResponse, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdateResponse, result_),
  };
  AgentUpdateResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AgentUpdateResponse_descriptor_,
      AgentUpdateResponse::default_instance_,
      AgentUpdateResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdateResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AgentUpdateResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AgentUpdateResponse));
  TestModuleUpdate_descriptor_ = file->message_type(54);
  static const int TestModuleUpdate_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdate, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdate, downloadurl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdate, checkcode_),
  };
  TestModuleUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TestModuleUpdate_descriptor_,
      TestModuleUpdate::default_instance_,
      TestModuleUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TestModuleUpdate));
  TestModuleUpdateResponse_descriptor_ = file->message_type(55);
  static const int TestModuleUpdateResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdateResponse, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdateResponse, result_),
  };
  TestModuleUpdateResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TestModuleUpdateResponse_descriptor_,
      TestModuleUpdateResponse::default_instance_,
      TestModuleUpdateResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdateResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestModuleUpdateResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TestModuleUpdateResponse));
  ForwardingMessage_descriptor_ = file->message_type(56);
  static const int ForwardingMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessage, destination_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessage, identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessage, encodedmessage_),
  };
  ForwardingMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ForwardingMessage_descriptor_,
      ForwardingMessage::default_instance_,
      ForwardingMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ForwardingMessage));
  ForwardingMessageResponse_descriptor_ = file->message_type(57);
  static const int ForwardingMessageResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessageResponse, identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessageResponse, encodedmessage_),
  };
  ForwardingMessageResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ForwardingMessageResponse_descriptor_,
      ForwardingMessageResponse::default_instance_,
      ForwardingMessageResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessageResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ForwardingMessageResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ForwardingMessageResponse));
  LoginCredentials_descriptor_ = file->message_type(58);
  static const int LoginCredentials_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCredentials, username_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCredentials, password_),
  };
  LoginCredentials_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginCredentials_descriptor_,
      LoginCredentials::default_instance_,
      LoginCredentials_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCredentials, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginCredentials, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginCredentials));
  GetNetlist_descriptor_ = file->message_type(59);
  static const int GetNetlist_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlist, list_),
  };
  GetNetlist_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetNetlist_descriptor_,
      GetNetlist::default_instance_,
      GetNetlist_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlist, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlist, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetNetlist));
  NetworkData_descriptor_ = file->message_type(60);
  static const int NetworkData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkData, start_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkData, end_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkData, nodes_count_network_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkData, nodes_),
  };
  NetworkData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetworkData_descriptor_,
      NetworkData::default_instance_,
      NetworkData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetworkData));
  BannedNetworkData_descriptor_ = file->message_type(61);
  static const int BannedNetworkData_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BannedNetworkData, start_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BannedNetworkData, end_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BannedNetworkData, nodes_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BannedNetworkData, flags_),
  };
  BannedNetworkData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BannedNetworkData_descriptor_,
      BannedNetworkData::default_instance_,
      BannedNetworkData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BannedNetworkData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BannedNetworkData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BannedNetworkData));
  GetNetlistResponse_descriptor_ = file->message_type(62);
  static const int GetNetlistResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlistResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlistResponse, networks_),
  };
  GetNetlistResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetNetlistResponse_descriptor_,
      GetNetlistResponse::default_instance_,
      GetNetlistResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlistResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetNetlistResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetNetlistResponse));
  GetBanlist_descriptor_ = file->message_type(63);
  static const int GetBanlist_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlist, count_),
  };
  GetBanlist_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetBanlist_descriptor_,
      GetBanlist::default_instance_,
      GetBanlist_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlist, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlist, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetBanlist));
  GetBanlistResponse_descriptor_ = file->message_type(64);
  static const int GetBanlistResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlistResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlistResponse, nodes_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlistResponse, agent_ids_),
  };
  GetBanlistResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetBanlistResponse_descriptor_,
      GetBanlistResponse::default_instance_,
      GetBanlistResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlistResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBanlistResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetBanlistResponse));
  GetBannets_descriptor_ = file->message_type(65);
  static const int GetBannets_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannets, count_),
  };
  GetBannets_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetBannets_descriptor_,
      GetBannets::default_instance_,
      GetBannets_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannets, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannets, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetBannets));
  GetBannetsResponse_descriptor_ = file->message_type(66);
  static const int GetBannetsResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannetsResponse, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannetsResponse, networks_),
  };
  GetBannetsResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetBannetsResponse_descriptor_,
      GetBannetsResponse::default_instance_,
      GetBannetsResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannetsResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetBannetsResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetBannetsResponse));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Trace_descriptor_, &Trace::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TraceRoute_descriptor_, &TraceRoute::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ICMReport_descriptor_, &ICMReport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WebsiteReportDetail_descriptor_, &WebsiteReportDetail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WebsiteReport_descriptor_, &WebsiteReport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServiceReportDetail_descriptor_, &ServiceReportDetail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServiceReport_descriptor_, &ServiceReport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RequestHeader_descriptor_, &RequestHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResponseHeader_descriptor_, &ResponseHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterAgent_descriptor_, &RegisterAgent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterAgentResponse_descriptor_, &RegisterAgentResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RSAKey_descriptor_, &RSAKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckAggregator_descriptor_, &CheckAggregator::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CheckAggregatorResponse_descriptor_, &CheckAggregatorResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Login_descriptor_, &Login::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginStep1_descriptor_, &LoginStep1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginStep2_descriptor_, &LoginStep2::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginResponse_descriptor_, &LoginResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Logout_descriptor_, &Logout::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LogoutResponse_descriptor_, &LogoutResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetPeerList_descriptor_, &GetPeerList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AgentData_descriptor_, &AgentData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetPeerListResponse_descriptor_, &GetPeerListResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetSuperPeerList_descriptor_, &GetSuperPeerList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetSuperPeerListResponse_descriptor_, &GetSuperPeerListResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Location_descriptor_, &Location::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetEvents_descriptor_, &GetEvents::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Event_descriptor_, &Event::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetEventsResponse_descriptor_, &GetEventsResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendWebsiteReport_descriptor_, &SendWebsiteReport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendServiceReport_descriptor_, &SendServiceReport::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendReportResponse_descriptor_, &SendReportResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewVersion_descriptor_, &NewVersion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewVersionResponse_descriptor_, &NewVersionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewTests_descriptor_, &NewTests::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Website_descriptor_, &Website::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Service_descriptor_, &Service::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Test_descriptor_, &Test::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewTestsResponse_descriptor_, &NewTestsResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AssignTask_descriptor_, &AssignTask::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AssignTaskResponse_descriptor_, &AssignTaskResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpgradeToSuper_descriptor_, &UpgradeToSuper::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpgradeToSuperResponse_descriptor_, &UpgradeToSuperResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WebsiteSuggestion_descriptor_, &WebsiteSuggestion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServiceSuggestion_descriptor_, &ServiceSuggestion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TestSuggestionResponse_descriptor_, &TestSuggestionResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AuthenticatePeer_descriptor_, &AuthenticatePeer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AuthenticatePeerResponse_descriptor_, &AuthenticatePeerResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    P2PGetSuperPeerList_descriptor_, &P2PGetSuperPeerList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    P2PGetSuperPeerListResponse_descriptor_, &P2PGetSuperPeerListResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    P2PGetPeerList_descriptor_, &P2PGetPeerList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    P2PGetPeerListResponse_descriptor_, &P2PGetPeerListResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AgentUpdate_descriptor_, &AgentUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AgentUpdateResponse_descriptor_, &AgentUpdateResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TestModuleUpdate_descriptor_, &TestModuleUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TestModuleUpdateResponse_descriptor_, &TestModuleUpdateResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ForwardingMessage_descriptor_, &ForwardingMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ForwardingMessageResponse_descriptor_, &ForwardingMessageResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginCredentials_descriptor_, &LoginCredentials::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetNetlist_descriptor_, &GetNetlist::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetworkData_descriptor_, &NetworkData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BannedNetworkData_descriptor_, &BannedNetworkData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetNetlistResponse_descriptor_, &GetNetlistResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetBanlist_descriptor_, &GetBanlist::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetBanlistResponse_descriptor_, &GetBanlistResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetBannets_descriptor_, &GetBannets::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetBannetsResponse_descriptor_, &GetBannetsResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete Trace::default_instance_;
  delete Trace_reflection_;
  delete TraceRoute::default_instance_;
  delete TraceRoute_reflection_;
  delete ICMReport::default_instance_;
  delete ICMReport_reflection_;
  delete WebsiteReportDetail::default_instance_;
  delete WebsiteReportDetail_reflection_;
  delete WebsiteReport::default_instance_;
  delete WebsiteReport_reflection_;
  delete ServiceReportDetail::default_instance_;
  delete ServiceReportDetail_reflection_;
  delete ServiceReport::default_instance_;
  delete ServiceReport_reflection_;
  delete RequestHeader::default_instance_;
  delete RequestHeader_reflection_;
  delete ResponseHeader::default_instance_;
  delete ResponseHeader_reflection_;
  delete RegisterAgent::default_instance_;
  delete RegisterAgent_reflection_;
  delete RegisterAgentResponse::default_instance_;
  delete RegisterAgentResponse_reflection_;
  delete RSAKey::default_instance_;
  delete RSAKey_reflection_;
  delete CheckAggregator::default_instance_;
  delete CheckAggregator_reflection_;
  delete CheckAggregatorResponse::default_instance_;
  delete CheckAggregatorResponse_reflection_;
  delete Login::default_instance_;
  delete Login_reflection_;
  delete LoginStep1::default_instance_;
  delete LoginStep1_reflection_;
  delete LoginStep2::default_instance_;
  delete LoginStep2_reflection_;
  delete LoginResponse::default_instance_;
  delete LoginResponse_reflection_;
  delete Logout::default_instance_;
  delete Logout_reflection_;
  delete LogoutResponse::default_instance_;
  delete LogoutResponse_reflection_;
  delete GetPeerList::default_instance_;
  delete GetPeerList_reflection_;
  delete AgentData::default_instance_;
  delete AgentData_reflection_;
  delete GetPeerListResponse::default_instance_;
  delete GetPeerListResponse_reflection_;
  delete GetSuperPeerList::default_instance_;
  delete GetSuperPeerList_reflection_;
  delete GetSuperPeerListResponse::default_instance_;
  delete GetSuperPeerListResponse_reflection_;
  delete Location::default_instance_;
  delete Location_reflection_;
  delete GetEvents::default_instance_;
  delete GetEvents_reflection_;
  delete Event::default_instance_;
  delete Event_reflection_;
  delete GetEventsResponse::default_instance_;
  delete GetEventsResponse_reflection_;
  delete SendWebsiteReport::default_instance_;
  delete SendWebsiteReport_reflection_;
  delete SendServiceReport::default_instance_;
  delete SendServiceReport_reflection_;
  delete SendReportResponse::default_instance_;
  delete SendReportResponse_reflection_;
  delete NewVersion::default_instance_;
  delete NewVersion_reflection_;
  delete NewVersionResponse::default_instance_;
  delete NewVersionResponse_reflection_;
  delete NewTests::default_instance_;
  delete NewTests_reflection_;
  delete Website::default_instance_;
  delete Website_reflection_;
  delete Service::default_instance_;
  delete Service_reflection_;
  delete Test::default_instance_;
  delete Test_reflection_;
  delete NewTestsResponse::default_instance_;
  delete NewTestsResponse_reflection_;
  delete AssignTask::default_instance_;
  delete AssignTask_reflection_;
  delete AssignTaskResponse::default_instance_;
  delete AssignTaskResponse_reflection_;
  delete UpgradeToSuper::default_instance_;
  delete UpgradeToSuper_reflection_;
  delete UpgradeToSuperResponse::default_instance_;
  delete UpgradeToSuperResponse_reflection_;
  delete WebsiteSuggestion::default_instance_;
  delete WebsiteSuggestion_reflection_;
  delete ServiceSuggestion::default_instance_;
  delete ServiceSuggestion_reflection_;
  delete TestSuggestionResponse::default_instance_;
  delete TestSuggestionResponse_reflection_;
  delete AuthenticatePeer::default_instance_;
  delete AuthenticatePeer_reflection_;
  delete AuthenticatePeerResponse::default_instance_;
  delete AuthenticatePeerResponse_reflection_;
  delete P2PGetSuperPeerList::default_instance_;
  delete P2PGetSuperPeerList_reflection_;
  delete P2PGetSuperPeerListResponse::default_instance_;
  delete P2PGetSuperPeerListResponse_reflection_;
  delete P2PGetPeerList::default_instance_;
  delete P2PGetPeerList_reflection_;
  delete P2PGetPeerListResponse::default_instance_;
  delete P2PGetPeerListResponse_reflection_;
  delete AgentUpdate::default_instance_;
  delete AgentUpdate_reflection_;
  delete AgentUpdateResponse::default_instance_;
  delete AgentUpdateResponse_reflection_;
  delete TestModuleUpdate::default_instance_;
  delete TestModuleUpdate_reflection_;
  delete TestModuleUpdateResponse::default_instance_;
  delete TestModuleUpdateResponse_reflection_;
  delete ForwardingMessage::default_instance_;
  delete ForwardingMessage_reflection_;
  delete ForwardingMessageResponse::default_instance_;
  delete ForwardingMessageResponse_reflection_;
  delete LoginCredentials::default_instance_;
  delete LoginCredentials_reflection_;
  delete GetNetlist::default_instance_;
  delete GetNetlist_reflection_;
  delete NetworkData::default_instance_;
  delete NetworkData_reflection_;
  delete BannedNetworkData::default_instance_;
  delete BannedNetworkData_reflection_;
  delete GetNetlistResponse::default_instance_;
  delete GetNetlistResponse_reflection_;
  delete GetBanlist::default_instance_;
  delete GetBanlist_reflection_;
  delete GetBanlistResponse::default_instance_;
  delete GetBanlistResponse_reflection_;
  delete GetBannets::default_instance_;
  delete GetBannets_reflection_;
  delete GetBannetsResponse::default_instance_;
  delete GetBannetsResponse_reflection_;
}

void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\022\031org.umit.icm.mobile.pr"
    "oto\"7\n\005Trace\022\013\n\003hop\030\001 \002(\005\022\n\n\002ip\030\002 \002(\t\022\025\n"
    "\rpacketsTiming\030\003 \003(\005\"p\n\nTraceRoute\022\016\n\006ta"
    "rget\030\001 \002(\t\022\014\n\004hops\030\002 \002(\005\022\022\n\npacketSize\030\003"
    " \002(\005\0220\n\006traces\030\004 \003(\0132 .org.umit.icm.mobi"
    "le.proto.Trace\"\260\001\n\tICMReport\022\020\n\010reportID"
    "\030\001 \002(\t\022\017\n\007agentID\030\002 \002(\003\022\016\n\006testID\030\003 \002(\005\022"
    "\020\n\010timeZone\030\004 \002(\005\022\017\n\007timeUTC\030\005 \002(\003\022\022\n\npa"
    "ssedNode\030\006 \003(\t\0229\n\ntraceroute\030\007 \001(\0132%.org"
    ".umit.icm.mobile.proto.TraceRoute\"\245\001\n\023We"
    "bsiteReportDetail\022\022\n\nwebsiteURL\030\001 \002(\t\022\022\n"
    "\nstatusCode\030\002 \002(\005\022\024\n\014responseTime\030\003 \001(\005\022"
    "\021\n\tbandwidth\030\004 \001(\005\022\024\n\014redirectLink\030\005 \001(\t"
    "\022\024\n\014htmlResponse\030\006 \001(\t\022\021\n\thtmlMedia\030\007 \001("
    "\014\"\205\001\n\rWebsiteReport\0224\n\006header\030\001 \002(\0132$.or"
    "g.umit.icm.mobile.proto.ICMReport\022>\n\006rep"
    "ort\030\002 \002(\0132..org.umit.icm.mobile.proto.We"
    "bsiteReportDetail\"u\n\023ServiceReportDetail"
    "\022\023\n\013serviceName\030\001 \002(\t\022\022\n\nstatusCode\030\002 \002("
    "\005\022\014\n\004port\030\003 \002(\005\022\024\n\014responseTime\030\004 \001(\001\022\021\n"
    "\tbandwidth\030\005 \001(\001\"\205\001\n\rServiceReport\0224\n\006he"
    "ader\030\001 \002(\0132$.org.umit.icm.mobile.proto.I"
    "CMReport\022>\n\006report\030\002 \002(\0132..org.umit.icm."
    "mobile.proto.ServiceReportDetail\" \n\rRequ"
    "estHeader\022\017\n\007agentID\030\001 \002(\003\"H\n\016ResponseHe"
    "ader\022\030\n\020currentVersionNo\030\001 \002(\005\022\034\n\024curren"
    "tTestVersionNo\030\002 \002(\005\"\276\001\n\rRegisterAgent\022\021"
    "\n\tversionNo\030\001 \002(\005\022\021\n\tagentType\030\002 \002(\t\022@\n\013"
    "credentials\030\003 \002(\0132+.org.umit.icm.mobile."
    "proto.LoginCredentials\0229\n\016agentPublicKey"
    "\030\004 \002(\0132!.org.umit.icm.mobile.proto.RSAKe"
    "y\022\n\n\002ip\030\005 \001(\t\"z\n\025RegisterAgentResponse\0229"
    "\n\006header\030\001 \002(\0132).org.umit.icm.mobile.pro"
    "to.ResponseHeader\022\017\n\007agentID\030\002 \002(\003\022\025\n\rpu"
    "blicKeyHash\030\003 \002(\t\"\"\n\006RSAKey\022\013\n\003mod\030\001 \002(\t"
    "\022\013\n\003exp\030\002 \002(\t\"$\n\017CheckAggregator\022\021\n\tagen"
    "tType\030\001 \002(\t\"d\n\027CheckAggregatorResponse\0229"
    "\n\006header\030\001 \002(\0132).org.umit.icm.mobile.pro"
    "to.ResponseHeader\022\016\n\006status\030\002 \002(\t\"E\n\005Log"
    "in\022\017\n\007agentID\030\001 \002(\003\022\021\n\tchallenge\030\002 \002(\t\022\014"
    "\n\004port\030\003 \002(\003\022\n\n\002ip\030\004 \001(\t\"M\n\nLoginStep1\022\021"
    "\n\tprocessID\030\001 \002(\003\022\031\n\021cipheredChallenge\030\002"
    " \002(\t\022\021\n\tchallenge\030\003 \002(\t\":\n\nLoginStep2\022\021\n"
    "\tprocessID\030\001 \002(\003\022\031\n\021cipheredChallenge\030\002 "
    "\002(\t\"J\n\rLoginResponse\0229\n\006header\030\001 \002(\0132).o"
    "rg.umit.icm.mobile.proto.ResponseHeader\""
    "\031\n\006Logout\022\017\n\007agentID\030\001 \002(\003\" \n\016LogoutResp"
    "onse\022\016\n\006status\030\001 \002(\t\"\034\n\013GetPeerList\022\r\n\005c"
    "ount\030\001 \001(\005\"\231\001\n\tAgentData\022\017\n\007agentID\030\001 \002("
    "\003\022\017\n\007agentIP\030\002 \002(\t\022\021\n\tagentPort\030\003 \002(\005\022\r\n"
    "\005token\030\004 \002(\t\0224\n\tpublicKey\030\005 \002(\0132!.org.um"
    "it.icm.mobile.proto.RSAKey\022\022\n\npeerStatus"
    "\030\006 \002(\t\"\212\001\n\023GetPeerListResponse\0229\n\006header"
    "\030\001 \002(\0132).org.umit.icm.mobile.proto.Respo"
    "nseHeader\0228\n\nknownPeers\030\002 \003(\0132$.org.umit"
    ".icm.mobile.proto.AgentData\"!\n\020GetSuperP"
    "eerList\022\r\n\005count\030\001 \001(\005\"\224\001\n\030GetSuperPeerL"
    "istResponse\0229\n\006header\030\001 \002(\0132).org.umit.i"
    "cm.mobile.proto.ResponseHeader\022=\n\017knownS"
    "uperPeers\030\002 \003(\0132$.org.umit.icm.mobile.pr"
    "oto.AgentData\"/\n\010Location\022\021\n\tlongitude\030\001"
    " \002(\001\022\020\n\010latitude\030\002 \002(\001\"\177\n\tGetEvents\0226\n\tl"
    "ocations\030\001 \003(\0132#.org.umit.icm.mobile.pro"
    "to.Location\022:\n\ragentLocation\030\002 \001(\0132#.org"
    ".umit.icm.mobile.proto.Location\"\231\002\n\005Even"
    "t\022\020\n\010testType\030\001 \002(\t\022\021\n\teventType\030\002 \002(\t\022\017"
    "\n\007timeUTC\030\003 \002(\003\022\024\n\014sinceTimeUTC\030\004 \002(\003\0226\n"
    "\tlocations\030\005 \003(\0132#.org.umit.icm.mobile.p"
    "roto.Location\022E\n\rwebsiteReport\030\006 \001(\0132..o"
    "rg.umit.icm.mobile.proto.WebsiteReportDe"
    "tail\022E\n\rserviceReport\030\007 \001(\0132..org.umit.i"
    "cm.mobile.proto.ServiceReportDetail\"\200\001\n\021"
    "GetEventsResponse\0229\n\006header\030\001 \002(\0132).org."
    "umit.icm.mobile.proto.ResponseHeader\0220\n\006"
    "events\030\002 \003(\0132 .org.umit.icm.mobile.proto"
    ".Event\"M\n\021SendWebsiteReport\0228\n\006report\030\001 "
    "\002(\0132(.org.umit.icm.mobile.proto.WebsiteR"
    "eport\"M\n\021SendServiceReport\0228\n\006report\030\001 \002"
    "(\0132(.org.umit.icm.mobile.proto.ServiceRe"
    "port\"O\n\022SendReportResponse\0229\n\006header\030\001 \002"
    "(\0132).org.umit.icm.mobile.proto.ResponseH"
    "eader\"7\n\nNewVersion\022\026\n\016agentVersionNo\030\001 "
    "\002(\005\022\021\n\tagentType\030\002 \002(\t\"\207\001\n\022NewVersionRes"
    "ponse\0229\n\006header\030\001 \002(\0132).org.umit.icm.mob"
    "ile.proto.ResponseHeader\022\023\n\013downloadURL\030"
    "\002 \001(\t\022\016\n\006update\030\003 \001(\014\022\021\n\tversionNo\030\004 \002(\005"
    "\"(\n\010NewTests\022\034\n\024currentTestVersionNo\030\001 \002"
    "(\005\"\026\n\007Website\022\013\n\003url\030\001 \002(\t\"1\n\007Service\022\014\n"
    "\004name\030\001 \002(\t\022\014\n\004port\030\002 \002(\005\022\n\n\002ip\030\003 \002(\t\"\254\001"
    "\n\004Test\022\016\n\006testID\030\001 \002(\003\0223\n\007website\030\002 \001(\0132"
    "\".org.umit.icm.mobile.proto.Website\0223\n\007s"
    "ervice\030\003 \001(\0132\".org.umit.icm.mobile.proto"
    ".Service\022\030\n\020executeAtTimeUTC\030\004 \001(\003\022\020\n\010te"
    "stType\030\005 \002(\t\"\224\001\n\020NewTestsResponse\0229\n\006hea"
    "der\030\001 \002(\0132).org.umit.icm.mobile.proto.Re"
    "sponseHeader\022.\n\005tests\030\002 \003(\0132\037.org.umit.i"
    "cm.mobile.proto.Test\022\025\n\rtestVersionNo\030\003 "
    "\002(\005\"F\n\nAssignTask\0228\n\006header\030\001 \002(\0132(.org."
    "umit.icm.mobile.proto.RequestHeader\"\177\n\022A"
    "ssignTaskResponse\0229\n\006header\030\001 \002(\0132).org."
    "umit.icm.mobile.proto.ResponseHeader\022.\n\005"
    "tests\030\002 \003(\0132\037.org.umit.icm.mobile.proto."
    "Test\"J\n\016UpgradeToSuper\0228\n\006header\030\001 \002(\0132("
    ".org.umit.icm.mobile.proto.RequestHeader"
    "\"\330\001\n\026UpgradeToSuperResponse\0229\n\006header\030\001 "
    "\002(\0132).org.umit.icm.mobile.proto.Response"
    "Header\022\020\n\010newToken\030\002 \002(\t\0228\n\rnewPrivateKe"
    "y\030\003 \002(\0132!.org.umit.icm.mobile.proto.RSAK"
    "ey\0227\n\014newPublicKey\030\004 \002(\0132!.org.umit.icm."
    "mobile.proto.RSAKey\"\'\n\021WebsiteSuggestion"
    "\022\022\n\nwebsiteURL\030\001 \002(\t\"T\n\021ServiceSuggestio"
    "n\022\023\n\013serviceName\030\001 \002(\t\022\020\n\010hostName\030\002 \002(\t"
    "\022\n\n\002ip\030\003 \002(\t\022\014\n\004port\030\004 \002(\003\"S\n\026TestSugges"
    "tionResponse\0229\n\006header\030\001 \002(\0132).org.umit."
    "icm.mobile.proto.ResponseHeader\"\207\001\n\020Auth"
    "enticatePeer\022\021\n\tagentType\030\001 \002(\005\022\017\n\007agent"
    "ID\030\002 \002(\003\022<\n\021cipheredPublicKey\030\003 \002(\0132!.or"
    "g.umit.icm.mobile.proto.RSAKey\022\021\n\tagentP"
    "ort\030\004 \001(\005\"g\n\030AuthenticatePeerResponse\022<\n"
    "\021cipheredPublicKey\030\001 \002(\0132!.org.umit.icm."
    "mobile.proto.RSAKey\022\r\n\005token\030\002 \002(\t\"$\n\023P2"
    "PGetSuperPeerList\022\r\n\005count\030\001 \002(\005\"R\n\033P2PG"
    "etSuperPeerListResponse\0223\n\005peers\030\001 \003(\0132$"
    ".org.umit.icm.mobile.proto.AgentData\"\037\n\016"
    "P2PGetPeerList\022\r\n\005count\030\001 \002(\005\"M\n\026P2PGetP"
    "eerListResponse\0223\n\005peers\030\001 \003(\0132$.org.umi"
    "t.icm.mobile.proto.AgentData\"F\n\013AgentUpd"
    "ate\022\017\n\007version\030\001 \002(\t\022\023\n\013downloadURL\030\002 \002("
    "\t\022\021\n\tcheckCode\030\003 \001(\005\"6\n\023AgentUpdateRespo"
    "nse\022\017\n\007version\030\001 \002(\t\022\016\n\006result\030\002 \002(\t\"K\n\020"
    "TestModuleUpdate\022\017\n\007version\030\001 \002(\t\022\023\n\013dow"
    "nloadURL\030\002 \002(\t\022\021\n\tcheckCode\030\003 \001(\005\";\n\030Tes"
    "tModuleUpdateResponse\022\017\n\007version\030\001 \002(\t\022\016"
    "\n\006result\030\002 \002(\t\"T\n\021ForwardingMessage\022\023\n\013d"
    "estination\030\001 \002(\003\022\022\n\nidentifier\030\002 \002(\t\022\026\n\016"
    "encodedMessage\030\003 \002(\t\"G\n\031ForwardingMessag"
    "eResponse\022\022\n\nidentifier\030\001 \002(\t\022\026\n\016encoded"
    "Message\030\002 \002(\t\"6\n\020LoginCredentials\022\020\n\010use"
    "rname\030\001 \002(\t\022\020\n\010password\030\002 \002(\t\"\032\n\nGetNetl"
    "ist\022\014\n\004list\030\001 \002(\005\"\201\001\n\013NetworkData\022\020\n\010sta"
    "rt_ip\030\001 \002(\005\022\016\n\006end_ip\030\002 \002(\005\022\033\n\023nodes_cou"
    "nt_network\030\003 \001(\005\0223\n\005nodes\030\004 \003(\0132$.org.um"
    "it.icm.mobile.proto.AgentData\"Y\n\021BannedN"
    "etworkData\022\020\n\010start_ip\030\001 \002(\005\022\016\n\006end_ip\030\002"
    " \002(\005\022\023\n\013nodes_count\030\003 \001(\005\022\r\n\005flags\030\004 \002(\005"
    "\"\211\001\n\022GetNetlistResponse\0229\n\006header\030\001 \002(\0132"
    ").org.umit.icm.mobile.proto.ResponseHead"
    "er\0228\n\010networks\030\002 \003(\0132&.org.umit.icm.mobi"
    "le.proto.NetworkData\"\033\n\nGetBanlist\022\r\n\005co"
    "unt\030\001 \002(\005\"w\n\022GetBanlistResponse\0229\n\006heade"
    "r\030\001 \002(\0132).org.umit.icm.mobile.proto.Resp"
    "onseHeader\022\023\n\013nodes_count\030\002 \002(\005\022\021\n\tagent"
    "_ids\030\003 \003(\005\"\033\n\nGetBannets\022\r\n\005count\030\001 \002(\005\""
    "\217\001\n\022GetBannetsResponse\0229\n\006header\030\001 \002(\0132)"
    ".org.umit.icm.mobile.proto.ResponseHeade"
    "r\022>\n\010networks\030\002 \003(\0132,.org.umit.icm.mobil"
    "e.proto.BannedNetworkDataB\017B\rMessageProt"
    "os", 6282);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  Trace::default_instance_ = new Trace();
  TraceRoute::default_instance_ = new TraceRoute();
  ICMReport::default_instance_ = new ICMReport();
  WebsiteReportDetail::default_instance_ = new WebsiteReportDetail();
  WebsiteReport::default_instance_ = new WebsiteReport();
  ServiceReportDetail::default_instance_ = new ServiceReportDetail();
  ServiceReport::default_instance_ = new ServiceReport();
  RequestHeader::default_instance_ = new RequestHeader();
  ResponseHeader::default_instance_ = new ResponseHeader();
  RegisterAgent::default_instance_ = new RegisterAgent();
  RegisterAgentResponse::default_instance_ = new RegisterAgentResponse();
  RSAKey::default_instance_ = new RSAKey();
  CheckAggregator::default_instance_ = new CheckAggregator();
  CheckAggregatorResponse::default_instance_ = new CheckAggregatorResponse();
  Login::default_instance_ = new Login();
  LoginStep1::default_instance_ = new LoginStep1();
  LoginStep2::default_instance_ = new LoginStep2();
  LoginResponse::default_instance_ = new LoginResponse();
  Logout::default_instance_ = new Logout();
  LogoutResponse::default_instance_ = new LogoutResponse();
  GetPeerList::default_instance_ = new GetPeerList();
  AgentData::default_instance_ = new AgentData();
  GetPeerListResponse::default_instance_ = new GetPeerListResponse();
  GetSuperPeerList::default_instance_ = new GetSuperPeerList();
  GetSuperPeerListResponse::default_instance_ = new GetSuperPeerListResponse();
  Location::default_instance_ = new Location();
  GetEvents::default_instance_ = new GetEvents();
  Event::default_instance_ = new Event();
  GetEventsResponse::default_instance_ = new GetEventsResponse();
  SendWebsiteReport::default_instance_ = new SendWebsiteReport();
  SendServiceReport::default_instance_ = new SendServiceReport();
  SendReportResponse::default_instance_ = new SendReportResponse();
  NewVersion::default_instance_ = new NewVersion();
  NewVersionResponse::default_instance_ = new NewVersionResponse();
  NewTests::default_instance_ = new NewTests();
  Website::default_instance_ = new Website();
  Service::default_instance_ = new Service();
  Test::default_instance_ = new Test();
  NewTestsResponse::default_instance_ = new NewTestsResponse();
  AssignTask::default_instance_ = new AssignTask();
  AssignTaskResponse::default_instance_ = new AssignTaskResponse();
  UpgradeToSuper::default_instance_ = new UpgradeToSuper();
  UpgradeToSuperResponse::default_instance_ = new UpgradeToSuperResponse();
  WebsiteSuggestion::default_instance_ = new WebsiteSuggestion();
  ServiceSuggestion::default_instance_ = new ServiceSuggestion();
  TestSuggestionResponse::default_instance_ = new TestSuggestionResponse();
  AuthenticatePeer::default_instance_ = new AuthenticatePeer();
  AuthenticatePeerResponse::default_instance_ = new AuthenticatePeerResponse();
  P2PGetSuperPeerList::default_instance_ = new P2PGetSuperPeerList();
  P2PGetSuperPeerListResponse::default_instance_ = new P2PGetSuperPeerListResponse();
  P2PGetPeerList::default_instance_ = new P2PGetPeerList();
  P2PGetPeerListResponse::default_instance_ = new P2PGetPeerListResponse();
  AgentUpdate::default_instance_ = new AgentUpdate();
  AgentUpdateResponse::default_instance_ = new AgentUpdateResponse();
  TestModuleUpdate::default_instance_ = new TestModuleUpdate();
  TestModuleUpdateResponse::default_instance_ = new TestModuleUpdateResponse();
  ForwardingMessage::default_instance_ = new ForwardingMessage();
  ForwardingMessageResponse::default_instance_ = new ForwardingMessageResponse();
  LoginCredentials::default_instance_ = new LoginCredentials();
  GetNetlist::default_instance_ = new GetNetlist();
  NetworkData::default_instance_ = new NetworkData();
  BannedNetworkData::default_instance_ = new BannedNetworkData();
  GetNetlistResponse::default_instance_ = new GetNetlistResponse();
  GetBanlist::default_instance_ = new GetBanlist();
  GetBanlistResponse::default_instance_ = new GetBanlistResponse();
  GetBannets::default_instance_ = new GetBannets();
  GetBannetsResponse::default_instance_ = new GetBannetsResponse();
  Trace::default_instance_->InitAsDefaultInstance();
  TraceRoute::default_instance_->InitAsDefaultInstance();
  ICMReport::default_instance_->InitAsDefaultInstance();
  WebsiteReportDetail::default_instance_->InitAsDefaultInstance();
  WebsiteReport::default_instance_->InitAsDefaultInstance();
  ServiceReportDetail::default_instance_->InitAsDefaultInstance();
  ServiceReport::default_instance_->InitAsDefaultInstance();
  RequestHeader::default_instance_->InitAsDefaultInstance();
  ResponseHeader::default_instance_->InitAsDefaultInstance();
  RegisterAgent::default_instance_->InitAsDefaultInstance();
  RegisterAgentResponse::default_instance_->InitAsDefaultInstance();
  RSAKey::default_instance_->InitAsDefaultInstance();
  CheckAggregator::default_instance_->InitAsDefaultInstance();
  CheckAggregatorResponse::default_instance_->InitAsDefaultInstance();
  Login::default_instance_->InitAsDefaultInstance();
  LoginStep1::default_instance_->InitAsDefaultInstance();
  LoginStep2::default_instance_->InitAsDefaultInstance();
  LoginResponse::default_instance_->InitAsDefaultInstance();
  Logout::default_instance_->InitAsDefaultInstance();
  LogoutResponse::default_instance_->InitAsDefaultInstance();
  GetPeerList::default_instance_->InitAsDefaultInstance();
  AgentData::default_instance_->InitAsDefaultInstance();
  GetPeerListResponse::default_instance_->InitAsDefaultInstance();
  GetSuperPeerList::default_instance_->InitAsDefaultInstance();
  GetSuperPeerListResponse::default_instance_->InitAsDefaultInstance();
  Location::default_instance_->InitAsDefaultInstance();
  GetEvents::default_instance_->InitAsDefaultInstance();
  Event::default_instance_->InitAsDefaultInstance();
  GetEventsResponse::default_instance_->InitAsDefaultInstance();
  SendWebsiteReport::default_instance_->InitAsDefaultInstance();
  SendServiceReport::default_instance_->InitAsDefaultInstance();
  SendReportResponse::default_instance_->InitAsDefaultInstance();
  NewVersion::default_instance_->InitAsDefaultInstance();
  NewVersionResponse::default_instance_->InitAsDefaultInstance();
  NewTests::default_instance_->InitAsDefaultInstance();
  Website::default_instance_->InitAsDefaultInstance();
  Service::default_instance_->InitAsDefaultInstance();
  Test::default_instance_->InitAsDefaultInstance();
  NewTestsResponse::default_instance_->InitAsDefaultInstance();
  AssignTask::default_instance_->InitAsDefaultInstance();
  AssignTaskResponse::default_instance_->InitAsDefaultInstance();
  UpgradeToSuper::default_instance_->InitAsDefaultInstance();
  UpgradeToSuperResponse::default_instance_->InitAsDefaultInstance();
  WebsiteSuggestion::default_instance_->InitAsDefaultInstance();
  ServiceSuggestion::default_instance_->InitAsDefaultInstance();
  TestSuggestionResponse::default_instance_->InitAsDefaultInstance();
  AuthenticatePeer::default_instance_->InitAsDefaultInstance();
  AuthenticatePeerResponse::default_instance_->InitAsDefaultInstance();
  P2PGetSuperPeerList::default_instance_->InitAsDefaultInstance();
  P2PGetSuperPeerListResponse::default_instance_->InitAsDefaultInstance();
  P2PGetPeerList::default_instance_->InitAsDefaultInstance();
  P2PGetPeerListResponse::default_instance_->InitAsDefaultInstance();
  AgentUpdate::default_instance_->InitAsDefaultInstance();
  AgentUpdateResponse::default_instance_->InitAsDefaultInstance();
  TestModuleUpdate::default_instance_->InitAsDefaultInstance();
  TestModuleUpdateResponse::default_instance_->InitAsDefaultInstance();
  ForwardingMessage::default_instance_->InitAsDefaultInstance();
  ForwardingMessageResponse::default_instance_->InitAsDefaultInstance();
  LoginCredentials::default_instance_->InitAsDefaultInstance();
  GetNetlist::default_instance_->InitAsDefaultInstance();
  NetworkData::default_instance_->InitAsDefaultInstance();
  BannedNetworkData::default_instance_->InitAsDefaultInstance();
  GetNetlistResponse::default_instance_->InitAsDefaultInstance();
  GetBanlist::default_instance_->InitAsDefaultInstance();
  GetBanlistResponse::default_instance_->InitAsDefaultInstance();
  GetBannets::default_instance_->InitAsDefaultInstance();
  GetBannetsResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int Trace::kHopFieldNumber;
const int Trace::kIpFieldNumber;
const int Trace::kPacketsTimingFieldNumber;
#endif  // !_MSC_VER

Trace::Trace()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Trace::InitAsDefaultInstance() {
}

Trace::Trace(const Trace& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Trace::SharedCtor() {
  _cached_size_ = 0;
  hop_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Trace::~Trace() {
  SharedDtor();
}

void Trace::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void Trace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Trace::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Trace_descriptor_;
}

const Trace& Trace::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Trace* Trace::default_instance_ = NULL;

Trace* Trace::New() const {
  return new Trace;
}

void Trace::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    hop_ = 0;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
  }
  packetstiming_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Trace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 hop = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hop_)));
          set_has_hop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }
      
      // required string ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_packetsTiming;
        break;
      }
      
      // repeated int32 packetsTiming = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_packetsTiming:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_packetstiming())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_packetstiming())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_packetsTiming;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Trace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 hop = 1;
  if (has_hop()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->hop(), output);
  }
  
  // required string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ip(), output);
  }
  
  // repeated int32 packetsTiming = 3;
  for (int i = 0; i < this->packetstiming_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->packetstiming(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Trace::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 hop = 1;
  if (has_hop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->hop(), target);
  }
  
  // required string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip(), target);
  }
  
  // repeated int32 packetsTiming = 3;
  for (int i = 0; i < this->packetstiming_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->packetstiming(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Trace::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 hop = 1;
    if (has_hop()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hop());
    }
    
    // required string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
  }
  // repeated int32 packetsTiming = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->packetstiming_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->packetstiming(i));
    }
    total_size += 1 * this->packetstiming_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Trace::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Trace* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Trace*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Trace::MergeFrom(const Trace& from) {
  GOOGLE_CHECK_NE(&from, this);
  packetstiming_.MergeFrom(from.packetstiming_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hop()) {
      set_hop(from.hop());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Trace::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Trace::CopyFrom(const Trace& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trace::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Trace::Swap(Trace* other) {
  if (other != this) {
    std::swap(hop_, other->hop_);
    std::swap(ip_, other->ip_);
    packetstiming_.Swap(&other->packetstiming_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Trace::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Trace_descriptor_;
  metadata.reflection = Trace_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TraceRoute::kTargetFieldNumber;
const int TraceRoute::kHopsFieldNumber;
const int TraceRoute::kPacketSizeFieldNumber;
const int TraceRoute::kTracesFieldNumber;
#endif  // !_MSC_VER

TraceRoute::TraceRoute()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TraceRoute::InitAsDefaultInstance() {
}

TraceRoute::TraceRoute(const TraceRoute& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TraceRoute::SharedCtor() {
  _cached_size_ = 0;
  target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hops_ = 0;
  packetsize_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceRoute::~TraceRoute() {
  SharedDtor();
}

void TraceRoute::SharedDtor() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    delete target_;
  }
  if (this != default_instance_) {
  }
}

void TraceRoute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TraceRoute::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TraceRoute_descriptor_;
}

const TraceRoute& TraceRoute::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

TraceRoute* TraceRoute::default_instance_ = NULL;

TraceRoute* TraceRoute::New() const {
  return new TraceRoute;
}

void TraceRoute::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_target()) {
      if (target_ != &::google::protobuf::internal::kEmptyString) {
        target_->clear();
      }
    }
    hops_ = 0;
    packetsize_ = 0;
  }
  traces_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TraceRoute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string target = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_target()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->target().data(), this->target().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_hops;
        break;
      }
      
      // required int32 hops = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_hops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hops_)));
          set_has_hops();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_packetSize;
        break;
      }
      
      // required int32 packetSize = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_packetSize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &packetsize_)));
          set_has_packetsize();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_traces;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.Trace traces = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_traces:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_traces()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_traces;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TraceRoute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string target = 1;
  if (has_target()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target().data(), this->target().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->target(), output);
  }
  
  // required int32 hops = 2;
  if (has_hops()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->hops(), output);
  }
  
  // required int32 packetSize = 3;
  if (has_packetsize()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->packetsize(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.Trace traces = 4;
  for (int i = 0; i < this->traces_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->traces(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TraceRoute::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string target = 1;
  if (has_target()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->target().data(), this->target().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->target(), target);
  }
  
  // required int32 hops = 2;
  if (has_hops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->hops(), target);
  }
  
  // required int32 packetSize = 3;
  if (has_packetsize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->packetsize(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.Trace traces = 4;
  for (int i = 0; i < this->traces_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->traces(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TraceRoute::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string target = 1;
    if (has_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->target());
    }
    
    // required int32 hops = 2;
    if (has_hops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->hops());
    }
    
    // required int32 packetSize = 3;
    if (has_packetsize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->packetsize());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.Trace traces = 4;
  total_size += 1 * this->traces_size();
  for (int i = 0; i < this->traces_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->traces(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceRoute::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TraceRoute* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TraceRoute*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TraceRoute::MergeFrom(const TraceRoute& from) {
  GOOGLE_CHECK_NE(&from, this);
  traces_.MergeFrom(from.traces_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target()) {
      set_target(from.target());
    }
    if (from.has_hops()) {
      set_hops(from.hops());
    }
    if (from.has_packetsize()) {
      set_packetsize(from.packetsize());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TraceRoute::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TraceRoute::CopyFrom(const TraceRoute& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceRoute::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < traces_size(); i++) {
    if (!this->traces(i).IsInitialized()) return false;
  }
  return true;
}

void TraceRoute::Swap(TraceRoute* other) {
  if (other != this) {
    std::swap(target_, other->target_);
    std::swap(hops_, other->hops_);
    std::swap(packetsize_, other->packetsize_);
    traces_.Swap(&other->traces_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TraceRoute::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TraceRoute_descriptor_;
  metadata.reflection = TraceRoute_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ICMReport::kReportIDFieldNumber;
const int ICMReport::kAgentIDFieldNumber;
const int ICMReport::kTestIDFieldNumber;
const int ICMReport::kTimeZoneFieldNumber;
const int ICMReport::kTimeUTCFieldNumber;
const int ICMReport::kPassedNodeFieldNumber;
const int ICMReport::kTracerouteFieldNumber;
#endif  // !_MSC_VER

ICMReport::ICMReport()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ICMReport::InitAsDefaultInstance() {
  traceroute_ = const_cast< ::org::umit::icm::mobile::proto::TraceRoute*>(&::org::umit::icm::mobile::proto::TraceRoute::default_instance());
}

ICMReport::ICMReport(const ICMReport& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ICMReport::SharedCtor() {
  _cached_size_ = 0;
  reportid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  agentid_ = GOOGLE_LONGLONG(0);
  testid_ = 0;
  timezone_ = 0;
  timeutc_ = GOOGLE_LONGLONG(0);
  traceroute_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ICMReport::~ICMReport() {
  SharedDtor();
}

void ICMReport::SharedDtor() {
  if (reportid_ != &::google::protobuf::internal::kEmptyString) {
    delete reportid_;
  }
  if (this != default_instance_) {
    delete traceroute_;
  }
}

void ICMReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ICMReport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ICMReport_descriptor_;
}

const ICMReport& ICMReport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ICMReport* ICMReport::default_instance_ = NULL;

ICMReport* ICMReport::New() const {
  return new ICMReport;
}

void ICMReport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_reportid()) {
      if (reportid_ != &::google::protobuf::internal::kEmptyString) {
        reportid_->clear();
      }
    }
    agentid_ = GOOGLE_LONGLONG(0);
    testid_ = 0;
    timezone_ = 0;
    timeutc_ = GOOGLE_LONGLONG(0);
    if (has_traceroute()) {
      if (traceroute_ != NULL) traceroute_->::org::umit::icm::mobile::proto::TraceRoute::Clear();
    }
  }
  passednode_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ICMReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string reportID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_reportid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->reportid().data(), this->reportid().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_agentID;
        break;
      }
      
      // required int64 agentID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_agentID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_testID;
        break;
      }
      
      // required int32 testID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_testID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &testid_)));
          set_has_testid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_timeZone;
        break;
      }
      
      // required int32 timeZone = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeZone:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timezone_)));
          set_has_timezone();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_timeUTC;
        break;
      }
      
      // required int64 timeUTC = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeUTC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timeutc_)));
          set_has_timeutc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_passedNode;
        break;
      }
      
      // repeated string passedNode = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_passedNode:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_passednode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->passednode(0).data(), this->passednode(0).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_passedNode;
        if (input->ExpectTag(58)) goto parse_traceroute;
        break;
      }
      
      // optional .org.umit.icm.mobile.proto.TraceRoute traceroute = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_traceroute:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traceroute()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ICMReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string reportID = 1;
  if (has_reportid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->reportid().data(), this->reportid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->reportid(), output);
  }
  
  // required int64 agentID = 2;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->agentid(), output);
  }
  
  // required int32 testID = 3;
  if (has_testid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->testid(), output);
  }
  
  // required int32 timeZone = 4;
  if (has_timezone()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->timezone(), output);
  }
  
  // required int64 timeUTC = 5;
  if (has_timeutc()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->timeutc(), output);
  }
  
  // repeated string passedNode = 6;
  for (int i = 0; i < this->passednode_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->passednode(i).data(), this->passednode(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->passednode(i), output);
  }
  
  // optional .org.umit.icm.mobile.proto.TraceRoute traceroute = 7;
  if (has_traceroute()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->traceroute(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ICMReport::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string reportID = 1;
  if (has_reportid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->reportid().data(), this->reportid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->reportid(), target);
  }
  
  // required int64 agentID = 2;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->agentid(), target);
  }
  
  // required int32 testID = 3;
  if (has_testid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->testid(), target);
  }
  
  // required int32 timeZone = 4;
  if (has_timezone()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->timezone(), target);
  }
  
  // required int64 timeUTC = 5;
  if (has_timeutc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->timeutc(), target);
  }
  
  // repeated string passedNode = 6;
  for (int i = 0; i < this->passednode_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passednode(i).data(), this->passednode(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->passednode(i), target);
  }
  
  // optional .org.umit.icm.mobile.proto.TraceRoute traceroute = 7;
  if (has_traceroute()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->traceroute(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ICMReport::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string reportID = 1;
    if (has_reportid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->reportid());
    }
    
    // required int64 agentID = 2;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
    // required int32 testID = 3;
    if (has_testid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->testid());
    }
    
    // required int32 timeZone = 4;
    if (has_timezone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timezone());
    }
    
    // required int64 timeUTC = 5;
    if (has_timeutc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timeutc());
    }
    
    // optional .org.umit.icm.mobile.proto.TraceRoute traceroute = 7;
    if (has_traceroute()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->traceroute());
    }
    
  }
  // repeated string passedNode = 6;
  total_size += 1 * this->passednode_size();
  for (int i = 0; i < this->passednode_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->passednode(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ICMReport::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ICMReport* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ICMReport*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ICMReport::MergeFrom(const ICMReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  passednode_.MergeFrom(from.passednode_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reportid()) {
      set_reportid(from.reportid());
    }
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
    if (from.has_testid()) {
      set_testid(from.testid());
    }
    if (from.has_timezone()) {
      set_timezone(from.timezone());
    }
    if (from.has_timeutc()) {
      set_timeutc(from.timeutc());
    }
    if (from.has_traceroute()) {
      mutable_traceroute()->::org::umit::icm::mobile::proto::TraceRoute::MergeFrom(from.traceroute());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ICMReport::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ICMReport::CopyFrom(const ICMReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ICMReport::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  if (has_traceroute()) {
    if (!this->traceroute().IsInitialized()) return false;
  }
  return true;
}

void ICMReport::Swap(ICMReport* other) {
  if (other != this) {
    std::swap(reportid_, other->reportid_);
    std::swap(agentid_, other->agentid_);
    std::swap(testid_, other->testid_);
    std::swap(timezone_, other->timezone_);
    std::swap(timeutc_, other->timeutc_);
    passednode_.Swap(&other->passednode_);
    std::swap(traceroute_, other->traceroute_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ICMReport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ICMReport_descriptor_;
  metadata.reflection = ICMReport_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WebsiteReportDetail::kWebsiteURLFieldNumber;
const int WebsiteReportDetail::kStatusCodeFieldNumber;
const int WebsiteReportDetail::kResponseTimeFieldNumber;
const int WebsiteReportDetail::kBandwidthFieldNumber;
const int WebsiteReportDetail::kRedirectLinkFieldNumber;
const int WebsiteReportDetail::kHtmlResponseFieldNumber;
const int WebsiteReportDetail::kHtmlMediaFieldNumber;
#endif  // !_MSC_VER

WebsiteReportDetail::WebsiteReportDetail()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WebsiteReportDetail::InitAsDefaultInstance() {
}

WebsiteReportDetail::WebsiteReportDetail(const WebsiteReportDetail& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WebsiteReportDetail::SharedCtor() {
  _cached_size_ = 0;
  websiteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  statuscode_ = 0;
  responsetime_ = 0;
  bandwidth_ = 0;
  redirectlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  htmlresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  htmlmedia_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WebsiteReportDetail::~WebsiteReportDetail() {
  SharedDtor();
}

void WebsiteReportDetail::SharedDtor() {
  if (websiteurl_ != &::google::protobuf::internal::kEmptyString) {
    delete websiteurl_;
  }
  if (redirectlink_ != &::google::protobuf::internal::kEmptyString) {
    delete redirectlink_;
  }
  if (htmlresponse_ != &::google::protobuf::internal::kEmptyString) {
    delete htmlresponse_;
  }
  if (htmlmedia_ != &::google::protobuf::internal::kEmptyString) {
    delete htmlmedia_;
  }
  if (this != default_instance_) {
  }
}

void WebsiteReportDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WebsiteReportDetail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WebsiteReportDetail_descriptor_;
}

const WebsiteReportDetail& WebsiteReportDetail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

WebsiteReportDetail* WebsiteReportDetail::default_instance_ = NULL;

WebsiteReportDetail* WebsiteReportDetail::New() const {
  return new WebsiteReportDetail;
}

void WebsiteReportDetail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_websiteurl()) {
      if (websiteurl_ != &::google::protobuf::internal::kEmptyString) {
        websiteurl_->clear();
      }
    }
    statuscode_ = 0;
    responsetime_ = 0;
    bandwidth_ = 0;
    if (has_redirectlink()) {
      if (redirectlink_ != &::google::protobuf::internal::kEmptyString) {
        redirectlink_->clear();
      }
    }
    if (has_htmlresponse()) {
      if (htmlresponse_ != &::google::protobuf::internal::kEmptyString) {
        htmlresponse_->clear();
      }
    }
    if (has_htmlmedia()) {
      if (htmlmedia_ != &::google::protobuf::internal::kEmptyString) {
        htmlmedia_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WebsiteReportDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string websiteURL = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_websiteurl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->websiteurl().data(), this->websiteurl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_statusCode;
        break;
      }
      
      // required int32 statusCode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_statusCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &statuscode_)));
          set_has_statuscode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_responseTime;
        break;
      }
      
      // optional int32 responseTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_responseTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &responsetime_)));
          set_has_responsetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_bandwidth;
        break;
      }
      
      // optional int32 bandwidth = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bandwidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &bandwidth_)));
          set_has_bandwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_redirectLink;
        break;
      }
      
      // optional string redirectLink = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_redirectLink:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_redirectlink()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->redirectlink().data(), this->redirectlink().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_htmlResponse;
        break;
      }
      
      // optional string htmlResponse = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_htmlResponse:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_htmlresponse()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->htmlresponse().data(), this->htmlresponse().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_htmlMedia;
        break;
      }
      
      // optional bytes htmlMedia = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_htmlMedia:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_htmlmedia()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WebsiteReportDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string websiteURL = 1;
  if (has_websiteurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->websiteurl().data(), this->websiteurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->websiteurl(), output);
  }
  
  // required int32 statusCode = 2;
  if (has_statuscode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->statuscode(), output);
  }
  
  // optional int32 responseTime = 3;
  if (has_responsetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->responsetime(), output);
  }
  
  // optional int32 bandwidth = 4;
  if (has_bandwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->bandwidth(), output);
  }
  
  // optional string redirectLink = 5;
  if (has_redirectlink()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->redirectlink().data(), this->redirectlink().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->redirectlink(), output);
  }
  
  // optional string htmlResponse = 6;
  if (has_htmlresponse()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->htmlresponse().data(), this->htmlresponse().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->htmlresponse(), output);
  }
  
  // optional bytes htmlMedia = 7;
  if (has_htmlmedia()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      7, this->htmlmedia(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WebsiteReportDetail::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string websiteURL = 1;
  if (has_websiteurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->websiteurl().data(), this->websiteurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->websiteurl(), target);
  }
  
  // required int32 statusCode = 2;
  if (has_statuscode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->statuscode(), target);
  }
  
  // optional int32 responseTime = 3;
  if (has_responsetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->responsetime(), target);
  }
  
  // optional int32 bandwidth = 4;
  if (has_bandwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->bandwidth(), target);
  }
  
  // optional string redirectLink = 5;
  if (has_redirectlink()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->redirectlink().data(), this->redirectlink().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->redirectlink(), target);
  }
  
  // optional string htmlResponse = 6;
  if (has_htmlresponse()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->htmlresponse().data(), this->htmlresponse().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->htmlresponse(), target);
  }
  
  // optional bytes htmlMedia = 7;
  if (has_htmlmedia()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->htmlmedia(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WebsiteReportDetail::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string websiteURL = 1;
    if (has_websiteurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->websiteurl());
    }
    
    // required int32 statusCode = 2;
    if (has_statuscode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->statuscode());
    }
    
    // optional int32 responseTime = 3;
    if (has_responsetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->responsetime());
    }
    
    // optional int32 bandwidth = 4;
    if (has_bandwidth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bandwidth());
    }
    
    // optional string redirectLink = 5;
    if (has_redirectlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->redirectlink());
    }
    
    // optional string htmlResponse = 6;
    if (has_htmlresponse()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->htmlresponse());
    }
    
    // optional bytes htmlMedia = 7;
    if (has_htmlmedia()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->htmlmedia());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WebsiteReportDetail::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WebsiteReportDetail* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WebsiteReportDetail*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WebsiteReportDetail::MergeFrom(const WebsiteReportDetail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_websiteurl()) {
      set_websiteurl(from.websiteurl());
    }
    if (from.has_statuscode()) {
      set_statuscode(from.statuscode());
    }
    if (from.has_responsetime()) {
      set_responsetime(from.responsetime());
    }
    if (from.has_bandwidth()) {
      set_bandwidth(from.bandwidth());
    }
    if (from.has_redirectlink()) {
      set_redirectlink(from.redirectlink());
    }
    if (from.has_htmlresponse()) {
      set_htmlresponse(from.htmlresponse());
    }
    if (from.has_htmlmedia()) {
      set_htmlmedia(from.htmlmedia());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WebsiteReportDetail::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WebsiteReportDetail::CopyFrom(const WebsiteReportDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WebsiteReportDetail::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void WebsiteReportDetail::Swap(WebsiteReportDetail* other) {
  if (other != this) {
    std::swap(websiteurl_, other->websiteurl_);
    std::swap(statuscode_, other->statuscode_);
    std::swap(responsetime_, other->responsetime_);
    std::swap(bandwidth_, other->bandwidth_);
    std::swap(redirectlink_, other->redirectlink_);
    std::swap(htmlresponse_, other->htmlresponse_);
    std::swap(htmlmedia_, other->htmlmedia_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WebsiteReportDetail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WebsiteReportDetail_descriptor_;
  metadata.reflection = WebsiteReportDetail_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WebsiteReport::kHeaderFieldNumber;
const int WebsiteReport::kReportFieldNumber;
#endif  // !_MSC_VER

WebsiteReport::WebsiteReport()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WebsiteReport::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ICMReport*>(&::org::umit::icm::mobile::proto::ICMReport::default_instance());
  report_ = const_cast< ::org::umit::icm::mobile::proto::WebsiteReportDetail*>(&::org::umit::icm::mobile::proto::WebsiteReportDetail::default_instance());
}

WebsiteReport::WebsiteReport(const WebsiteReport& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WebsiteReport::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  report_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WebsiteReport::~WebsiteReport() {
  SharedDtor();
}

void WebsiteReport::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete report_;
  }
}

void WebsiteReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WebsiteReport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WebsiteReport_descriptor_;
}

const WebsiteReport& WebsiteReport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

WebsiteReport* WebsiteReport::default_instance_ = NULL;

WebsiteReport* WebsiteReport::New() const {
  return new WebsiteReport;
}

void WebsiteReport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ICMReport::Clear();
    }
    if (has_report()) {
      if (report_ != NULL) report_->::org::umit::icm::mobile::proto::WebsiteReportDetail::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WebsiteReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ICMReport header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_report;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.WebsiteReportDetail report = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_report:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_report()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WebsiteReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ICMReport header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // required .org.umit.icm.mobile.proto.WebsiteReportDetail report = 2;
  if (has_report()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->report(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WebsiteReport::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ICMReport header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // required .org.umit.icm.mobile.proto.WebsiteReportDetail report = 2;
  if (has_report()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->report(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WebsiteReport::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ICMReport header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required .org.umit.icm.mobile.proto.WebsiteReportDetail report = 2;
    if (has_report()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->report());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WebsiteReport::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WebsiteReport* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WebsiteReport*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WebsiteReport::MergeFrom(const WebsiteReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ICMReport::MergeFrom(from.header());
    }
    if (from.has_report()) {
      mutable_report()->::org::umit::icm::mobile::proto::WebsiteReportDetail::MergeFrom(from.report());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WebsiteReport::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WebsiteReport::CopyFrom(const WebsiteReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WebsiteReport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  if (has_report()) {
    if (!this->report().IsInitialized()) return false;
  }
  return true;
}

void WebsiteReport::Swap(WebsiteReport* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(report_, other->report_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WebsiteReport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WebsiteReport_descriptor_;
  metadata.reflection = WebsiteReport_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceReportDetail::kServiceNameFieldNumber;
const int ServiceReportDetail::kStatusCodeFieldNumber;
const int ServiceReportDetail::kPortFieldNumber;
const int ServiceReportDetail::kResponseTimeFieldNumber;
const int ServiceReportDetail::kBandwidthFieldNumber;
#endif  // !_MSC_VER

ServiceReportDetail::ServiceReportDetail()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ServiceReportDetail::InitAsDefaultInstance() {
}

ServiceReportDetail::ServiceReportDetail(const ServiceReportDetail& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ServiceReportDetail::SharedCtor() {
  _cached_size_ = 0;
  servicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  statuscode_ = 0;
  port_ = 0;
  responsetime_ = 0;
  bandwidth_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceReportDetail::~ServiceReportDetail() {
  SharedDtor();
}

void ServiceReportDetail::SharedDtor() {
  if (servicename_ != &::google::protobuf::internal::kEmptyString) {
    delete servicename_;
  }
  if (this != default_instance_) {
  }
}

void ServiceReportDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServiceReportDetail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceReportDetail_descriptor_;
}

const ServiceReportDetail& ServiceReportDetail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ServiceReportDetail* ServiceReportDetail::default_instance_ = NULL;

ServiceReportDetail* ServiceReportDetail::New() const {
  return new ServiceReportDetail;
}

void ServiceReportDetail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_servicename()) {
      if (servicename_ != &::google::protobuf::internal::kEmptyString) {
        servicename_->clear();
      }
    }
    statuscode_ = 0;
    port_ = 0;
    responsetime_ = 0;
    bandwidth_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServiceReportDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string serviceName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_servicename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->servicename().data(), this->servicename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_statusCode;
        break;
      }
      
      // required int32 statusCode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_statusCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &statuscode_)));
          set_has_statuscode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }
      
      // required int32 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(33)) goto parse_responseTime;
        break;
      }
      
      // optional double responseTime = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_responseTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &responsetime_)));
          set_has_responsetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(41)) goto parse_bandwidth;
        break;
      }
      
      // optional double bandwidth = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_bandwidth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &bandwidth_)));
          set_has_bandwidth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServiceReportDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string serviceName = 1;
  if (has_servicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servicename().data(), this->servicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->servicename(), output);
  }
  
  // required int32 statusCode = 2;
  if (has_statuscode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->statuscode(), output);
  }
  
  // required int32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }
  
  // optional double responseTime = 4;
  if (has_responsetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->responsetime(), output);
  }
  
  // optional double bandwidth = 5;
  if (has_bandwidth()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->bandwidth(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ServiceReportDetail::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string serviceName = 1;
  if (has_servicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servicename().data(), this->servicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->servicename(), target);
  }
  
  // required int32 statusCode = 2;
  if (has_statuscode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->statuscode(), target);
  }
  
  // required int32 port = 3;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->port(), target);
  }
  
  // optional double responseTime = 4;
  if (has_responsetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->responsetime(), target);
  }
  
  // optional double bandwidth = 5;
  if (has_bandwidth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->bandwidth(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ServiceReportDetail::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string serviceName = 1;
    if (has_servicename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->servicename());
    }
    
    // required int32 statusCode = 2;
    if (has_statuscode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->statuscode());
    }
    
    // required int32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }
    
    // optional double responseTime = 4;
    if (has_responsetime()) {
      total_size += 1 + 8;
    }
    
    // optional double bandwidth = 5;
    if (has_bandwidth()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceReportDetail::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServiceReportDetail* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServiceReportDetail*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServiceReportDetail::MergeFrom(const ServiceReportDetail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_servicename()) {
      set_servicename(from.servicename());
    }
    if (from.has_statuscode()) {
      set_statuscode(from.statuscode());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_responsetime()) {
      set_responsetime(from.responsetime());
    }
    if (from.has_bandwidth()) {
      set_bandwidth(from.bandwidth());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServiceReportDetail::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServiceReportDetail::CopyFrom(const ServiceReportDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceReportDetail::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void ServiceReportDetail::Swap(ServiceReportDetail* other) {
  if (other != this) {
    std::swap(servicename_, other->servicename_);
    std::swap(statuscode_, other->statuscode_);
    std::swap(port_, other->port_);
    std::swap(responsetime_, other->responsetime_);
    std::swap(bandwidth_, other->bandwidth_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServiceReportDetail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServiceReportDetail_descriptor_;
  metadata.reflection = ServiceReportDetail_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceReport::kHeaderFieldNumber;
const int ServiceReport::kReportFieldNumber;
#endif  // !_MSC_VER

ServiceReport::ServiceReport()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ServiceReport::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ICMReport*>(&::org::umit::icm::mobile::proto::ICMReport::default_instance());
  report_ = const_cast< ::org::umit::icm::mobile::proto::ServiceReportDetail*>(&::org::umit::icm::mobile::proto::ServiceReportDetail::default_instance());
}

ServiceReport::ServiceReport(const ServiceReport& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ServiceReport::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  report_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceReport::~ServiceReport() {
  SharedDtor();
}

void ServiceReport::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
    delete report_;
  }
}

void ServiceReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServiceReport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceReport_descriptor_;
}

const ServiceReport& ServiceReport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ServiceReport* ServiceReport::default_instance_ = NULL;

ServiceReport* ServiceReport::New() const {
  return new ServiceReport;
}

void ServiceReport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ICMReport::Clear();
    }
    if (has_report()) {
      if (report_ != NULL) report_->::org::umit::icm::mobile::proto::ServiceReportDetail::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServiceReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ICMReport header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_report;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.ServiceReportDetail report = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_report:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_report()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServiceReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ICMReport header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // required .org.umit.icm.mobile.proto.ServiceReportDetail report = 2;
  if (has_report()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->report(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ServiceReport::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ICMReport header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // required .org.umit.icm.mobile.proto.ServiceReportDetail report = 2;
  if (has_report()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->report(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ServiceReport::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ICMReport header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required .org.umit.icm.mobile.proto.ServiceReportDetail report = 2;
    if (has_report()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->report());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceReport::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServiceReport* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServiceReport*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServiceReport::MergeFrom(const ServiceReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ICMReport::MergeFrom(from.header());
    }
    if (from.has_report()) {
      mutable_report()->::org::umit::icm::mobile::proto::ServiceReportDetail::MergeFrom(from.report());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServiceReport::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServiceReport::CopyFrom(const ServiceReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceReport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  if (has_report()) {
    if (!this->report().IsInitialized()) return false;
  }
  return true;
}

void ServiceReport::Swap(ServiceReport* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(report_, other->report_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServiceReport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServiceReport_descriptor_;
  metadata.reflection = ServiceReport_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RequestHeader::kAgentIDFieldNumber;
#endif  // !_MSC_VER

RequestHeader::RequestHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RequestHeader::InitAsDefaultInstance() {
}

RequestHeader::RequestHeader(const RequestHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RequestHeader::SharedCtor() {
  _cached_size_ = 0;
  agentid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestHeader::~RequestHeader() {
  SharedDtor();
}

void RequestHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RequestHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RequestHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestHeader_descriptor_;
}

const RequestHeader& RequestHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

RequestHeader* RequestHeader::default_instance_ = NULL;

RequestHeader* RequestHeader::New() const {
  return new RequestHeader;
}

void RequestHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agentid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RequestHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 agentID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->agentid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RequestHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->agentid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RequestHeader::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 agentID = 1;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RequestHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RequestHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RequestHeader::MergeFrom(const RequestHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RequestHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RequestHeader::CopyFrom(const RequestHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void RequestHeader::Swap(RequestHeader* other) {
  if (other != this) {
    std::swap(agentid_, other->agentid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RequestHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RequestHeader_descriptor_;
  metadata.reflection = RequestHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseHeader::kCurrentVersionNoFieldNumber;
const int ResponseHeader::kCurrentTestVersionNoFieldNumber;
#endif  // !_MSC_VER

ResponseHeader::ResponseHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResponseHeader::InitAsDefaultInstance() {
}

ResponseHeader::ResponseHeader(const ResponseHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseHeader::SharedCtor() {
  _cached_size_ = 0;
  currentversionno_ = 0;
  currenttestversionno_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseHeader::~ResponseHeader() {
  SharedDtor();
}

void ResponseHeader::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResponseHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResponseHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResponseHeader_descriptor_;
}

const ResponseHeader& ResponseHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ResponseHeader* ResponseHeader::default_instance_ = NULL;

ResponseHeader* ResponseHeader::New() const {
  return new ResponseHeader;
}

void ResponseHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    currentversionno_ = 0;
    currenttestversionno_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResponseHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 currentVersionNo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currentversionno_)));
          set_has_currentversionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_currentTestVersionNo;
        break;
      }
      
      // required int32 currentTestVersionNo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_currentTestVersionNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currenttestversionno_)));
          set_has_currenttestversionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 currentVersionNo = 1;
  if (has_currentversionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->currentversionno(), output);
  }
  
  // required int32 currentTestVersionNo = 2;
  if (has_currenttestversionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->currenttestversionno(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResponseHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 currentVersionNo = 1;
  if (has_currentversionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->currentversionno(), target);
  }
  
  // required int32 currentTestVersionNo = 2;
  if (has_currenttestversionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->currenttestversionno(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResponseHeader::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 currentVersionNo = 1;
    if (has_currentversionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currentversionno());
    }
    
    // required int32 currentTestVersionNo = 2;
    if (has_currenttestversionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currenttestversionno());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResponseHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResponseHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResponseHeader::MergeFrom(const ResponseHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_currentversionno()) {
      set_currentversionno(from.currentversionno());
    }
    if (from.has_currenttestversionno()) {
      set_currenttestversionno(from.currenttestversionno());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResponseHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResponseHeader::CopyFrom(const ResponseHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseHeader::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void ResponseHeader::Swap(ResponseHeader* other) {
  if (other != this) {
    std::swap(currentversionno_, other->currentversionno_);
    std::swap(currenttestversionno_, other->currenttestversionno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResponseHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResponseHeader_descriptor_;
  metadata.reflection = ResponseHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterAgent::kVersionNoFieldNumber;
const int RegisterAgent::kAgentTypeFieldNumber;
const int RegisterAgent::kCredentialsFieldNumber;
const int RegisterAgent::kAgentPublicKeyFieldNumber;
const int RegisterAgent::kIpFieldNumber;
#endif  // !_MSC_VER

RegisterAgent::RegisterAgent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterAgent::InitAsDefaultInstance() {
  credentials_ = const_cast< ::org::umit::icm::mobile::proto::LoginCredentials*>(&::org::umit::icm::mobile::proto::LoginCredentials::default_instance());
  agentpublickey_ = const_cast< ::org::umit::icm::mobile::proto::RSAKey*>(&::org::umit::icm::mobile::proto::RSAKey::default_instance());
}

RegisterAgent::RegisterAgent(const RegisterAgent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterAgent::SharedCtor() {
  _cached_size_ = 0;
  versionno_ = 0;
  agenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  credentials_ = NULL;
  agentpublickey_ = NULL;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterAgent::~RegisterAgent() {
  SharedDtor();
}

void RegisterAgent::SharedDtor() {
  if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
    delete agenttype_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
    delete credentials_;
    delete agentpublickey_;
  }
}

void RegisterAgent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterAgent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterAgent_descriptor_;
}

const RegisterAgent& RegisterAgent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

RegisterAgent* RegisterAgent::default_instance_ = NULL;

RegisterAgent* RegisterAgent::New() const {
  return new RegisterAgent;
}

void RegisterAgent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    versionno_ = 0;
    if (has_agenttype()) {
      if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
        agenttype_->clear();
      }
    }
    if (has_credentials()) {
      if (credentials_ != NULL) credentials_->::org::umit::icm::mobile::proto::LoginCredentials::Clear();
    }
    if (has_agentpublickey()) {
      if (agentpublickey_ != NULL) agentpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterAgent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 versionNo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &versionno_)));
          set_has_versionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agentType;
        break;
      }
      
      // required string agentType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agentType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_agenttype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->agenttype().data(), this->agenttype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_credentials;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.LoginCredentials credentials = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_credentials:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_credentials()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_agentPublicKey;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.RSAKey agentPublicKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agentPublicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agentpublickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ip;
        break;
      }
      
      // optional string ip = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterAgent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 versionNo = 1;
  if (has_versionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->versionno(), output);
  }
  
  // required string agentType = 2;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agenttype().data(), this->agenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->agenttype(), output);
  }
  
  // required .org.umit.icm.mobile.proto.LoginCredentials credentials = 3;
  if (has_credentials()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->credentials(), output);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey agentPublicKey = 4;
  if (has_agentpublickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->agentpublickey(), output);
  }
  
  // optional string ip = 5;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->ip(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterAgent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 versionNo = 1;
  if (has_versionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->versionno(), target);
  }
  
  // required string agentType = 2;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agenttype().data(), this->agenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->agenttype(), target);
  }
  
  // required .org.umit.icm.mobile.proto.LoginCredentials credentials = 3;
  if (has_credentials()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->credentials(), target);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey agentPublicKey = 4;
  if (has_agentpublickey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->agentpublickey(), target);
  }
  
  // optional string ip = 5;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->ip(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterAgent::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 versionNo = 1;
    if (has_versionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->versionno());
    }
    
    // required string agentType = 2;
    if (has_agenttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->agenttype());
    }
    
    // required .org.umit.icm.mobile.proto.LoginCredentials credentials = 3;
    if (has_credentials()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->credentials());
    }
    
    // required .org.umit.icm.mobile.proto.RSAKey agentPublicKey = 4;
    if (has_agentpublickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agentpublickey());
    }
    
    // optional string ip = 5;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterAgent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterAgent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterAgent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterAgent::MergeFrom(const RegisterAgent& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_versionno()) {
      set_versionno(from.versionno());
    }
    if (from.has_agenttype()) {
      set_agenttype(from.agenttype());
    }
    if (from.has_credentials()) {
      mutable_credentials()->::org::umit::icm::mobile::proto::LoginCredentials::MergeFrom(from.credentials());
    }
    if (from.has_agentpublickey()) {
      mutable_agentpublickey()->::org::umit::icm::mobile::proto::RSAKey::MergeFrom(from.agentpublickey());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterAgent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterAgent::CopyFrom(const RegisterAgent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterAgent::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_credentials()) {
    if (!this->credentials().IsInitialized()) return false;
  }
  if (has_agentpublickey()) {
    if (!this->agentpublickey().IsInitialized()) return false;
  }
  return true;
}

void RegisterAgent::Swap(RegisterAgent* other) {
  if (other != this) {
    std::swap(versionno_, other->versionno_);
    std::swap(agenttype_, other->agenttype_);
    std::swap(credentials_, other->credentials_);
    std::swap(agentpublickey_, other->agentpublickey_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterAgent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterAgent_descriptor_;
  metadata.reflection = RegisterAgent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterAgentResponse::kHeaderFieldNumber;
const int RegisterAgentResponse::kAgentIDFieldNumber;
const int RegisterAgentResponse::kPublicKeyHashFieldNumber;
#endif  // !_MSC_VER

RegisterAgentResponse::RegisterAgentResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterAgentResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

RegisterAgentResponse::RegisterAgentResponse(const RegisterAgentResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterAgentResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  agentid_ = GOOGLE_LONGLONG(0);
  publickeyhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterAgentResponse::~RegisterAgentResponse() {
  SharedDtor();
}

void RegisterAgentResponse::SharedDtor() {
  if (publickeyhash_ != &::google::protobuf::internal::kEmptyString) {
    delete publickeyhash_;
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void RegisterAgentResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterAgentResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterAgentResponse_descriptor_;
}

const RegisterAgentResponse& RegisterAgentResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

RegisterAgentResponse* RegisterAgentResponse::default_instance_ = NULL;

RegisterAgentResponse* RegisterAgentResponse::New() const {
  return new RegisterAgentResponse;
}

void RegisterAgentResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
    agentid_ = GOOGLE_LONGLONG(0);
    if (has_publickeyhash()) {
      if (publickeyhash_ != &::google::protobuf::internal::kEmptyString) {
        publickeyhash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterAgentResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_agentID;
        break;
      }
      
      // required int64 agentID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_agentID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_publicKeyHash;
        break;
      }
      
      // required string publicKeyHash = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_publicKeyHash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_publickeyhash()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->publickeyhash().data(), this->publickeyhash().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterAgentResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // required int64 agentID = 2;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->agentid(), output);
  }
  
  // required string publicKeyHash = 3;
  if (has_publickeyhash()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->publickeyhash().data(), this->publickeyhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->publickeyhash(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterAgentResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // required int64 agentID = 2;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->agentid(), target);
  }
  
  // required string publicKeyHash = 3;
  if (has_publickeyhash()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->publickeyhash().data(), this->publickeyhash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->publickeyhash(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterAgentResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required int64 agentID = 2;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
    // required string publicKeyHash = 3;
    if (has_publickeyhash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->publickeyhash());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterAgentResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterAgentResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterAgentResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterAgentResponse::MergeFrom(const RegisterAgentResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
    if (from.has_publickeyhash()) {
      set_publickeyhash(from.publickeyhash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterAgentResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterAgentResponse::CopyFrom(const RegisterAgentResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterAgentResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void RegisterAgentResponse::Swap(RegisterAgentResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(agentid_, other->agentid_);
    std::swap(publickeyhash_, other->publickeyhash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterAgentResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterAgentResponse_descriptor_;
  metadata.reflection = RegisterAgentResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RSAKey::kModFieldNumber;
const int RSAKey::kExpFieldNumber;
#endif  // !_MSC_VER

RSAKey::RSAKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RSAKey::InitAsDefaultInstance() {
}

RSAKey::RSAKey(const RSAKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RSAKey::SharedCtor() {
  _cached_size_ = 0;
  mod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  exp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RSAKey::~RSAKey() {
  SharedDtor();
}

void RSAKey::SharedDtor() {
  if (mod_ != &::google::protobuf::internal::kEmptyString) {
    delete mod_;
  }
  if (exp_ != &::google::protobuf::internal::kEmptyString) {
    delete exp_;
  }
  if (this != default_instance_) {
  }
}

void RSAKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RSAKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RSAKey_descriptor_;
}

const RSAKey& RSAKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

RSAKey* RSAKey::default_instance_ = NULL;

RSAKey* RSAKey::New() const {
  return new RSAKey;
}

void RSAKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mod()) {
      if (mod_ != &::google::protobuf::internal::kEmptyString) {
        mod_->clear();
      }
    }
    if (has_exp()) {
      if (exp_ != &::google::protobuf::internal::kEmptyString) {
        exp_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RSAKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string mod = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mod()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mod().data(), this->mod().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_exp;
        break;
      }
      
      // required string exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_exp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_exp()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->exp().data(), this->exp().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RSAKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string mod = 1;
  if (has_mod()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mod().data(), this->mod().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mod(), output);
  }
  
  // required string exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->exp().data(), this->exp().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->exp(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RSAKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string mod = 1;
  if (has_mod()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mod().data(), this->mod().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mod(), target);
  }
  
  // required string exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->exp().data(), this->exp().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->exp(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RSAKey::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string mod = 1;
    if (has_mod()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mod());
    }
    
    // required string exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->exp());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RSAKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RSAKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RSAKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RSAKey::MergeFrom(const RSAKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mod()) {
      set_mod(from.mod());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RSAKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RSAKey::CopyFrom(const RSAKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RSAKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void RSAKey::Swap(RSAKey* other) {
  if (other != this) {
    std::swap(mod_, other->mod_);
    std::swap(exp_, other->exp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RSAKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RSAKey_descriptor_;
  metadata.reflection = RSAKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckAggregator::kAgentTypeFieldNumber;
#endif  // !_MSC_VER

CheckAggregator::CheckAggregator()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckAggregator::InitAsDefaultInstance() {
}

CheckAggregator::CheckAggregator(const CheckAggregator& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckAggregator::SharedCtor() {
  _cached_size_ = 0;
  agenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckAggregator::~CheckAggregator() {
  SharedDtor();
}

void CheckAggregator::SharedDtor() {
  if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
    delete agenttype_;
  }
  if (this != default_instance_) {
  }
}

void CheckAggregator::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckAggregator::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckAggregator_descriptor_;
}

const CheckAggregator& CheckAggregator::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

CheckAggregator* CheckAggregator::default_instance_ = NULL;

CheckAggregator* CheckAggregator::New() const {
  return new CheckAggregator;
}

void CheckAggregator::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_agenttype()) {
      if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
        agenttype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckAggregator::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string agentType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_agenttype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->agenttype().data(), this->agenttype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckAggregator::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string agentType = 1;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agenttype().data(), this->agenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->agenttype(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckAggregator::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string agentType = 1;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agenttype().data(), this->agenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->agenttype(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckAggregator::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string agentType = 1;
    if (has_agenttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->agenttype());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckAggregator::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckAggregator* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckAggregator*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckAggregator::MergeFrom(const CheckAggregator& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agenttype()) {
      set_agenttype(from.agenttype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckAggregator::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckAggregator::CopyFrom(const CheckAggregator& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckAggregator::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void CheckAggregator::Swap(CheckAggregator* other) {
  if (other != this) {
    std::swap(agenttype_, other->agenttype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckAggregator::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckAggregator_descriptor_;
  metadata.reflection = CheckAggregator_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CheckAggregatorResponse::kHeaderFieldNumber;
const int CheckAggregatorResponse::kStatusFieldNumber;
#endif  // !_MSC_VER

CheckAggregatorResponse::CheckAggregatorResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CheckAggregatorResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

CheckAggregatorResponse::CheckAggregatorResponse(const CheckAggregatorResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CheckAggregatorResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckAggregatorResponse::~CheckAggregatorResponse() {
  SharedDtor();
}

void CheckAggregatorResponse::SharedDtor() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void CheckAggregatorResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckAggregatorResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckAggregatorResponse_descriptor_;
}

const CheckAggregatorResponse& CheckAggregatorResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

CheckAggregatorResponse* CheckAggregatorResponse::default_instance_ = NULL;

CheckAggregatorResponse* CheckAggregatorResponse::New() const {
  return new CheckAggregatorResponse;
}

void CheckAggregatorResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CheckAggregatorResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_status;
        break;
      }
      
      // required string status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CheckAggregatorResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // required string status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->status(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CheckAggregatorResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // required string status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->status(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CheckAggregatorResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required string status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckAggregatorResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CheckAggregatorResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CheckAggregatorResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CheckAggregatorResponse::MergeFrom(const CheckAggregatorResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CheckAggregatorResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckAggregatorResponse::CopyFrom(const CheckAggregatorResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckAggregatorResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void CheckAggregatorResponse::Swap(CheckAggregatorResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CheckAggregatorResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckAggregatorResponse_descriptor_;
  metadata.reflection = CheckAggregatorResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Login::kAgentIDFieldNumber;
const int Login::kChallengeFieldNumber;
const int Login::kPortFieldNumber;
const int Login::kIpFieldNumber;
#endif  // !_MSC_VER

Login::Login()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Login::InitAsDefaultInstance() {
}

Login::Login(const Login& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Login::SharedCtor() {
  _cached_size_ = 0;
  agentid_ = GOOGLE_LONGLONG(0);
  challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = GOOGLE_LONGLONG(0);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Login::~Login() {
  SharedDtor();
}

void Login::SharedDtor() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void Login::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Login::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Login_descriptor_;
}

const Login& Login::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Login* Login::default_instance_ = NULL;

Login* Login::New() const {
  return new Login;
}

void Login::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agentid_ = GOOGLE_LONGLONG(0);
    if (has_challenge()) {
      if (challenge_ != &::google::protobuf::internal::kEmptyString) {
        challenge_->clear();
      }
    }
    port_ = GOOGLE_LONGLONG(0);
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Login::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 agentID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_challenge;
        break;
      }
      
      // required string challenge = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_challenge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_challenge()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->challenge().data(), this->challenge().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }
      
      // required int64 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ip;
        break;
      }
      
      // optional string ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Login::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->agentid(), output);
  }
  
  // required string challenge = 2;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->challenge().data(), this->challenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->challenge(), output);
  }
  
  // required int64 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->port(), output);
  }
  
  // optional string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->ip(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Login::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->agentid(), target);
  }
  
  // required string challenge = 2;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->challenge().data(), this->challenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->challenge(), target);
  }
  
  // required int64 port = 3;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->port(), target);
  }
  
  // optional string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->ip(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Login::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 agentID = 1;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
    // required string challenge = 2;
    if (has_challenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->challenge());
    }
    
    // required int64 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->port());
    }
    
    // optional string ip = 4;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Login::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Login* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Login*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Login::MergeFrom(const Login& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
    if (from.has_challenge()) {
      set_challenge(from.challenge());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Login::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Login::CopyFrom(const Login& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Login::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Login::Swap(Login* other) {
  if (other != this) {
    std::swap(agentid_, other->agentid_);
    std::swap(challenge_, other->challenge_);
    std::swap(port_, other->port_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Login::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Login_descriptor_;
  metadata.reflection = Login_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginStep1::kProcessIDFieldNumber;
const int LoginStep1::kCipheredChallengeFieldNumber;
const int LoginStep1::kChallengeFieldNumber;
#endif  // !_MSC_VER

LoginStep1::LoginStep1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginStep1::InitAsDefaultInstance() {
}

LoginStep1::LoginStep1(const LoginStep1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginStep1::SharedCtor() {
  _cached_size_ = 0;
  processid_ = GOOGLE_LONGLONG(0);
  cipheredchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginStep1::~LoginStep1() {
  SharedDtor();
}

void LoginStep1::SharedDtor() {
  if (cipheredchallenge_ != &::google::protobuf::internal::kEmptyString) {
    delete cipheredchallenge_;
  }
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    delete challenge_;
  }
  if (this != default_instance_) {
  }
}

void LoginStep1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginStep1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginStep1_descriptor_;
}

const LoginStep1& LoginStep1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

LoginStep1* LoginStep1::default_instance_ = NULL;

LoginStep1* LoginStep1::New() const {
  return new LoginStep1;
}

void LoginStep1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    processid_ = GOOGLE_LONGLONG(0);
    if (has_cipheredchallenge()) {
      if (cipheredchallenge_ != &::google::protobuf::internal::kEmptyString) {
        cipheredchallenge_->clear();
      }
    }
    if (has_challenge()) {
      if (challenge_ != &::google::protobuf::internal::kEmptyString) {
        challenge_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginStep1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 processID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &processid_)));
          set_has_processid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cipheredChallenge;
        break;
      }
      
      // required string cipheredChallenge = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cipheredChallenge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cipheredchallenge()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cipheredchallenge().data(), this->cipheredchallenge().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_challenge;
        break;
      }
      
      // required string challenge = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_challenge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_challenge()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->challenge().data(), this->challenge().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginStep1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 processID = 1;
  if (has_processid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->processid(), output);
  }
  
  // required string cipheredChallenge = 2;
  if (has_cipheredchallenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipheredchallenge().data(), this->cipheredchallenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->cipheredchallenge(), output);
  }
  
  // required string challenge = 3;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->challenge().data(), this->challenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->challenge(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginStep1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 processID = 1;
  if (has_processid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->processid(), target);
  }
  
  // required string cipheredChallenge = 2;
  if (has_cipheredchallenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipheredchallenge().data(), this->cipheredchallenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->cipheredchallenge(), target);
  }
  
  // required string challenge = 3;
  if (has_challenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->challenge().data(), this->challenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->challenge(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginStep1::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 processID = 1;
    if (has_processid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->processid());
    }
    
    // required string cipheredChallenge = 2;
    if (has_cipheredchallenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cipheredchallenge());
    }
    
    // required string challenge = 3;
    if (has_challenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->challenge());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginStep1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginStep1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginStep1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginStep1::MergeFrom(const LoginStep1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_processid()) {
      set_processid(from.processid());
    }
    if (from.has_cipheredchallenge()) {
      set_cipheredchallenge(from.cipheredchallenge());
    }
    if (from.has_challenge()) {
      set_challenge(from.challenge());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginStep1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginStep1::CopyFrom(const LoginStep1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginStep1::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void LoginStep1::Swap(LoginStep1* other) {
  if (other != this) {
    std::swap(processid_, other->processid_);
    std::swap(cipheredchallenge_, other->cipheredchallenge_);
    std::swap(challenge_, other->challenge_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginStep1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginStep1_descriptor_;
  metadata.reflection = LoginStep1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginStep2::kProcessIDFieldNumber;
const int LoginStep2::kCipheredChallengeFieldNumber;
#endif  // !_MSC_VER

LoginStep2::LoginStep2()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginStep2::InitAsDefaultInstance() {
}

LoginStep2::LoginStep2(const LoginStep2& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginStep2::SharedCtor() {
  _cached_size_ = 0;
  processid_ = GOOGLE_LONGLONG(0);
  cipheredchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginStep2::~LoginStep2() {
  SharedDtor();
}

void LoginStep2::SharedDtor() {
  if (cipheredchallenge_ != &::google::protobuf::internal::kEmptyString) {
    delete cipheredchallenge_;
  }
  if (this != default_instance_) {
  }
}

void LoginStep2::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginStep2::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginStep2_descriptor_;
}

const LoginStep2& LoginStep2::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

LoginStep2* LoginStep2::default_instance_ = NULL;

LoginStep2* LoginStep2::New() const {
  return new LoginStep2;
}

void LoginStep2::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    processid_ = GOOGLE_LONGLONG(0);
    if (has_cipheredchallenge()) {
      if (cipheredchallenge_ != &::google::protobuf::internal::kEmptyString) {
        cipheredchallenge_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginStep2::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 processID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &processid_)));
          set_has_processid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_cipheredChallenge;
        break;
      }
      
      // required string cipheredChallenge = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cipheredChallenge:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cipheredchallenge()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cipheredchallenge().data(), this->cipheredchallenge().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginStep2::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 processID = 1;
  if (has_processid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->processid(), output);
  }
  
  // required string cipheredChallenge = 2;
  if (has_cipheredchallenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipheredchallenge().data(), this->cipheredchallenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->cipheredchallenge(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginStep2::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 processID = 1;
  if (has_processid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->processid(), target);
  }
  
  // required string cipheredChallenge = 2;
  if (has_cipheredchallenge()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipheredchallenge().data(), this->cipheredchallenge().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->cipheredchallenge(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginStep2::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 processID = 1;
    if (has_processid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->processid());
    }
    
    // required string cipheredChallenge = 2;
    if (has_cipheredchallenge()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cipheredchallenge());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginStep2::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginStep2* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginStep2*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginStep2::MergeFrom(const LoginStep2& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_processid()) {
      set_processid(from.processid());
    }
    if (from.has_cipheredchallenge()) {
      set_cipheredchallenge(from.cipheredchallenge());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginStep2::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginStep2::CopyFrom(const LoginStep2& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginStep2::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void LoginStep2::Swap(LoginStep2* other) {
  if (other != this) {
    std::swap(processid_, other->processid_);
    std::swap(cipheredchallenge_, other->cipheredchallenge_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginStep2::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginStep2_descriptor_;
  metadata.reflection = LoginStep2_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

LoginResponse::LoginResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

LoginResponse::LoginResponse(const LoginResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginResponse::~LoginResponse() {
  SharedDtor();
}

void LoginResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void LoginResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginResponse_descriptor_;
}

const LoginResponse& LoginResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

LoginResponse* LoginResponse::default_instance_ = NULL;

LoginResponse* LoginResponse::New() const {
  return new LoginResponse;
}

void LoginResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginResponse::MergeFrom(const LoginResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginResponse::CopyFrom(const LoginResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void LoginResponse::Swap(LoginResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginResponse_descriptor_;
  metadata.reflection = LoginResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Logout::kAgentIDFieldNumber;
#endif  // !_MSC_VER

Logout::Logout()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Logout::InitAsDefaultInstance() {
}

Logout::Logout(const Logout& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Logout::SharedCtor() {
  _cached_size_ = 0;
  agentid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Logout::~Logout() {
  SharedDtor();
}

void Logout::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Logout::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Logout::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Logout_descriptor_;
}

const Logout& Logout::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Logout* Logout::default_instance_ = NULL;

Logout* Logout::New() const {
  return new Logout;
}

void Logout::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agentid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Logout::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 agentID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Logout::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->agentid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Logout::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->agentid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Logout::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 agentID = 1;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Logout::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Logout* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Logout*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Logout::MergeFrom(const Logout& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Logout::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Logout::CopyFrom(const Logout& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Logout::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Logout::Swap(Logout* other) {
  if (other != this) {
    std::swap(agentid_, other->agentid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Logout::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Logout_descriptor_;
  metadata.reflection = Logout_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LogoutResponse::kStatusFieldNumber;
#endif  // !_MSC_VER

LogoutResponse::LogoutResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LogoutResponse::InitAsDefaultInstance() {
}

LogoutResponse::LogoutResponse(const LogoutResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LogoutResponse::SharedCtor() {
  _cached_size_ = 0;
  status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LogoutResponse::~LogoutResponse() {
  SharedDtor();
}

void LogoutResponse::SharedDtor() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (this != default_instance_) {
  }
}

void LogoutResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LogoutResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LogoutResponse_descriptor_;
}

const LogoutResponse& LogoutResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

LogoutResponse* LogoutResponse::default_instance_ = NULL;

LogoutResponse* LogoutResponse::New() const {
  return new LogoutResponse;
}

void LogoutResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_status()) {
      if (status_ != &::google::protobuf::internal::kEmptyString) {
        status_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LogoutResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string status = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->status().data(), this->status().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LogoutResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->status(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LogoutResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->status().data(), this->status().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->status(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LogoutResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LogoutResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LogoutResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LogoutResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LogoutResponse::MergeFrom(const LogoutResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_status(from.status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LogoutResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogoutResponse::CopyFrom(const LogoutResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogoutResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void LogoutResponse::Swap(LogoutResponse* other) {
  if (other != this) {
    std::swap(status_, other->status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LogoutResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LogoutResponse_descriptor_;
  metadata.reflection = LogoutResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetPeerList::kCountFieldNumber;
#endif  // !_MSC_VER

GetPeerList::GetPeerList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetPeerList::InitAsDefaultInstance() {
}

GetPeerList::GetPeerList(const GetPeerList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetPeerList::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPeerList::~GetPeerList() {
  SharedDtor();
}

void GetPeerList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetPeerList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPeerList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetPeerList_descriptor_;
}

const GetPeerList& GetPeerList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetPeerList* GetPeerList::default_instance_ = NULL;

GetPeerList* GetPeerList::New() const {
  return new GetPeerList;
}

void GetPeerList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetPeerList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetPeerList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetPeerList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->count(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetPeerList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPeerList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetPeerList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetPeerList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetPeerList::MergeFrom(const GetPeerList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetPeerList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPeerList::CopyFrom(const GetPeerList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPeerList::IsInitialized() const {
  
  return true;
}

void GetPeerList::Swap(GetPeerList* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetPeerList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetPeerList_descriptor_;
  metadata.reflection = GetPeerList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AgentData::kAgentIDFieldNumber;
const int AgentData::kAgentIPFieldNumber;
const int AgentData::kAgentPortFieldNumber;
const int AgentData::kTokenFieldNumber;
const int AgentData::kPublicKeyFieldNumber;
const int AgentData::kPeerStatusFieldNumber;
#endif  // !_MSC_VER

AgentData::AgentData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AgentData::InitAsDefaultInstance() {
  publickey_ = const_cast< ::org::umit::icm::mobile::proto::RSAKey*>(&::org::umit::icm::mobile::proto::RSAKey::default_instance());
}

AgentData::AgentData(const AgentData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AgentData::SharedCtor() {
  _cached_size_ = 0;
  agentid_ = GOOGLE_LONGLONG(0);
  agentip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  agentport_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  publickey_ = NULL;
  peerstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AgentData::~AgentData() {
  SharedDtor();
}

void AgentData::SharedDtor() {
  if (agentip_ != &::google::protobuf::internal::kEmptyString) {
    delete agentip_;
  }
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (peerstatus_ != &::google::protobuf::internal::kEmptyString) {
    delete peerstatus_;
  }
  if (this != default_instance_) {
    delete publickey_;
  }
}

void AgentData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AgentData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AgentData_descriptor_;
}

const AgentData& AgentData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AgentData* AgentData::default_instance_ = NULL;

AgentData* AgentData::New() const {
  return new AgentData;
}

void AgentData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agentid_ = GOOGLE_LONGLONG(0);
    if (has_agentip()) {
      if (agentip_ != &::google::protobuf::internal::kEmptyString) {
        agentip_->clear();
      }
    }
    agentport_ = 0;
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    if (has_publickey()) {
      if (publickey_ != NULL) publickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
    }
    if (has_peerstatus()) {
      if (peerstatus_ != &::google::protobuf::internal::kEmptyString) {
        peerstatus_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AgentData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 agentID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agentIP;
        break;
      }
      
      // required string agentIP = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agentIP:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_agentip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->agentip().data(), this->agentip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_agentPort;
        break;
      }
      
      // required int32 agentPort = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_agentPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &agentport_)));
          set_has_agentport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_token;
        break;
      }
      
      // required string token = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->token().data(), this->token().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_publicKey;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.RSAKey publicKey = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_publicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_publickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_peerStatus;
        break;
      }
      
      // required string peerStatus = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peerStatus:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_peerstatus()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->peerstatus().data(), this->peerstatus().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AgentData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->agentid(), output);
  }
  
  // required string agentIP = 2;
  if (has_agentip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agentip().data(), this->agentip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->agentip(), output);
  }
  
  // required int32 agentPort = 3;
  if (has_agentport()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->agentport(), output);
  }
  
  // required string token = 4;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->token(), output);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey publicKey = 5;
  if (has_publickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->publickey(), output);
  }
  
  // required string peerStatus = 6;
  if (has_peerstatus()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->peerstatus().data(), this->peerstatus().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->peerstatus(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AgentData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 agentID = 1;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->agentid(), target);
  }
  
  // required string agentIP = 2;
  if (has_agentip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agentip().data(), this->agentip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->agentip(), target);
  }
  
  // required int32 agentPort = 3;
  if (has_agentport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->agentport(), target);
  }
  
  // required string token = 4;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->token(), target);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey publicKey = 5;
  if (has_publickey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->publickey(), target);
  }
  
  // required string peerStatus = 6;
  if (has_peerstatus()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->peerstatus().data(), this->peerstatus().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->peerstatus(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AgentData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 agentID = 1;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
    // required string agentIP = 2;
    if (has_agentip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->agentip());
    }
    
    // required int32 agentPort = 3;
    if (has_agentport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->agentport());
    }
    
    // required string token = 4;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }
    
    // required .org.umit.icm.mobile.proto.RSAKey publicKey = 5;
    if (has_publickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->publickey());
    }
    
    // required string peerStatus = 6;
    if (has_peerstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->peerstatus());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AgentData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AgentData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AgentData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AgentData::MergeFrom(const AgentData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
    if (from.has_agentip()) {
      set_agentip(from.agentip());
    }
    if (from.has_agentport()) {
      set_agentport(from.agentport());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_publickey()) {
      mutable_publickey()->::org::umit::icm::mobile::proto::RSAKey::MergeFrom(from.publickey());
    }
    if (from.has_peerstatus()) {
      set_peerstatus(from.peerstatus());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AgentData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AgentData::CopyFrom(const AgentData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgentData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  
  if (has_publickey()) {
    if (!this->publickey().IsInitialized()) return false;
  }
  return true;
}

void AgentData::Swap(AgentData* other) {
  if (other != this) {
    std::swap(agentid_, other->agentid_);
    std::swap(agentip_, other->agentip_);
    std::swap(agentport_, other->agentport_);
    std::swap(token_, other->token_);
    std::swap(publickey_, other->publickey_);
    std::swap(peerstatus_, other->peerstatus_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AgentData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AgentData_descriptor_;
  metadata.reflection = AgentData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetPeerListResponse::kHeaderFieldNumber;
const int GetPeerListResponse::kKnownPeersFieldNumber;
#endif  // !_MSC_VER

GetPeerListResponse::GetPeerListResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetPeerListResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

GetPeerListResponse::GetPeerListResponse(const GetPeerListResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetPeerListResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPeerListResponse::~GetPeerListResponse() {
  SharedDtor();
}

void GetPeerListResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetPeerListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPeerListResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetPeerListResponse_descriptor_;
}

const GetPeerListResponse& GetPeerListResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetPeerListResponse* GetPeerListResponse::default_instance_ = NULL;

GetPeerListResponse* GetPeerListResponse::New() const {
  return new GetPeerListResponse;
}

void GetPeerListResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  knownpeers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetPeerListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_knownPeers;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.AgentData knownPeers = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_knownPeers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_knownpeers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_knownPeers;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetPeerListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.AgentData knownPeers = 2;
  for (int i = 0; i < this->knownpeers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->knownpeers(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetPeerListResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.AgentData knownPeers = 2;
  for (int i = 0; i < this->knownpeers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->knownpeers(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetPeerListResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.AgentData knownPeers = 2;
  total_size += 1 * this->knownpeers_size();
  for (int i = 0; i < this->knownpeers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->knownpeers(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPeerListResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetPeerListResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetPeerListResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetPeerListResponse::MergeFrom(const GetPeerListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  knownpeers_.MergeFrom(from.knownpeers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetPeerListResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPeerListResponse::CopyFrom(const GetPeerListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPeerListResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < knownpeers_size(); i++) {
    if (!this->knownpeers(i).IsInitialized()) return false;
  }
  return true;
}

void GetPeerListResponse::Swap(GetPeerListResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    knownpeers_.Swap(&other->knownpeers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetPeerListResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetPeerListResponse_descriptor_;
  metadata.reflection = GetPeerListResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetSuperPeerList::kCountFieldNumber;
#endif  // !_MSC_VER

GetSuperPeerList::GetSuperPeerList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetSuperPeerList::InitAsDefaultInstance() {
}

GetSuperPeerList::GetSuperPeerList(const GetSuperPeerList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetSuperPeerList::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetSuperPeerList::~GetSuperPeerList() {
  SharedDtor();
}

void GetSuperPeerList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetSuperPeerList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetSuperPeerList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetSuperPeerList_descriptor_;
}

const GetSuperPeerList& GetSuperPeerList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetSuperPeerList* GetSuperPeerList::default_instance_ = NULL;

GetSuperPeerList* GetSuperPeerList::New() const {
  return new GetSuperPeerList;
}

void GetSuperPeerList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetSuperPeerList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetSuperPeerList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetSuperPeerList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->count(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetSuperPeerList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetSuperPeerList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetSuperPeerList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetSuperPeerList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetSuperPeerList::MergeFrom(const GetSuperPeerList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetSuperPeerList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetSuperPeerList::CopyFrom(const GetSuperPeerList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSuperPeerList::IsInitialized() const {
  
  return true;
}

void GetSuperPeerList::Swap(GetSuperPeerList* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetSuperPeerList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetSuperPeerList_descriptor_;
  metadata.reflection = GetSuperPeerList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetSuperPeerListResponse::kHeaderFieldNumber;
const int GetSuperPeerListResponse::kKnownSuperPeersFieldNumber;
#endif  // !_MSC_VER

GetSuperPeerListResponse::GetSuperPeerListResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetSuperPeerListResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

GetSuperPeerListResponse::GetSuperPeerListResponse(const GetSuperPeerListResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetSuperPeerListResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetSuperPeerListResponse::~GetSuperPeerListResponse() {
  SharedDtor();
}

void GetSuperPeerListResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetSuperPeerListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetSuperPeerListResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetSuperPeerListResponse_descriptor_;
}

const GetSuperPeerListResponse& GetSuperPeerListResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetSuperPeerListResponse* GetSuperPeerListResponse::default_instance_ = NULL;

GetSuperPeerListResponse* GetSuperPeerListResponse::New() const {
  return new GetSuperPeerListResponse;
}

void GetSuperPeerListResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  knownsuperpeers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetSuperPeerListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_knownSuperPeers;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.AgentData knownSuperPeers = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_knownSuperPeers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_knownsuperpeers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_knownSuperPeers;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetSuperPeerListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.AgentData knownSuperPeers = 2;
  for (int i = 0; i < this->knownsuperpeers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->knownsuperpeers(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetSuperPeerListResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.AgentData knownSuperPeers = 2;
  for (int i = 0; i < this->knownsuperpeers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->knownsuperpeers(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetSuperPeerListResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.AgentData knownSuperPeers = 2;
  total_size += 1 * this->knownsuperpeers_size();
  for (int i = 0; i < this->knownsuperpeers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->knownsuperpeers(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetSuperPeerListResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetSuperPeerListResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetSuperPeerListResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetSuperPeerListResponse::MergeFrom(const GetSuperPeerListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  knownsuperpeers_.MergeFrom(from.knownsuperpeers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetSuperPeerListResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetSuperPeerListResponse::CopyFrom(const GetSuperPeerListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetSuperPeerListResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < knownsuperpeers_size(); i++) {
    if (!this->knownsuperpeers(i).IsInitialized()) return false;
  }
  return true;
}

void GetSuperPeerListResponse::Swap(GetSuperPeerListResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    knownsuperpeers_.Swap(&other->knownsuperpeers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetSuperPeerListResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetSuperPeerListResponse_descriptor_;
  metadata.reflection = GetSuperPeerListResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Location::kLongitudeFieldNumber;
const int Location::kLatitudeFieldNumber;
#endif  // !_MSC_VER

Location::Location()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Location::InitAsDefaultInstance() {
}

Location::Location(const Location& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Location::SharedCtor() {
  _cached_size_ = 0;
  longitude_ = 0;
  latitude_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location::~Location() {
  SharedDtor();
}

void Location::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Location::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Location::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Location_descriptor_;
}

const Location& Location::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Location* Location::default_instance_ = NULL;

Location* Location::New() const {
  return new Location;
}

void Location::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    longitude_ = 0;
    latitude_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Location::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double longitude = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &longitude_)));
          set_has_longitude();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_latitude;
        break;
      }
      
      // required double latitude = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_latitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &latitude_)));
          set_has_latitude();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Location::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double longitude = 1;
  if (has_longitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->longitude(), output);
  }
  
  // required double latitude = 2;
  if (has_latitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->latitude(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Location::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double longitude = 1;
  if (has_longitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->longitude(), target);
  }
  
  // required double latitude = 2;
  if (has_latitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->latitude(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Location::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double longitude = 1;
    if (has_longitude()) {
      total_size += 1 + 8;
    }
    
    // required double latitude = 2;
    if (has_latitude()) {
      total_size += 1 + 8;
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Location::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Location* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Location*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Location::MergeFrom(const Location& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_longitude()) {
      set_longitude(from.longitude());
    }
    if (from.has_latitude()) {
      set_latitude(from.latitude());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Location::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Location::CopyFrom(const Location& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void Location::Swap(Location* other) {
  if (other != this) {
    std::swap(longitude_, other->longitude_);
    std::swap(latitude_, other->latitude_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Location::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Location_descriptor_;
  metadata.reflection = Location_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetEvents::kLocationsFieldNumber;
const int GetEvents::kAgentLocationFieldNumber;
#endif  // !_MSC_VER

GetEvents::GetEvents()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetEvents::InitAsDefaultInstance() {
  agentlocation_ = const_cast< ::org::umit::icm::mobile::proto::Location*>(&::org::umit::icm::mobile::proto::Location::default_instance());
}

GetEvents::GetEvents(const GetEvents& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetEvents::SharedCtor() {
  _cached_size_ = 0;
  agentlocation_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetEvents::~GetEvents() {
  SharedDtor();
}

void GetEvents::SharedDtor() {
  if (this != default_instance_) {
    delete agentlocation_;
  }
}

void GetEvents::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetEvents::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetEvents_descriptor_;
}

const GetEvents& GetEvents::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetEvents* GetEvents::default_instance_ = NULL;

GetEvents* GetEvents::New() const {
  return new GetEvents;
}

void GetEvents::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_agentlocation()) {
      if (agentlocation_ != NULL) agentlocation_->::org::umit::icm::mobile::proto::Location::Clear();
    }
  }
  locations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetEvents::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .org.umit.icm.mobile.proto.Location locations = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_locations;
        if (input->ExpectTag(18)) goto parse_agentLocation;
        break;
      }
      
      // optional .org.umit.icm.mobile.proto.Location agentLocation = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agentLocation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_agentlocation()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetEvents::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .org.umit.icm.mobile.proto.Location locations = 1;
  for (int i = 0; i < this->locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->locations(i), output);
  }
  
  // optional .org.umit.icm.mobile.proto.Location agentLocation = 2;
  if (has_agentlocation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->agentlocation(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetEvents::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .org.umit.icm.mobile.proto.Location locations = 1;
  for (int i = 0; i < this->locations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->locations(i), target);
  }
  
  // optional .org.umit.icm.mobile.proto.Location agentLocation = 2;
  if (has_agentlocation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->agentlocation(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetEvents::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional .org.umit.icm.mobile.proto.Location agentLocation = 2;
    if (has_agentlocation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->agentlocation());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.Location locations = 1;
  total_size += 1 * this->locations_size();
  for (int i = 0; i < this->locations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->locations(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetEvents::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetEvents* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetEvents*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetEvents::MergeFrom(const GetEvents& from) {
  GOOGLE_CHECK_NE(&from, this);
  locations_.MergeFrom(from.locations_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_agentlocation()) {
      mutable_agentlocation()->::org::umit::icm::mobile::proto::Location::MergeFrom(from.agentlocation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetEvents::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetEvents::CopyFrom(const GetEvents& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetEvents::IsInitialized() const {
  
  for (int i = 0; i < locations_size(); i++) {
    if (!this->locations(i).IsInitialized()) return false;
  }
  if (has_agentlocation()) {
    if (!this->agentlocation().IsInitialized()) return false;
  }
  return true;
}

void GetEvents::Swap(GetEvents* other) {
  if (other != this) {
    locations_.Swap(&other->locations_);
    std::swap(agentlocation_, other->agentlocation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetEvents::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetEvents_descriptor_;
  metadata.reflection = GetEvents_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Event::kTestTypeFieldNumber;
const int Event::kEventTypeFieldNumber;
const int Event::kTimeUTCFieldNumber;
const int Event::kSinceTimeUTCFieldNumber;
const int Event::kLocationsFieldNumber;
const int Event::kWebsiteReportFieldNumber;
const int Event::kServiceReportFieldNumber;
#endif  // !_MSC_VER

Event::Event()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Event::InitAsDefaultInstance() {
  websitereport_ = const_cast< ::org::umit::icm::mobile::proto::WebsiteReportDetail*>(&::org::umit::icm::mobile::proto::WebsiteReportDetail::default_instance());
  servicereport_ = const_cast< ::org::umit::icm::mobile::proto::ServiceReportDetail*>(&::org::umit::icm::mobile::proto::ServiceReportDetail::default_instance());
}

Event::Event(const Event& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Event::SharedCtor() {
  _cached_size_ = 0;
  testtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  timeutc_ = GOOGLE_LONGLONG(0);
  sincetimeutc_ = GOOGLE_LONGLONG(0);
  websitereport_ = NULL;
  servicereport_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Event::~Event() {
  SharedDtor();
}

void Event::SharedDtor() {
  if (testtype_ != &::google::protobuf::internal::kEmptyString) {
    delete testtype_;
  }
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    delete eventtype_;
  }
  if (this != default_instance_) {
    delete websitereport_;
    delete servicereport_;
  }
}

void Event::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Event::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Event_descriptor_;
}

const Event& Event::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Event* Event::default_instance_ = NULL;

Event* Event::New() const {
  return new Event;
}

void Event::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_testtype()) {
      if (testtype_ != &::google::protobuf::internal::kEmptyString) {
        testtype_->clear();
      }
    }
    if (has_eventtype()) {
      if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
        eventtype_->clear();
      }
    }
    timeutc_ = GOOGLE_LONGLONG(0);
    sincetimeutc_ = GOOGLE_LONGLONG(0);
    if (has_websitereport()) {
      if (websitereport_ != NULL) websitereport_->::org::umit::icm::mobile::proto::WebsiteReportDetail::Clear();
    }
    if (has_servicereport()) {
      if (servicereport_ != NULL) servicereport_->::org::umit::icm::mobile::proto::ServiceReportDetail::Clear();
    }
  }
  locations_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Event::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string testType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_testtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->testtype().data(), this->testtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_eventType;
        break;
      }
      
      // required string eventType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_eventType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_eventtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->eventtype().data(), this->eventtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_timeUTC;
        break;
      }
      
      // required int64 timeUTC = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_timeUTC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &timeutc_)));
          set_has_timeutc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sinceTimeUTC;
        break;
      }
      
      // required int64 sinceTimeUTC = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sinceTimeUTC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sincetimeutc_)));
          set_has_sincetimeutc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_locations;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.Location locations = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_locations:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_locations()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_locations;
        if (input->ExpectTag(50)) goto parse_websiteReport;
        break;
      }
      
      // optional .org.umit.icm.mobile.proto.WebsiteReportDetail websiteReport = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_websiteReport:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_websitereport()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_serviceReport;
        break;
      }
      
      // optional .org.umit.icm.mobile.proto.ServiceReportDetail serviceReport = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serviceReport:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_servicereport()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Event::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string testType = 1;
  if (has_testtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->testtype().data(), this->testtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->testtype(), output);
  }
  
  // required string eventType = 2;
  if (has_eventtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eventtype().data(), this->eventtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->eventtype(), output);
  }
  
  // required int64 timeUTC = 3;
  if (has_timeutc()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->timeutc(), output);
  }
  
  // required int64 sinceTimeUTC = 4;
  if (has_sincetimeutc()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->sincetimeutc(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.Location locations = 5;
  for (int i = 0; i < this->locations_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->locations(i), output);
  }
  
  // optional .org.umit.icm.mobile.proto.WebsiteReportDetail websiteReport = 6;
  if (has_websitereport()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->websitereport(), output);
  }
  
  // optional .org.umit.icm.mobile.proto.ServiceReportDetail serviceReport = 7;
  if (has_servicereport()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->servicereport(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Event::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string testType = 1;
  if (has_testtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->testtype().data(), this->testtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->testtype(), target);
  }
  
  // required string eventType = 2;
  if (has_eventtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->eventtype().data(), this->eventtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->eventtype(), target);
  }
  
  // required int64 timeUTC = 3;
  if (has_timeutc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->timeutc(), target);
  }
  
  // required int64 sinceTimeUTC = 4;
  if (has_sincetimeutc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->sincetimeutc(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.Location locations = 5;
  for (int i = 0; i < this->locations_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->locations(i), target);
  }
  
  // optional .org.umit.icm.mobile.proto.WebsiteReportDetail websiteReport = 6;
  if (has_websitereport()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->websitereport(), target);
  }
  
  // optional .org.umit.icm.mobile.proto.ServiceReportDetail serviceReport = 7;
  if (has_servicereport()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->servicereport(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Event::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string testType = 1;
    if (has_testtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->testtype());
    }
    
    // required string eventType = 2;
    if (has_eventtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->eventtype());
    }
    
    // required int64 timeUTC = 3;
    if (has_timeutc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->timeutc());
    }
    
    // required int64 sinceTimeUTC = 4;
    if (has_sincetimeutc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sincetimeutc());
    }
    
    // optional .org.umit.icm.mobile.proto.WebsiteReportDetail websiteReport = 6;
    if (has_websitereport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->websitereport());
    }
    
    // optional .org.umit.icm.mobile.proto.ServiceReportDetail serviceReport = 7;
    if (has_servicereport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->servicereport());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.Location locations = 5;
  total_size += 1 * this->locations_size();
  for (int i = 0; i < this->locations_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->locations(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Event::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Event* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Event*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Event::MergeFrom(const Event& from) {
  GOOGLE_CHECK_NE(&from, this);
  locations_.MergeFrom(from.locations_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_testtype()) {
      set_testtype(from.testtype());
    }
    if (from.has_eventtype()) {
      set_eventtype(from.eventtype());
    }
    if (from.has_timeutc()) {
      set_timeutc(from.timeutc());
    }
    if (from.has_sincetimeutc()) {
      set_sincetimeutc(from.sincetimeutc());
    }
    if (from.has_websitereport()) {
      mutable_websitereport()->::org::umit::icm::mobile::proto::WebsiteReportDetail::MergeFrom(from.websitereport());
    }
    if (from.has_servicereport()) {
      mutable_servicereport()->::org::umit::icm::mobile::proto::ServiceReportDetail::MergeFrom(from.servicereport());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Event::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Event::CopyFrom(const Event& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Event::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  for (int i = 0; i < locations_size(); i++) {
    if (!this->locations(i).IsInitialized()) return false;
  }
  if (has_websitereport()) {
    if (!this->websitereport().IsInitialized()) return false;
  }
  if (has_servicereport()) {
    if (!this->servicereport().IsInitialized()) return false;
  }
  return true;
}

void Event::Swap(Event* other) {
  if (other != this) {
    std::swap(testtype_, other->testtype_);
    std::swap(eventtype_, other->eventtype_);
    std::swap(timeutc_, other->timeutc_);
    std::swap(sincetimeutc_, other->sincetimeutc_);
    locations_.Swap(&other->locations_);
    std::swap(websitereport_, other->websitereport_);
    std::swap(servicereport_, other->servicereport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Event::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Event_descriptor_;
  metadata.reflection = Event_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetEventsResponse::kHeaderFieldNumber;
const int GetEventsResponse::kEventsFieldNumber;
#endif  // !_MSC_VER

GetEventsResponse::GetEventsResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetEventsResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

GetEventsResponse::GetEventsResponse(const GetEventsResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetEventsResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetEventsResponse::~GetEventsResponse() {
  SharedDtor();
}

void GetEventsResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetEventsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetEventsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetEventsResponse_descriptor_;
}

const GetEventsResponse& GetEventsResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetEventsResponse* GetEventsResponse::default_instance_ = NULL;

GetEventsResponse* GetEventsResponse::New() const {
  return new GetEventsResponse;
}

void GetEventsResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  events_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetEventsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_events;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.Event events = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_events:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_events()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_events;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetEventsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.Event events = 2;
  for (int i = 0; i < this->events_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->events(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetEventsResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.Event events = 2;
  for (int i = 0; i < this->events_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->events(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetEventsResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.Event events = 2;
  total_size += 1 * this->events_size();
  for (int i = 0; i < this->events_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->events(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetEventsResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetEventsResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetEventsResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetEventsResponse::MergeFrom(const GetEventsResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  events_.MergeFrom(from.events_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetEventsResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetEventsResponse::CopyFrom(const GetEventsResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetEventsResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < events_size(); i++) {
    if (!this->events(i).IsInitialized()) return false;
  }
  return true;
}

void GetEventsResponse::Swap(GetEventsResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    events_.Swap(&other->events_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetEventsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetEventsResponse_descriptor_;
  metadata.reflection = GetEventsResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendWebsiteReport::kReportFieldNumber;
#endif  // !_MSC_VER

SendWebsiteReport::SendWebsiteReport()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SendWebsiteReport::InitAsDefaultInstance() {
  report_ = const_cast< ::org::umit::icm::mobile::proto::WebsiteReport*>(&::org::umit::icm::mobile::proto::WebsiteReport::default_instance());
}

SendWebsiteReport::SendWebsiteReport(const SendWebsiteReport& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SendWebsiteReport::SharedCtor() {
  _cached_size_ = 0;
  report_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendWebsiteReport::~SendWebsiteReport() {
  SharedDtor();
}

void SendWebsiteReport::SharedDtor() {
  if (this != default_instance_) {
    delete report_;
  }
}

void SendWebsiteReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendWebsiteReport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendWebsiteReport_descriptor_;
}

const SendWebsiteReport& SendWebsiteReport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

SendWebsiteReport* SendWebsiteReport::default_instance_ = NULL;

SendWebsiteReport* SendWebsiteReport::New() const {
  return new SendWebsiteReport;
}

void SendWebsiteReport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_report()) {
      if (report_ != NULL) report_->::org::umit::icm::mobile::proto::WebsiteReport::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendWebsiteReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.WebsiteReport report = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_report()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendWebsiteReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.WebsiteReport report = 1;
  if (has_report()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->report(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SendWebsiteReport::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.WebsiteReport report = 1;
  if (has_report()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->report(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SendWebsiteReport::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.WebsiteReport report = 1;
    if (has_report()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->report());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendWebsiteReport::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendWebsiteReport* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendWebsiteReport*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendWebsiteReport::MergeFrom(const SendWebsiteReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_report()) {
      mutable_report()->::org::umit::icm::mobile::proto::WebsiteReport::MergeFrom(from.report());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendWebsiteReport::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendWebsiteReport::CopyFrom(const SendWebsiteReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendWebsiteReport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_report()) {
    if (!this->report().IsInitialized()) return false;
  }
  return true;
}

void SendWebsiteReport::Swap(SendWebsiteReport* other) {
  if (other != this) {
    std::swap(report_, other->report_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendWebsiteReport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendWebsiteReport_descriptor_;
  metadata.reflection = SendWebsiteReport_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendServiceReport::kReportFieldNumber;
#endif  // !_MSC_VER

SendServiceReport::SendServiceReport()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SendServiceReport::InitAsDefaultInstance() {
  report_ = const_cast< ::org::umit::icm::mobile::proto::ServiceReport*>(&::org::umit::icm::mobile::proto::ServiceReport::default_instance());
}

SendServiceReport::SendServiceReport(const SendServiceReport& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SendServiceReport::SharedCtor() {
  _cached_size_ = 0;
  report_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendServiceReport::~SendServiceReport() {
  SharedDtor();
}

void SendServiceReport::SharedDtor() {
  if (this != default_instance_) {
    delete report_;
  }
}

void SendServiceReport::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendServiceReport::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendServiceReport_descriptor_;
}

const SendServiceReport& SendServiceReport::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

SendServiceReport* SendServiceReport::default_instance_ = NULL;

SendServiceReport* SendServiceReport::New() const {
  return new SendServiceReport;
}

void SendServiceReport::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_report()) {
      if (report_ != NULL) report_->::org::umit::icm::mobile::proto::ServiceReport::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendServiceReport::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ServiceReport report = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_report()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendServiceReport::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ServiceReport report = 1;
  if (has_report()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->report(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SendServiceReport::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ServiceReport report = 1;
  if (has_report()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->report(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SendServiceReport::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ServiceReport report = 1;
    if (has_report()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->report());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendServiceReport::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendServiceReport* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendServiceReport*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendServiceReport::MergeFrom(const SendServiceReport& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_report()) {
      mutable_report()->::org::umit::icm::mobile::proto::ServiceReport::MergeFrom(from.report());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendServiceReport::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendServiceReport::CopyFrom(const SendServiceReport& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendServiceReport::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_report()) {
    if (!this->report().IsInitialized()) return false;
  }
  return true;
}

void SendServiceReport::Swap(SendServiceReport* other) {
  if (other != this) {
    std::swap(report_, other->report_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendServiceReport::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendServiceReport_descriptor_;
  metadata.reflection = SendServiceReport_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendReportResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

SendReportResponse::SendReportResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SendReportResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

SendReportResponse::SendReportResponse(const SendReportResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SendReportResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendReportResponse::~SendReportResponse() {
  SharedDtor();
}

void SendReportResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void SendReportResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendReportResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendReportResponse_descriptor_;
}

const SendReportResponse& SendReportResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

SendReportResponse* SendReportResponse::default_instance_ = NULL;

SendReportResponse* SendReportResponse::New() const {
  return new SendReportResponse;
}

void SendReportResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendReportResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SendReportResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SendReportResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SendReportResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendReportResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendReportResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendReportResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendReportResponse::MergeFrom(const SendReportResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendReportResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendReportResponse::CopyFrom(const SendReportResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendReportResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void SendReportResponse::Swap(SendReportResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendReportResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendReportResponse_descriptor_;
  metadata.reflection = SendReportResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewVersion::kAgentVersionNoFieldNumber;
const int NewVersion::kAgentTypeFieldNumber;
#endif  // !_MSC_VER

NewVersion::NewVersion()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewVersion::InitAsDefaultInstance() {
}

NewVersion::NewVersion(const NewVersion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewVersion::SharedCtor() {
  _cached_size_ = 0;
  agentversionno_ = 0;
  agenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewVersion::~NewVersion() {
  SharedDtor();
}

void NewVersion::SharedDtor() {
  if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
    delete agenttype_;
  }
  if (this != default_instance_) {
  }
}

void NewVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewVersion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewVersion_descriptor_;
}

const NewVersion& NewVersion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

NewVersion* NewVersion::default_instance_ = NULL;

NewVersion* NewVersion::New() const {
  return new NewVersion;
}

void NewVersion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agentversionno_ = 0;
    if (has_agenttype()) {
      if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
        agenttype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 agentVersionNo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &agentversionno_)));
          set_has_agentversionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_agentType;
        break;
      }
      
      // required string agentType = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_agentType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_agenttype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->agenttype().data(), this->agenttype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 agentVersionNo = 1;
  if (has_agentversionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->agentversionno(), output);
  }
  
  // required string agentType = 2;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agenttype().data(), this->agenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->agenttype(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewVersion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 agentVersionNo = 1;
  if (has_agentversionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->agentversionno(), target);
  }
  
  // required string agentType = 2;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->agenttype().data(), this->agenttype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->agenttype(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewVersion::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 agentVersionNo = 1;
    if (has_agentversionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->agentversionno());
    }
    
    // required string agentType = 2;
    if (has_agenttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->agenttype());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewVersion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewVersion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewVersion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewVersion::MergeFrom(const NewVersion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agentversionno()) {
      set_agentversionno(from.agentversionno());
    }
    if (from.has_agenttype()) {
      set_agenttype(from.agenttype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewVersion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewVersion::CopyFrom(const NewVersion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewVersion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void NewVersion::Swap(NewVersion* other) {
  if (other != this) {
    std::swap(agentversionno_, other->agentversionno_);
    std::swap(agenttype_, other->agenttype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewVersion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewVersion_descriptor_;
  metadata.reflection = NewVersion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewVersionResponse::kHeaderFieldNumber;
const int NewVersionResponse::kDownloadURLFieldNumber;
const int NewVersionResponse::kUpdateFieldNumber;
const int NewVersionResponse::kVersionNoFieldNumber;
#endif  // !_MSC_VER

NewVersionResponse::NewVersionResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewVersionResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

NewVersionResponse::NewVersionResponse(const NewVersionResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewVersionResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  update_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  versionno_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewVersionResponse::~NewVersionResponse() {
  SharedDtor();
}

void NewVersionResponse::SharedDtor() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (update_ != &::google::protobuf::internal::kEmptyString) {
    delete update_;
  }
  if (this != default_instance_) {
    delete header_;
  }
}

void NewVersionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewVersionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewVersionResponse_descriptor_;
}

const NewVersionResponse& NewVersionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

NewVersionResponse* NewVersionResponse::default_instance_ = NULL;

NewVersionResponse* NewVersionResponse::New() const {
  return new NewVersionResponse;
}

void NewVersionResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
    if (has_downloadurl()) {
      if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
        downloadurl_->clear();
      }
    }
    if (has_update()) {
      if (update_ != &::google::protobuf::internal::kEmptyString) {
        update_->clear();
      }
    }
    versionno_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewVersionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_downloadURL;
        break;
      }
      
      // optional string downloadURL = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_downloadURL:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_downloadurl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->downloadurl().data(), this->downloadurl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_update;
        break;
      }
      
      // optional bytes update = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_update:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_update()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_versionNo;
        break;
      }
      
      // required int32 versionNo = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_versionNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &versionno_)));
          set_has_versionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewVersionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // optional string downloadURL = 2;
  if (has_downloadurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->downloadurl().data(), this->downloadurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->downloadurl(), output);
  }
  
  // optional bytes update = 3;
  if (has_update()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->update(), output);
  }
  
  // required int32 versionNo = 4;
  if (has_versionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->versionno(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewVersionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // optional string downloadURL = 2;
  if (has_downloadurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->downloadurl().data(), this->downloadurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->downloadurl(), target);
  }
  
  // optional bytes update = 3;
  if (has_update()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->update(), target);
  }
  
  // required int32 versionNo = 4;
  if (has_versionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->versionno(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewVersionResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // optional string downloadURL = 2;
    if (has_downloadurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->downloadurl());
    }
    
    // optional bytes update = 3;
    if (has_update()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->update());
    }
    
    // required int32 versionNo = 4;
    if (has_versionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->versionno());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewVersionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewVersionResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewVersionResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewVersionResponse::MergeFrom(const NewVersionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_downloadurl()) {
      set_downloadurl(from.downloadurl());
    }
    if (from.has_update()) {
      set_update(from.update());
    }
    if (from.has_versionno()) {
      set_versionno(from.versionno());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewVersionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewVersionResponse::CopyFrom(const NewVersionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewVersionResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void NewVersionResponse::Swap(NewVersionResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(downloadurl_, other->downloadurl_);
    std::swap(update_, other->update_);
    std::swap(versionno_, other->versionno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewVersionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewVersionResponse_descriptor_;
  metadata.reflection = NewVersionResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewTests::kCurrentTestVersionNoFieldNumber;
#endif  // !_MSC_VER

NewTests::NewTests()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewTests::InitAsDefaultInstance() {
}

NewTests::NewTests(const NewTests& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewTests::SharedCtor() {
  _cached_size_ = 0;
  currenttestversionno_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewTests::~NewTests() {
  SharedDtor();
}

void NewTests::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NewTests::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewTests::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewTests_descriptor_;
}

const NewTests& NewTests::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

NewTests* NewTests::default_instance_ = NULL;

NewTests* NewTests::New() const {
  return new NewTests;
}

void NewTests::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    currenttestversionno_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewTests::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 currentTestVersionNo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &currenttestversionno_)));
          set_has_currenttestversionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewTests::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 currentTestVersionNo = 1;
  if (has_currenttestversionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->currenttestversionno(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewTests::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 currentTestVersionNo = 1;
  if (has_currenttestversionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->currenttestversionno(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewTests::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 currentTestVersionNo = 1;
    if (has_currenttestversionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->currenttestversionno());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewTests::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewTests* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewTests*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewTests::MergeFrom(const NewTests& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_currenttestversionno()) {
      set_currenttestversionno(from.currenttestversionno());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewTests::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewTests::CopyFrom(const NewTests& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewTests::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void NewTests::Swap(NewTests* other) {
  if (other != this) {
    std::swap(currenttestversionno_, other->currenttestversionno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewTests::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewTests_descriptor_;
  metadata.reflection = NewTests_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Website::kUrlFieldNumber;
#endif  // !_MSC_VER

Website::Website()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Website::InitAsDefaultInstance() {
}

Website::Website(const Website& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Website::SharedCtor() {
  _cached_size_ = 0;
  url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Website::~Website() {
  SharedDtor();
}

void Website::SharedDtor() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (this != default_instance_) {
  }
}

void Website::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Website::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Website_descriptor_;
}

const Website& Website::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Website* Website::default_instance_ = NULL;

Website* Website::New() const {
  return new Website;
}

void Website::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_url()) {
      if (url_ != &::google::protobuf::internal::kEmptyString) {
        url_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Website::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string url = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->url().data(), this->url().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Website::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string url = 1;
  if (has_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->url(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Website::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string url = 1;
  if (has_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->url(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Website::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string url = 1;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Website::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Website* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Website*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Website::MergeFrom(const Website& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_url()) {
      set_url(from.url());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Website::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Website::CopyFrom(const Website& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Website::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void Website::Swap(Website* other) {
  if (other != this) {
    std::swap(url_, other->url_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Website::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Website_descriptor_;
  metadata.reflection = Website_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Service::kNameFieldNumber;
const int Service::kPortFieldNumber;
const int Service::kIpFieldNumber;
#endif  // !_MSC_VER

Service::Service()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Service::InitAsDefaultInstance() {
}

Service::Service(const Service& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Service::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Service::~Service() {
  SharedDtor();
}

void Service::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void Service::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Service::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Service_descriptor_;
}

const Service& Service::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Service* Service::default_instance_ = NULL;

Service* Service::New() const {
  return new Service;
}

void Service::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    port_ = 0;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Service::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }
      
      // required int32 port = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }
      
      // required string ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Service::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }
  
  // required int32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->port(), output);
  }
  
  // required string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->ip(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Service::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }
  
  // required int32 port = 2;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->port(), target);
  }
  
  // required string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->ip(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Service::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // required int32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }
    
    // required string ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Service::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Service* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Service*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Service::MergeFrom(const Service& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Service::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Service::CopyFrom(const Service& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Service::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void Service::Swap(Service* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(port_, other->port_);
    std::swap(ip_, other->ip_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Service::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Service_descriptor_;
  metadata.reflection = Service_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Test::kTestIDFieldNumber;
const int Test::kWebsiteFieldNumber;
const int Test::kServiceFieldNumber;
const int Test::kExecuteAtTimeUTCFieldNumber;
const int Test::kTestTypeFieldNumber;
#endif  // !_MSC_VER

Test::Test()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Test::InitAsDefaultInstance() {
  website_ = const_cast< ::org::umit::icm::mobile::proto::Website*>(&::org::umit::icm::mobile::proto::Website::default_instance());
  service_ = const_cast< ::org::umit::icm::mobile::proto::Service*>(&::org::umit::icm::mobile::proto::Service::default_instance());
}

Test::Test(const Test& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Test::SharedCtor() {
  _cached_size_ = 0;
  testid_ = GOOGLE_LONGLONG(0);
  website_ = NULL;
  service_ = NULL;
  executeattimeutc_ = GOOGLE_LONGLONG(0);
  testtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test::~Test() {
  SharedDtor();
}

void Test::SharedDtor() {
  if (testtype_ != &::google::protobuf::internal::kEmptyString) {
    delete testtype_;
  }
  if (this != default_instance_) {
    delete website_;
    delete service_;
  }
}

void Test::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Test::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Test_descriptor_;
}

const Test& Test::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

Test* Test::default_instance_ = NULL;

Test* Test::New() const {
  return new Test;
}

void Test::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    testid_ = GOOGLE_LONGLONG(0);
    if (has_website()) {
      if (website_ != NULL) website_->::org::umit::icm::mobile::proto::Website::Clear();
    }
    if (has_service()) {
      if (service_ != NULL) service_->::org::umit::icm::mobile::proto::Service::Clear();
    }
    executeattimeutc_ = GOOGLE_LONGLONG(0);
    if (has_testtype()) {
      if (testtype_ != &::google::protobuf::internal::kEmptyString) {
        testtype_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Test::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 testID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &testid_)));
          set_has_testid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_website;
        break;
      }
      
      // optional .org.umit.icm.mobile.proto.Website website = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_website:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_website()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_service;
        break;
      }
      
      // optional .org.umit.icm.mobile.proto.Service service = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_service:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_service()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_executeAtTimeUTC;
        break;
      }
      
      // optional int64 executeAtTimeUTC = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_executeAtTimeUTC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &executeattimeutc_)));
          set_has_executeattimeutc();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_testType;
        break;
      }
      
      // required string testType = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_testType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_testtype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->testtype().data(), this->testtype().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 testID = 1;
  if (has_testid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->testid(), output);
  }
  
  // optional .org.umit.icm.mobile.proto.Website website = 2;
  if (has_website()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->website(), output);
  }
  
  // optional .org.umit.icm.mobile.proto.Service service = 3;
  if (has_service()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->service(), output);
  }
  
  // optional int64 executeAtTimeUTC = 4;
  if (has_executeattimeutc()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->executeattimeutc(), output);
  }
  
  // required string testType = 5;
  if (has_testtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->testtype().data(), this->testtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->testtype(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Test::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 testID = 1;
  if (has_testid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->testid(), target);
  }
  
  // optional .org.umit.icm.mobile.proto.Website website = 2;
  if (has_website()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->website(), target);
  }
  
  // optional .org.umit.icm.mobile.proto.Service service = 3;
  if (has_service()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->service(), target);
  }
  
  // optional int64 executeAtTimeUTC = 4;
  if (has_executeattimeutc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->executeattimeutc(), target);
  }
  
  // required string testType = 5;
  if (has_testtype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->testtype().data(), this->testtype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->testtype(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Test::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 testID = 1;
    if (has_testid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->testid());
    }
    
    // optional .org.umit.icm.mobile.proto.Website website = 2;
    if (has_website()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->website());
    }
    
    // optional .org.umit.icm.mobile.proto.Service service = 3;
    if (has_service()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->service());
    }
    
    // optional int64 executeAtTimeUTC = 4;
    if (has_executeattimeutc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->executeattimeutc());
    }
    
    // required string testType = 5;
    if (has_testtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->testtype());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Test* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Test*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Test::MergeFrom(const Test& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_testid()) {
      set_testid(from.testid());
    }
    if (from.has_website()) {
      mutable_website()->::org::umit::icm::mobile::proto::Website::MergeFrom(from.website());
    }
    if (from.has_service()) {
      mutable_service()->::org::umit::icm::mobile::proto::Service::MergeFrom(from.service());
    }
    if (from.has_executeattimeutc()) {
      set_executeattimeutc(from.executeattimeutc());
    }
    if (from.has_testtype()) {
      set_testtype(from.testtype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Test::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Test::CopyFrom(const Test& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000011) != 0x00000011) return false;
  
  if (has_website()) {
    if (!this->website().IsInitialized()) return false;
  }
  if (has_service()) {
    if (!this->service().IsInitialized()) return false;
  }
  return true;
}

void Test::Swap(Test* other) {
  if (other != this) {
    std::swap(testid_, other->testid_);
    std::swap(website_, other->website_);
    std::swap(service_, other->service_);
    std::swap(executeattimeutc_, other->executeattimeutc_);
    std::swap(testtype_, other->testtype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Test::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Test_descriptor_;
  metadata.reflection = Test_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NewTestsResponse::kHeaderFieldNumber;
const int NewTestsResponse::kTestsFieldNumber;
const int NewTestsResponse::kTestVersionNoFieldNumber;
#endif  // !_MSC_VER

NewTestsResponse::NewTestsResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewTestsResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

NewTestsResponse::NewTestsResponse(const NewTestsResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewTestsResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  testversionno_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewTestsResponse::~NewTestsResponse() {
  SharedDtor();
}

void NewTestsResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void NewTestsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewTestsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewTestsResponse_descriptor_;
}

const NewTestsResponse& NewTestsResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

NewTestsResponse* NewTestsResponse::default_instance_ = NULL;

NewTestsResponse* NewTestsResponse::New() const {
  return new NewTestsResponse;
}

void NewTestsResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
    testversionno_ = 0;
  }
  tests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewTestsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tests;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.Test tests = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tests()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tests;
        if (input->ExpectTag(24)) goto parse_testVersionNo;
        break;
      }
      
      // required int32 testVersionNo = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_testVersionNo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &testversionno_)));
          set_has_testversionno();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewTestsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  for (int i = 0; i < this->tests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tests(i), output);
  }
  
  // required int32 testVersionNo = 3;
  if (has_testversionno()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->testversionno(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewTestsResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  for (int i = 0; i < this->tests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tests(i), target);
  }
  
  // required int32 testVersionNo = 3;
  if (has_testversionno()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->testversionno(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewTestsResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required int32 testVersionNo = 3;
    if (has_testversionno()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->testversionno());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  total_size += 1 * this->tests_size();
  for (int i = 0; i < this->tests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tests(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewTestsResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewTestsResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewTestsResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewTestsResponse::MergeFrom(const NewTestsResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  tests_.MergeFrom(from.tests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_testversionno()) {
      set_testversionno(from.testversionno());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewTestsResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewTestsResponse::CopyFrom(const NewTestsResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewTestsResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < tests_size(); i++) {
    if (!this->tests(i).IsInitialized()) return false;
  }
  return true;
}

void NewTestsResponse::Swap(NewTestsResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    tests_.Swap(&other->tests_);
    std::swap(testversionno_, other->testversionno_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewTestsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewTestsResponse_descriptor_;
  metadata.reflection = NewTestsResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AssignTask::kHeaderFieldNumber;
#endif  // !_MSC_VER

AssignTask::AssignTask()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AssignTask::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::RequestHeader*>(&::org::umit::icm::mobile::proto::RequestHeader::default_instance());
}

AssignTask::AssignTask(const AssignTask& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AssignTask::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AssignTask::~AssignTask() {
  SharedDtor();
}

void AssignTask::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AssignTask::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AssignTask::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AssignTask_descriptor_;
}

const AssignTask& AssignTask::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AssignTask* AssignTask::default_instance_ = NULL;

AssignTask* AssignTask::New() const {
  return new AssignTask;
}

void AssignTask::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::RequestHeader::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AssignTask::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AssignTask::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AssignTask::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AssignTask::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AssignTask::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AssignTask* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AssignTask*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AssignTask::MergeFrom(const AssignTask& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AssignTask::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AssignTask::CopyFrom(const AssignTask& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssignTask::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void AssignTask::Swap(AssignTask* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AssignTask::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AssignTask_descriptor_;
  metadata.reflection = AssignTask_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AssignTaskResponse::kHeaderFieldNumber;
const int AssignTaskResponse::kTestsFieldNumber;
#endif  // !_MSC_VER

AssignTaskResponse::AssignTaskResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AssignTaskResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

AssignTaskResponse::AssignTaskResponse(const AssignTaskResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AssignTaskResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AssignTaskResponse::~AssignTaskResponse() {
  SharedDtor();
}

void AssignTaskResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void AssignTaskResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AssignTaskResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AssignTaskResponse_descriptor_;
}

const AssignTaskResponse& AssignTaskResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AssignTaskResponse* AssignTaskResponse::default_instance_ = NULL;

AssignTaskResponse* AssignTaskResponse::New() const {
  return new AssignTaskResponse;
}

void AssignTaskResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  tests_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AssignTaskResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tests;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.Test tests = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tests:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_tests()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tests;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AssignTaskResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  for (int i = 0; i < this->tests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->tests(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AssignTaskResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  for (int i = 0; i < this->tests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->tests(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AssignTaskResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  total_size += 1 * this->tests_size();
  for (int i = 0; i < this->tests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tests(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AssignTaskResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AssignTaskResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AssignTaskResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AssignTaskResponse::MergeFrom(const AssignTaskResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  tests_.MergeFrom(from.tests_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AssignTaskResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AssignTaskResponse::CopyFrom(const AssignTaskResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssignTaskResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < tests_size(); i++) {
    if (!this->tests(i).IsInitialized()) return false;
  }
  return true;
}

void AssignTaskResponse::Swap(AssignTaskResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    tests_.Swap(&other->tests_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AssignTaskResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AssignTaskResponse_descriptor_;
  metadata.reflection = AssignTaskResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpgradeToSuper::kHeaderFieldNumber;
#endif  // !_MSC_VER

UpgradeToSuper::UpgradeToSuper()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpgradeToSuper::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::RequestHeader*>(&::org::umit::icm::mobile::proto::RequestHeader::default_instance());
}

UpgradeToSuper::UpgradeToSuper(const UpgradeToSuper& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpgradeToSuper::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeToSuper::~UpgradeToSuper() {
  SharedDtor();
}

void UpgradeToSuper::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void UpgradeToSuper::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpgradeToSuper::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpgradeToSuper_descriptor_;
}

const UpgradeToSuper& UpgradeToSuper::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

UpgradeToSuper* UpgradeToSuper::default_instance_ = NULL;

UpgradeToSuper* UpgradeToSuper::New() const {
  return new UpgradeToSuper;
}

void UpgradeToSuper::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::RequestHeader::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpgradeToSuper::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpgradeToSuper::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpgradeToSuper::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpgradeToSuper::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeToSuper::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpgradeToSuper* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpgradeToSuper*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpgradeToSuper::MergeFrom(const UpgradeToSuper& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::RequestHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpgradeToSuper::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpgradeToSuper::CopyFrom(const UpgradeToSuper& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeToSuper::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void UpgradeToSuper::Swap(UpgradeToSuper* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpgradeToSuper::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpgradeToSuper_descriptor_;
  metadata.reflection = UpgradeToSuper_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int UpgradeToSuperResponse::kHeaderFieldNumber;
const int UpgradeToSuperResponse::kNewTokenFieldNumber;
const int UpgradeToSuperResponse::kNewPrivateKeyFieldNumber;
const int UpgradeToSuperResponse::kNewPublicKeyFieldNumber;
#endif  // !_MSC_VER

UpgradeToSuperResponse::UpgradeToSuperResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void UpgradeToSuperResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
  newprivatekey_ = const_cast< ::org::umit::icm::mobile::proto::RSAKey*>(&::org::umit::icm::mobile::proto::RSAKey::default_instance());
  newpublickey_ = const_cast< ::org::umit::icm::mobile::proto::RSAKey*>(&::org::umit::icm::mobile::proto::RSAKey::default_instance());
}

UpgradeToSuperResponse::UpgradeToSuperResponse(const UpgradeToSuperResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void UpgradeToSuperResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  newtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  newprivatekey_ = NULL;
  newpublickey_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeToSuperResponse::~UpgradeToSuperResponse() {
  SharedDtor();
}

void UpgradeToSuperResponse::SharedDtor() {
  if (newtoken_ != &::google::protobuf::internal::kEmptyString) {
    delete newtoken_;
  }
  if (this != default_instance_) {
    delete header_;
    delete newprivatekey_;
    delete newpublickey_;
  }
}

void UpgradeToSuperResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpgradeToSuperResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpgradeToSuperResponse_descriptor_;
}

const UpgradeToSuperResponse& UpgradeToSuperResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

UpgradeToSuperResponse* UpgradeToSuperResponse::default_instance_ = NULL;

UpgradeToSuperResponse* UpgradeToSuperResponse::New() const {
  return new UpgradeToSuperResponse;
}

void UpgradeToSuperResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
    if (has_newtoken()) {
      if (newtoken_ != &::google::protobuf::internal::kEmptyString) {
        newtoken_->clear();
      }
    }
    if (has_newprivatekey()) {
      if (newprivatekey_ != NULL) newprivatekey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
    }
    if (has_newpublickey()) {
      if (newpublickey_ != NULL) newpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpgradeToSuperResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_newToken;
        break;
      }
      
      // required string newToken = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newToken:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_newtoken()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->newtoken().data(), this->newtoken().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_newPrivateKey;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.RSAKey newPrivateKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newPrivateKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_newprivatekey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_newPublicKey;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.RSAKey newPublicKey = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_newPublicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_newpublickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpgradeToSuperResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // required string newToken = 2;
  if (has_newtoken()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->newtoken().data(), this->newtoken().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->newtoken(), output);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey newPrivateKey = 3;
  if (has_newprivatekey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->newprivatekey(), output);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey newPublicKey = 4;
  if (has_newpublickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->newpublickey(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* UpgradeToSuperResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // required string newToken = 2;
  if (has_newtoken()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->newtoken().data(), this->newtoken().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->newtoken(), target);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey newPrivateKey = 3;
  if (has_newprivatekey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->newprivatekey(), target);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey newPublicKey = 4;
  if (has_newpublickey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->newpublickey(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int UpgradeToSuperResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required string newToken = 2;
    if (has_newtoken()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->newtoken());
    }
    
    // required .org.umit.icm.mobile.proto.RSAKey newPrivateKey = 3;
    if (has_newprivatekey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->newprivatekey());
    }
    
    // required .org.umit.icm.mobile.proto.RSAKey newPublicKey = 4;
    if (has_newpublickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->newpublickey());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeToSuperResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpgradeToSuperResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpgradeToSuperResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpgradeToSuperResponse::MergeFrom(const UpgradeToSuperResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_newtoken()) {
      set_newtoken(from.newtoken());
    }
    if (from.has_newprivatekey()) {
      mutable_newprivatekey()->::org::umit::icm::mobile::proto::RSAKey::MergeFrom(from.newprivatekey());
    }
    if (from.has_newpublickey()) {
      mutable_newpublickey()->::org::umit::icm::mobile::proto::RSAKey::MergeFrom(from.newpublickey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpgradeToSuperResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpgradeToSuperResponse::CopyFrom(const UpgradeToSuperResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeToSuperResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  if (has_newprivatekey()) {
    if (!this->newprivatekey().IsInitialized()) return false;
  }
  if (has_newpublickey()) {
    if (!this->newpublickey().IsInitialized()) return false;
  }
  return true;
}

void UpgradeToSuperResponse::Swap(UpgradeToSuperResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(newtoken_, other->newtoken_);
    std::swap(newprivatekey_, other->newprivatekey_);
    std::swap(newpublickey_, other->newpublickey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpgradeToSuperResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpgradeToSuperResponse_descriptor_;
  metadata.reflection = UpgradeToSuperResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WebsiteSuggestion::kWebsiteURLFieldNumber;
#endif  // !_MSC_VER

WebsiteSuggestion::WebsiteSuggestion()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WebsiteSuggestion::InitAsDefaultInstance() {
}

WebsiteSuggestion::WebsiteSuggestion(const WebsiteSuggestion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WebsiteSuggestion::SharedCtor() {
  _cached_size_ = 0;
  websiteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WebsiteSuggestion::~WebsiteSuggestion() {
  SharedDtor();
}

void WebsiteSuggestion::SharedDtor() {
  if (websiteurl_ != &::google::protobuf::internal::kEmptyString) {
    delete websiteurl_;
  }
  if (this != default_instance_) {
  }
}

void WebsiteSuggestion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WebsiteSuggestion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WebsiteSuggestion_descriptor_;
}

const WebsiteSuggestion& WebsiteSuggestion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

WebsiteSuggestion* WebsiteSuggestion::default_instance_ = NULL;

WebsiteSuggestion* WebsiteSuggestion::New() const {
  return new WebsiteSuggestion;
}

void WebsiteSuggestion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_websiteurl()) {
      if (websiteurl_ != &::google::protobuf::internal::kEmptyString) {
        websiteurl_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WebsiteSuggestion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string websiteURL = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_websiteurl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->websiteurl().data(), this->websiteurl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WebsiteSuggestion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string websiteURL = 1;
  if (has_websiteurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->websiteurl().data(), this->websiteurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->websiteurl(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WebsiteSuggestion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string websiteURL = 1;
  if (has_websiteurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->websiteurl().data(), this->websiteurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->websiteurl(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WebsiteSuggestion::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string websiteURL = 1;
    if (has_websiteurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->websiteurl());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WebsiteSuggestion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WebsiteSuggestion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WebsiteSuggestion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WebsiteSuggestion::MergeFrom(const WebsiteSuggestion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_websiteurl()) {
      set_websiteurl(from.websiteurl());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WebsiteSuggestion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WebsiteSuggestion::CopyFrom(const WebsiteSuggestion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WebsiteSuggestion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void WebsiteSuggestion::Swap(WebsiteSuggestion* other) {
  if (other != this) {
    std::swap(websiteurl_, other->websiteurl_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WebsiteSuggestion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WebsiteSuggestion_descriptor_;
  metadata.reflection = WebsiteSuggestion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceSuggestion::kServiceNameFieldNumber;
const int ServiceSuggestion::kHostNameFieldNumber;
const int ServiceSuggestion::kIpFieldNumber;
const int ServiceSuggestion::kPortFieldNumber;
#endif  // !_MSC_VER

ServiceSuggestion::ServiceSuggestion()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ServiceSuggestion::InitAsDefaultInstance() {
}

ServiceSuggestion::ServiceSuggestion(const ServiceSuggestion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ServiceSuggestion::SharedCtor() {
  _cached_size_ = 0;
  servicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceSuggestion::~ServiceSuggestion() {
  SharedDtor();
}

void ServiceSuggestion::SharedDtor() {
  if (servicename_ != &::google::protobuf::internal::kEmptyString) {
    delete servicename_;
  }
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (this != default_instance_) {
  }
}

void ServiceSuggestion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServiceSuggestion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceSuggestion_descriptor_;
}

const ServiceSuggestion& ServiceSuggestion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ServiceSuggestion* ServiceSuggestion::default_instance_ = NULL;

ServiceSuggestion* ServiceSuggestion::New() const {
  return new ServiceSuggestion;
}

void ServiceSuggestion::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_servicename()) {
      if (servicename_ != &::google::protobuf::internal::kEmptyString) {
        servicename_->clear();
      }
    }
    if (has_hostname()) {
      if (hostname_ != &::google::protobuf::internal::kEmptyString) {
        hostname_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServiceSuggestion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string serviceName = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_servicename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->servicename().data(), this->servicename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hostName;
        break;
      }
      
      // required string hostName = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hostName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_ip;
        break;
      }
      
      // required string ip = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_port;
        break;
      }
      
      // required int64 port = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServiceSuggestion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string serviceName = 1;
  if (has_servicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servicename().data(), this->servicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->servicename(), output);
  }
  
  // required string hostName = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->hostname(), output);
  }
  
  // required string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->ip(), output);
  }
  
  // required int64 port = 4;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->port(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ServiceSuggestion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string serviceName = 1;
  if (has_servicename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->servicename().data(), this->servicename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->servicename(), target);
  }
  
  // required string hostName = 2;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->hostname(), target);
  }
  
  // required string ip = 3;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->ip(), target);
  }
  
  // required int64 port = 4;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->port(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ServiceSuggestion::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string serviceName = 1;
    if (has_servicename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->servicename());
    }
    
    // required string hostName = 2;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }
    
    // required string ip = 3;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }
    
    // required int64 port = 4;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->port());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceSuggestion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServiceSuggestion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServiceSuggestion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServiceSuggestion::MergeFrom(const ServiceSuggestion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_servicename()) {
      set_servicename(from.servicename());
    }
    if (from.has_hostname()) {
      set_hostname(from.hostname());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServiceSuggestion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServiceSuggestion::CopyFrom(const ServiceSuggestion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceSuggestion::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void ServiceSuggestion::Swap(ServiceSuggestion* other) {
  if (other != this) {
    std::swap(servicename_, other->servicename_);
    std::swap(hostname_, other->hostname_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServiceSuggestion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServiceSuggestion_descriptor_;
  metadata.reflection = ServiceSuggestion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TestSuggestionResponse::kHeaderFieldNumber;
#endif  // !_MSC_VER

TestSuggestionResponse::TestSuggestionResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TestSuggestionResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

TestSuggestionResponse::TestSuggestionResponse(const TestSuggestionResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TestSuggestionResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestSuggestionResponse::~TestSuggestionResponse() {
  SharedDtor();
}

void TestSuggestionResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void TestSuggestionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TestSuggestionResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TestSuggestionResponse_descriptor_;
}

const TestSuggestionResponse& TestSuggestionResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

TestSuggestionResponse* TestSuggestionResponse::default_instance_ = NULL;

TestSuggestionResponse* TestSuggestionResponse::New() const {
  return new TestSuggestionResponse;
}

void TestSuggestionResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TestSuggestionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TestSuggestionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TestSuggestionResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TestSuggestionResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestSuggestionResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TestSuggestionResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TestSuggestionResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TestSuggestionResponse::MergeFrom(const TestSuggestionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TestSuggestionResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TestSuggestionResponse::CopyFrom(const TestSuggestionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestSuggestionResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void TestSuggestionResponse::Swap(TestSuggestionResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TestSuggestionResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TestSuggestionResponse_descriptor_;
  metadata.reflection = TestSuggestionResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AuthenticatePeer::kAgentTypeFieldNumber;
const int AuthenticatePeer::kAgentIDFieldNumber;
const int AuthenticatePeer::kCipheredPublicKeyFieldNumber;
const int AuthenticatePeer::kAgentPortFieldNumber;
#endif  // !_MSC_VER

AuthenticatePeer::AuthenticatePeer()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AuthenticatePeer::InitAsDefaultInstance() {
  cipheredpublickey_ = const_cast< ::org::umit::icm::mobile::proto::RSAKey*>(&::org::umit::icm::mobile::proto::RSAKey::default_instance());
}

AuthenticatePeer::AuthenticatePeer(const AuthenticatePeer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AuthenticatePeer::SharedCtor() {
  _cached_size_ = 0;
  agenttype_ = 0;
  agentid_ = GOOGLE_LONGLONG(0);
  cipheredpublickey_ = NULL;
  agentport_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuthenticatePeer::~AuthenticatePeer() {
  SharedDtor();
}

void AuthenticatePeer::SharedDtor() {
  if (this != default_instance_) {
    delete cipheredpublickey_;
  }
}

void AuthenticatePeer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AuthenticatePeer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AuthenticatePeer_descriptor_;
}

const AuthenticatePeer& AuthenticatePeer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AuthenticatePeer* AuthenticatePeer::default_instance_ = NULL;

AuthenticatePeer* AuthenticatePeer::New() const {
  return new AuthenticatePeer;
}

void AuthenticatePeer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agenttype_ = 0;
    agentid_ = GOOGLE_LONGLONG(0);
    if (has_cipheredpublickey()) {
      if (cipheredpublickey_ != NULL) cipheredpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
    }
    agentport_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AuthenticatePeer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 agentType = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &agenttype_)));
          set_has_agenttype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_agentID;
        break;
      }
      
      // required int64 agentID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_agentID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &agentid_)));
          set_has_agentid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_cipheredPublicKey;
        break;
      }
      
      // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cipheredPublicKey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cipheredpublickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_agentPort;
        break;
      }
      
      // optional int32 agentPort = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_agentPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &agentport_)));
          set_has_agentport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuthenticatePeer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 agentType = 1;
  if (has_agenttype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->agenttype(), output);
  }
  
  // required int64 agentID = 2;
  if (has_agentid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->agentid(), output);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 3;
  if (has_cipheredpublickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->cipheredpublickey(), output);
  }
  
  // optional int32 agentPort = 4;
  if (has_agentport()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->agentport(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AuthenticatePeer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 agentType = 1;
  if (has_agenttype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->agenttype(), target);
  }
  
  // required int64 agentID = 2;
  if (has_agentid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->agentid(), target);
  }
  
  // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 3;
  if (has_cipheredpublickey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->cipheredpublickey(), target);
  }
  
  // optional int32 agentPort = 4;
  if (has_agentport()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->agentport(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AuthenticatePeer::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 agentType = 1;
    if (has_agenttype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->agenttype());
    }
    
    // required int64 agentID = 2;
    if (has_agentid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->agentid());
    }
    
    // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 3;
    if (has_cipheredpublickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cipheredpublickey());
    }
    
    // optional int32 agentPort = 4;
    if (has_agentport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->agentport());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuthenticatePeer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AuthenticatePeer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AuthenticatePeer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AuthenticatePeer::MergeFrom(const AuthenticatePeer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agenttype()) {
      set_agenttype(from.agenttype());
    }
    if (from.has_agentid()) {
      set_agentid(from.agentid());
    }
    if (from.has_cipheredpublickey()) {
      mutable_cipheredpublickey()->::org::umit::icm::mobile::proto::RSAKey::MergeFrom(from.cipheredpublickey());
    }
    if (from.has_agentport()) {
      set_agentport(from.agentport());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AuthenticatePeer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AuthenticatePeer::CopyFrom(const AuthenticatePeer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticatePeer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  if (has_cipheredpublickey()) {
    if (!this->cipheredpublickey().IsInitialized()) return false;
  }
  return true;
}

void AuthenticatePeer::Swap(AuthenticatePeer* other) {
  if (other != this) {
    std::swap(agenttype_, other->agenttype_);
    std::swap(agentid_, other->agentid_);
    std::swap(cipheredpublickey_, other->cipheredpublickey_);
    std::swap(agentport_, other->agentport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AuthenticatePeer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AuthenticatePeer_descriptor_;
  metadata.reflection = AuthenticatePeer_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AuthenticatePeerResponse::kCipheredPublicKeyFieldNumber;
const int AuthenticatePeerResponse::kTokenFieldNumber;
#endif  // !_MSC_VER

AuthenticatePeerResponse::AuthenticatePeerResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AuthenticatePeerResponse::InitAsDefaultInstance() {
  cipheredpublickey_ = const_cast< ::org::umit::icm::mobile::proto::RSAKey*>(&::org::umit::icm::mobile::proto::RSAKey::default_instance());
}

AuthenticatePeerResponse::AuthenticatePeerResponse(const AuthenticatePeerResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AuthenticatePeerResponse::SharedCtor() {
  _cached_size_ = 0;
  cipheredpublickey_ = NULL;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuthenticatePeerResponse::~AuthenticatePeerResponse() {
  SharedDtor();
}

void AuthenticatePeerResponse::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (this != default_instance_) {
    delete cipheredpublickey_;
  }
}

void AuthenticatePeerResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AuthenticatePeerResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AuthenticatePeerResponse_descriptor_;
}

const AuthenticatePeerResponse& AuthenticatePeerResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AuthenticatePeerResponse* AuthenticatePeerResponse::default_instance_ = NULL;

AuthenticatePeerResponse* AuthenticatePeerResponse::New() const {
  return new AuthenticatePeerResponse;
}

void AuthenticatePeerResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_cipheredpublickey()) {
      if (cipheredpublickey_ != NULL) cipheredpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
    }
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AuthenticatePeerResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cipheredpublickey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_token;
        break;
      }
      
      // required string token = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->token().data(), this->token().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuthenticatePeerResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 1;
  if (has_cipheredpublickey()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->cipheredpublickey(), output);
  }
  
  // required string token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->token(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AuthenticatePeerResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 1;
  if (has_cipheredpublickey()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->cipheredpublickey(), target);
  }
  
  // required string token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->token().data(), this->token().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->token(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AuthenticatePeerResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 1;
    if (has_cipheredpublickey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cipheredpublickey());
    }
    
    // required string token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuthenticatePeerResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AuthenticatePeerResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AuthenticatePeerResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AuthenticatePeerResponse::MergeFrom(const AuthenticatePeerResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cipheredpublickey()) {
      mutable_cipheredpublickey()->::org::umit::icm::mobile::proto::RSAKey::MergeFrom(from.cipheredpublickey());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AuthenticatePeerResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AuthenticatePeerResponse::CopyFrom(const AuthenticatePeerResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuthenticatePeerResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_cipheredpublickey()) {
    if (!this->cipheredpublickey().IsInitialized()) return false;
  }
  return true;
}

void AuthenticatePeerResponse::Swap(AuthenticatePeerResponse* other) {
  if (other != this) {
    std::swap(cipheredpublickey_, other->cipheredpublickey_);
    std::swap(token_, other->token_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AuthenticatePeerResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AuthenticatePeerResponse_descriptor_;
  metadata.reflection = AuthenticatePeerResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int P2PGetSuperPeerList::kCountFieldNumber;
#endif  // !_MSC_VER

P2PGetSuperPeerList::P2PGetSuperPeerList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void P2PGetSuperPeerList::InitAsDefaultInstance() {
}

P2PGetSuperPeerList::P2PGetSuperPeerList(const P2PGetSuperPeerList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void P2PGetSuperPeerList::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

P2PGetSuperPeerList::~P2PGetSuperPeerList() {
  SharedDtor();
}

void P2PGetSuperPeerList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void P2PGetSuperPeerList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* P2PGetSuperPeerList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return P2PGetSuperPeerList_descriptor_;
}

const P2PGetSuperPeerList& P2PGetSuperPeerList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

P2PGetSuperPeerList* P2PGetSuperPeerList::default_instance_ = NULL;

P2PGetSuperPeerList* P2PGetSuperPeerList::New() const {
  return new P2PGetSuperPeerList;
}

void P2PGetSuperPeerList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool P2PGetSuperPeerList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void P2PGetSuperPeerList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* P2PGetSuperPeerList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->count(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int P2PGetSuperPeerList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PGetSuperPeerList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const P2PGetSuperPeerList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const P2PGetSuperPeerList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void P2PGetSuperPeerList::MergeFrom(const P2PGetSuperPeerList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void P2PGetSuperPeerList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void P2PGetSuperPeerList::CopyFrom(const P2PGetSuperPeerList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PGetSuperPeerList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void P2PGetSuperPeerList::Swap(P2PGetSuperPeerList* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata P2PGetSuperPeerList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = P2PGetSuperPeerList_descriptor_;
  metadata.reflection = P2PGetSuperPeerList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int P2PGetSuperPeerListResponse::kPeersFieldNumber;
#endif  // !_MSC_VER

P2PGetSuperPeerListResponse::P2PGetSuperPeerListResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void P2PGetSuperPeerListResponse::InitAsDefaultInstance() {
}

P2PGetSuperPeerListResponse::P2PGetSuperPeerListResponse(const P2PGetSuperPeerListResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void P2PGetSuperPeerListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

P2PGetSuperPeerListResponse::~P2PGetSuperPeerListResponse() {
  SharedDtor();
}

void P2PGetSuperPeerListResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void P2PGetSuperPeerListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* P2PGetSuperPeerListResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return P2PGetSuperPeerListResponse_descriptor_;
}

const P2PGetSuperPeerListResponse& P2PGetSuperPeerListResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

P2PGetSuperPeerListResponse* P2PGetSuperPeerListResponse::default_instance_ = NULL;

P2PGetSuperPeerListResponse* P2PGetSuperPeerListResponse::New() const {
  return new P2PGetSuperPeerListResponse;
}

void P2PGetSuperPeerListResponse::Clear() {
  peers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool P2PGetSuperPeerListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_peers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_peers;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void P2PGetSuperPeerListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  for (int i = 0; i < this->peers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->peers(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* P2PGetSuperPeerListResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  for (int i = 0; i < this->peers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->peers(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int P2PGetSuperPeerListResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  total_size += 1 * this->peers_size();
  for (int i = 0; i < this->peers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->peers(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PGetSuperPeerListResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const P2PGetSuperPeerListResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const P2PGetSuperPeerListResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void P2PGetSuperPeerListResponse::MergeFrom(const P2PGetSuperPeerListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  peers_.MergeFrom(from.peers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void P2PGetSuperPeerListResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void P2PGetSuperPeerListResponse::CopyFrom(const P2PGetSuperPeerListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PGetSuperPeerListResponse::IsInitialized() const {
  
  for (int i = 0; i < peers_size(); i++) {
    if (!this->peers(i).IsInitialized()) return false;
  }
  return true;
}

void P2PGetSuperPeerListResponse::Swap(P2PGetSuperPeerListResponse* other) {
  if (other != this) {
    peers_.Swap(&other->peers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata P2PGetSuperPeerListResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = P2PGetSuperPeerListResponse_descriptor_;
  metadata.reflection = P2PGetSuperPeerListResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int P2PGetPeerList::kCountFieldNumber;
#endif  // !_MSC_VER

P2PGetPeerList::P2PGetPeerList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void P2PGetPeerList::InitAsDefaultInstance() {
}

P2PGetPeerList::P2PGetPeerList(const P2PGetPeerList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void P2PGetPeerList::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

P2PGetPeerList::~P2PGetPeerList() {
  SharedDtor();
}

void P2PGetPeerList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void P2PGetPeerList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* P2PGetPeerList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return P2PGetPeerList_descriptor_;
}

const P2PGetPeerList& P2PGetPeerList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

P2PGetPeerList* P2PGetPeerList::default_instance_ = NULL;

P2PGetPeerList* P2PGetPeerList::New() const {
  return new P2PGetPeerList;
}

void P2PGetPeerList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool P2PGetPeerList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void P2PGetPeerList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* P2PGetPeerList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->count(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int P2PGetPeerList::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PGetPeerList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const P2PGetPeerList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const P2PGetPeerList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void P2PGetPeerList::MergeFrom(const P2PGetPeerList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void P2PGetPeerList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void P2PGetPeerList::CopyFrom(const P2PGetPeerList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PGetPeerList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void P2PGetPeerList::Swap(P2PGetPeerList* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata P2PGetPeerList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = P2PGetPeerList_descriptor_;
  metadata.reflection = P2PGetPeerList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int P2PGetPeerListResponse::kPeersFieldNumber;
#endif  // !_MSC_VER

P2PGetPeerListResponse::P2PGetPeerListResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void P2PGetPeerListResponse::InitAsDefaultInstance() {
}

P2PGetPeerListResponse::P2PGetPeerListResponse(const P2PGetPeerListResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void P2PGetPeerListResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

P2PGetPeerListResponse::~P2PGetPeerListResponse() {
  SharedDtor();
}

void P2PGetPeerListResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void P2PGetPeerListResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* P2PGetPeerListResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return P2PGetPeerListResponse_descriptor_;
}

const P2PGetPeerListResponse& P2PGetPeerListResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

P2PGetPeerListResponse* P2PGetPeerListResponse::default_instance_ = NULL;

P2PGetPeerListResponse* P2PGetPeerListResponse::New() const {
  return new P2PGetPeerListResponse;
}

void P2PGetPeerListResponse::Clear() {
  peers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool P2PGetPeerListResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_peers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_peers()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_peers;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void P2PGetPeerListResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  for (int i = 0; i < this->peers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->peers(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* P2PGetPeerListResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  for (int i = 0; i < this->peers_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->peers(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int P2PGetPeerListResponse::ByteSize() const {
  int total_size = 0;
  
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  total_size += 1 * this->peers_size();
  for (int i = 0; i < this->peers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->peers(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void P2PGetPeerListResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const P2PGetPeerListResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const P2PGetPeerListResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void P2PGetPeerListResponse::MergeFrom(const P2PGetPeerListResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  peers_.MergeFrom(from.peers_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void P2PGetPeerListResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void P2PGetPeerListResponse::CopyFrom(const P2PGetPeerListResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool P2PGetPeerListResponse::IsInitialized() const {
  
  for (int i = 0; i < peers_size(); i++) {
    if (!this->peers(i).IsInitialized()) return false;
  }
  return true;
}

void P2PGetPeerListResponse::Swap(P2PGetPeerListResponse* other) {
  if (other != this) {
    peers_.Swap(&other->peers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata P2PGetPeerListResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = P2PGetPeerListResponse_descriptor_;
  metadata.reflection = P2PGetPeerListResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AgentUpdate::kVersionFieldNumber;
const int AgentUpdate::kDownloadURLFieldNumber;
const int AgentUpdate::kCheckCodeFieldNumber;
#endif  // !_MSC_VER

AgentUpdate::AgentUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AgentUpdate::InitAsDefaultInstance() {
}

AgentUpdate::AgentUpdate(const AgentUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AgentUpdate::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checkcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AgentUpdate::~AgentUpdate() {
  SharedDtor();
}

void AgentUpdate::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (this != default_instance_) {
  }
}

void AgentUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AgentUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AgentUpdate_descriptor_;
}

const AgentUpdate& AgentUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AgentUpdate* AgentUpdate::default_instance_ = NULL;

AgentUpdate* AgentUpdate::New() const {
  return new AgentUpdate;
}

void AgentUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_downloadurl()) {
      if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
        downloadurl_->clear();
      }
    }
    checkcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AgentUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_downloadURL;
        break;
      }
      
      // required string downloadURL = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_downloadURL:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_downloadurl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->downloadurl().data(), this->downloadurl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_checkCode;
        break;
      }
      
      // optional int32 checkCode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checkCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checkcode_)));
          set_has_checkcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AgentUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }
  
  // required string downloadURL = 2;
  if (has_downloadurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->downloadurl().data(), this->downloadurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->downloadurl(), output);
  }
  
  // optional int32 checkCode = 3;
  if (has_checkcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->checkcode(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AgentUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }
  
  // required string downloadURL = 2;
  if (has_downloadurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->downloadurl().data(), this->downloadurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->downloadurl(), target);
  }
  
  // optional int32 checkCode = 3;
  if (has_checkcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->checkcode(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AgentUpdate::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // required string downloadURL = 2;
    if (has_downloadurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->downloadurl());
    }
    
    // optional int32 checkCode = 3;
    if (has_checkcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checkcode());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AgentUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AgentUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AgentUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AgentUpdate::MergeFrom(const AgentUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_downloadurl()) {
      set_downloadurl(from.downloadurl());
    }
    if (from.has_checkcode()) {
      set_checkcode(from.checkcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AgentUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AgentUpdate::CopyFrom(const AgentUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgentUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AgentUpdate::Swap(AgentUpdate* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(downloadurl_, other->downloadurl_);
    std::swap(checkcode_, other->checkcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AgentUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AgentUpdate_descriptor_;
  metadata.reflection = AgentUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AgentUpdateResponse::kVersionFieldNumber;
const int AgentUpdateResponse::kResultFieldNumber;
#endif  // !_MSC_VER

AgentUpdateResponse::AgentUpdateResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AgentUpdateResponse::InitAsDefaultInstance() {
}

AgentUpdateResponse::AgentUpdateResponse(const AgentUpdateResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AgentUpdateResponse::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AgentUpdateResponse::~AgentUpdateResponse() {
  SharedDtor();
}

void AgentUpdateResponse::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    delete result_;
  }
  if (this != default_instance_) {
  }
}

void AgentUpdateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AgentUpdateResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AgentUpdateResponse_descriptor_;
}

const AgentUpdateResponse& AgentUpdateResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

AgentUpdateResponse* AgentUpdateResponse::default_instance_ = NULL;

AgentUpdateResponse* AgentUpdateResponse::New() const {
  return new AgentUpdateResponse;
}

void AgentUpdateResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_result()) {
      if (result_ != &::google::protobuf::internal::kEmptyString) {
        result_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AgentUpdateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_result;
        break;
      }
      
      // required string result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_result()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->result().data(), this->result().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AgentUpdateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }
  
  // required string result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->result().data(), this->result().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->result(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AgentUpdateResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }
  
  // required string result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->result().data(), this->result().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->result(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AgentUpdateResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // required string result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->result());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AgentUpdateResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AgentUpdateResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AgentUpdateResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AgentUpdateResponse::MergeFrom(const AgentUpdateResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AgentUpdateResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AgentUpdateResponse::CopyFrom(const AgentUpdateResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgentUpdateResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void AgentUpdateResponse::Swap(AgentUpdateResponse* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AgentUpdateResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AgentUpdateResponse_descriptor_;
  metadata.reflection = AgentUpdateResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TestModuleUpdate::kVersionFieldNumber;
const int TestModuleUpdate::kDownloadURLFieldNumber;
const int TestModuleUpdate::kCheckCodeFieldNumber;
#endif  // !_MSC_VER

TestModuleUpdate::TestModuleUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TestModuleUpdate::InitAsDefaultInstance() {
}

TestModuleUpdate::TestModuleUpdate(const TestModuleUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TestModuleUpdate::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  checkcode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestModuleUpdate::~TestModuleUpdate() {
  SharedDtor();
}

void TestModuleUpdate::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (this != default_instance_) {
  }
}

void TestModuleUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TestModuleUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TestModuleUpdate_descriptor_;
}

const TestModuleUpdate& TestModuleUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

TestModuleUpdate* TestModuleUpdate::default_instance_ = NULL;

TestModuleUpdate* TestModuleUpdate::New() const {
  return new TestModuleUpdate;
}

void TestModuleUpdate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_downloadurl()) {
      if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
        downloadurl_->clear();
      }
    }
    checkcode_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TestModuleUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_downloadURL;
        break;
      }
      
      // required string downloadURL = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_downloadURL:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_downloadurl()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->downloadurl().data(), this->downloadurl().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_checkCode;
        break;
      }
      
      // optional int32 checkCode = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_checkCode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &checkcode_)));
          set_has_checkcode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TestModuleUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }
  
  // required string downloadURL = 2;
  if (has_downloadurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->downloadurl().data(), this->downloadurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->downloadurl(), output);
  }
  
  // optional int32 checkCode = 3;
  if (has_checkcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->checkcode(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TestModuleUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }
  
  // required string downloadURL = 2;
  if (has_downloadurl()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->downloadurl().data(), this->downloadurl().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->downloadurl(), target);
  }
  
  // optional int32 checkCode = 3;
  if (has_checkcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->checkcode(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TestModuleUpdate::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // required string downloadURL = 2;
    if (has_downloadurl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->downloadurl());
    }
    
    // optional int32 checkCode = 3;
    if (has_checkcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->checkcode());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestModuleUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TestModuleUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TestModuleUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TestModuleUpdate::MergeFrom(const TestModuleUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_downloadurl()) {
      set_downloadurl(from.downloadurl());
    }
    if (from.has_checkcode()) {
      set_checkcode(from.checkcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TestModuleUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TestModuleUpdate::CopyFrom(const TestModuleUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestModuleUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void TestModuleUpdate::Swap(TestModuleUpdate* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(downloadurl_, other->downloadurl_);
    std::swap(checkcode_, other->checkcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TestModuleUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TestModuleUpdate_descriptor_;
  metadata.reflection = TestModuleUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TestModuleUpdateResponse::kVersionFieldNumber;
const int TestModuleUpdateResponse::kResultFieldNumber;
#endif  // !_MSC_VER

TestModuleUpdateResponse::TestModuleUpdateResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TestModuleUpdateResponse::InitAsDefaultInstance() {
}

TestModuleUpdateResponse::TestModuleUpdateResponse(const TestModuleUpdateResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TestModuleUpdateResponse::SharedCtor() {
  _cached_size_ = 0;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestModuleUpdateResponse::~TestModuleUpdateResponse() {
  SharedDtor();
}

void TestModuleUpdateResponse::SharedDtor() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    delete result_;
  }
  if (this != default_instance_) {
  }
}

void TestModuleUpdateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TestModuleUpdateResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TestModuleUpdateResponse_descriptor_;
}

const TestModuleUpdateResponse& TestModuleUpdateResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

TestModuleUpdateResponse* TestModuleUpdateResponse::default_instance_ = NULL;

TestModuleUpdateResponse* TestModuleUpdateResponse::New() const {
  return new TestModuleUpdateResponse;
}

void TestModuleUpdateResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::kEmptyString) {
        version_->clear();
      }
    }
    if (has_result()) {
      if (result_ != &::google::protobuf::internal::kEmptyString) {
        result_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TestModuleUpdateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_result;
        break;
      }
      
      // required string result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_result()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->result().data(), this->result().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TestModuleUpdateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->version(), output);
  }
  
  // required string result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->result().data(), this->result().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->result(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TestModuleUpdateResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }
  
  // required string result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->result().data(), this->result().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->result(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TestModuleUpdateResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }
    
    // required string result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->result());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestModuleUpdateResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TestModuleUpdateResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TestModuleUpdateResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TestModuleUpdateResponse::MergeFrom(const TestModuleUpdateResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TestModuleUpdateResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TestModuleUpdateResponse::CopyFrom(const TestModuleUpdateResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestModuleUpdateResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void TestModuleUpdateResponse::Swap(TestModuleUpdateResponse* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TestModuleUpdateResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TestModuleUpdateResponse_descriptor_;
  metadata.reflection = TestModuleUpdateResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ForwardingMessage::kDestinationFieldNumber;
const int ForwardingMessage::kIdentifierFieldNumber;
const int ForwardingMessage::kEncodedMessageFieldNumber;
#endif  // !_MSC_VER

ForwardingMessage::ForwardingMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ForwardingMessage::InitAsDefaultInstance() {
}

ForwardingMessage::ForwardingMessage(const ForwardingMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ForwardingMessage::SharedCtor() {
  _cached_size_ = 0;
  destination_ = GOOGLE_LONGLONG(0);
  identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encodedmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ForwardingMessage::~ForwardingMessage() {
  SharedDtor();
}

void ForwardingMessage::SharedDtor() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_;
  }
  if (encodedmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete encodedmessage_;
  }
  if (this != default_instance_) {
  }
}

void ForwardingMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ForwardingMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ForwardingMessage_descriptor_;
}

const ForwardingMessage& ForwardingMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ForwardingMessage* ForwardingMessage::default_instance_ = NULL;

ForwardingMessage* ForwardingMessage::New() const {
  return new ForwardingMessage;
}

void ForwardingMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    destination_ = GOOGLE_LONGLONG(0);
    if (has_identifier()) {
      if (identifier_ != &::google::protobuf::internal::kEmptyString) {
        identifier_->clear();
      }
    }
    if (has_encodedmessage()) {
      if (encodedmessage_ != &::google::protobuf::internal::kEmptyString) {
        encodedmessage_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ForwardingMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 destination = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &destination_)));
          set_has_destination();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_identifier;
        break;
      }
      
      // required string identifier = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_identifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_identifier()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->identifier().data(), this->identifier().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_encodedMessage;
        break;
      }
      
      // required string encodedMessage = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encodedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_encodedmessage()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->encodedmessage().data(), this->encodedmessage().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ForwardingMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 destination = 1;
  if (has_destination()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->destination(), output);
  }
  
  // required string identifier = 2;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identifier().data(), this->identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->identifier(), output);
  }
  
  // required string encodedMessage = 3;
  if (has_encodedmessage()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encodedmessage().data(), this->encodedmessage().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->encodedmessage(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ForwardingMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int64 destination = 1;
  if (has_destination()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->destination(), target);
  }
  
  // required string identifier = 2;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identifier().data(), this->identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->identifier(), target);
  }
  
  // required string encodedMessage = 3;
  if (has_encodedmessage()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encodedmessage().data(), this->encodedmessage().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->encodedmessage(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ForwardingMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 destination = 1;
    if (has_destination()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->destination());
    }
    
    // required string identifier = 2;
    if (has_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->identifier());
    }
    
    // required string encodedMessage = 3;
    if (has_encodedmessage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encodedmessage());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ForwardingMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ForwardingMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ForwardingMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ForwardingMessage::MergeFrom(const ForwardingMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_destination()) {
      set_destination(from.destination());
    }
    if (from.has_identifier()) {
      set_identifier(from.identifier());
    }
    if (from.has_encodedmessage()) {
      set_encodedmessage(from.encodedmessage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ForwardingMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ForwardingMessage::CopyFrom(const ForwardingMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForwardingMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

void ForwardingMessage::Swap(ForwardingMessage* other) {
  if (other != this) {
    std::swap(destination_, other->destination_);
    std::swap(identifier_, other->identifier_);
    std::swap(encodedmessage_, other->encodedmessage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ForwardingMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ForwardingMessage_descriptor_;
  metadata.reflection = ForwardingMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ForwardingMessageResponse::kIdentifierFieldNumber;
const int ForwardingMessageResponse::kEncodedMessageFieldNumber;
#endif  // !_MSC_VER

ForwardingMessageResponse::ForwardingMessageResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ForwardingMessageResponse::InitAsDefaultInstance() {
}

ForwardingMessageResponse::ForwardingMessageResponse(const ForwardingMessageResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ForwardingMessageResponse::SharedCtor() {
  _cached_size_ = 0;
  identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encodedmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ForwardingMessageResponse::~ForwardingMessageResponse() {
  SharedDtor();
}

void ForwardingMessageResponse::SharedDtor() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    delete identifier_;
  }
  if (encodedmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete encodedmessage_;
  }
  if (this != default_instance_) {
  }
}

void ForwardingMessageResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ForwardingMessageResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ForwardingMessageResponse_descriptor_;
}

const ForwardingMessageResponse& ForwardingMessageResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

ForwardingMessageResponse* ForwardingMessageResponse::default_instance_ = NULL;

ForwardingMessageResponse* ForwardingMessageResponse::New() const {
  return new ForwardingMessageResponse;
}

void ForwardingMessageResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_identifier()) {
      if (identifier_ != &::google::protobuf::internal::kEmptyString) {
        identifier_->clear();
      }
    }
    if (has_encodedmessage()) {
      if (encodedmessage_ != &::google::protobuf::internal::kEmptyString) {
        encodedmessage_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ForwardingMessageResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string identifier = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_identifier()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->identifier().data(), this->identifier().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_encodedMessage;
        break;
      }
      
      // required string encodedMessage = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_encodedMessage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_encodedmessage()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->encodedmessage().data(), this->encodedmessage().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ForwardingMessageResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string identifier = 1;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identifier().data(), this->identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->identifier(), output);
  }
  
  // required string encodedMessage = 2;
  if (has_encodedmessage()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encodedmessage().data(), this->encodedmessage().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->encodedmessage(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ForwardingMessageResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string identifier = 1;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->identifier().data(), this->identifier().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->identifier(), target);
  }
  
  // required string encodedMessage = 2;
  if (has_encodedmessage()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encodedmessage().data(), this->encodedmessage().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->encodedmessage(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ForwardingMessageResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string identifier = 1;
    if (has_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->identifier());
    }
    
    // required string encodedMessage = 2;
    if (has_encodedmessage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encodedmessage());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ForwardingMessageResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ForwardingMessageResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ForwardingMessageResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ForwardingMessageResponse::MergeFrom(const ForwardingMessageResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_identifier()) {
      set_identifier(from.identifier());
    }
    if (from.has_encodedmessage()) {
      set_encodedmessage(from.encodedmessage());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ForwardingMessageResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ForwardingMessageResponse::CopyFrom(const ForwardingMessageResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForwardingMessageResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void ForwardingMessageResponse::Swap(ForwardingMessageResponse* other) {
  if (other != this) {
    std::swap(identifier_, other->identifier_);
    std::swap(encodedmessage_, other->encodedmessage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ForwardingMessageResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ForwardingMessageResponse_descriptor_;
  metadata.reflection = ForwardingMessageResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginCredentials::kUsernameFieldNumber;
const int LoginCredentials::kPasswordFieldNumber;
#endif  // !_MSC_VER

LoginCredentials::LoginCredentials()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoginCredentials::InitAsDefaultInstance() {
}

LoginCredentials::LoginCredentials(const LoginCredentials& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoginCredentials::SharedCtor() {
  _cached_size_ = 0;
  username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginCredentials::~LoginCredentials() {
  SharedDtor();
}

void LoginCredentials::SharedDtor() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (this != default_instance_) {
  }
}

void LoginCredentials::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginCredentials::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginCredentials_descriptor_;
}

const LoginCredentials& LoginCredentials::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

LoginCredentials* LoginCredentials::default_instance_ = NULL;

LoginCredentials* LoginCredentials::New() const {
  return new LoginCredentials;
}

void LoginCredentials::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_username()) {
      if (username_ != &::google::protobuf::internal::kEmptyString) {
        username_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginCredentials::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string username = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_username()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->username().data(), this->username().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }
      
      // required string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->password().data(), this->password().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginCredentials::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->username(), output);
  }
  
  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoginCredentials::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string username = 1;
  if (has_username()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->username().data(), this->username().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->username(), target);
  }
  
  // required string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password().data(), this->password().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->password(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoginCredentials::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string username = 1;
    if (has_username()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->username());
    }
    
    // required string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginCredentials::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginCredentials* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginCredentials*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginCredentials::MergeFrom(const LoginCredentials& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_username()) {
      set_username(from.username());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginCredentials::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginCredentials::CopyFrom(const LoginCredentials& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginCredentials::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void LoginCredentials::Swap(LoginCredentials* other) {
  if (other != this) {
    std::swap(username_, other->username_);
    std::swap(password_, other->password_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginCredentials::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginCredentials_descriptor_;
  metadata.reflection = LoginCredentials_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetNetlist::kListFieldNumber;
#endif  // !_MSC_VER

GetNetlist::GetNetlist()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetNetlist::InitAsDefaultInstance() {
}

GetNetlist::GetNetlist(const GetNetlist& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetNetlist::SharedCtor() {
  _cached_size_ = 0;
  list_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetNetlist::~GetNetlist() {
  SharedDtor();
}

void GetNetlist::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetNetlist::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetNetlist::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetNetlist_descriptor_;
}

const GetNetlist& GetNetlist::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetNetlist* GetNetlist::default_instance_ = NULL;

GetNetlist* GetNetlist::New() const {
  return new GetNetlist;
}

void GetNetlist::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    list_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetNetlist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &list_)));
          set_has_list();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetNetlist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 list = 1;
  if (has_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->list(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetNetlist::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 list = 1;
  if (has_list()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->list(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetNetlist::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 list = 1;
    if (has_list()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->list());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetNetlist::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetNetlist* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetNetlist*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetNetlist::MergeFrom(const GetNetlist& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_list()) {
      set_list(from.list());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetNetlist::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetNetlist::CopyFrom(const GetNetlist& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNetlist::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetNetlist::Swap(GetNetlist* other) {
  if (other != this) {
    std::swap(list_, other->list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetNetlist::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetNetlist_descriptor_;
  metadata.reflection = GetNetlist_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int NetworkData::kStartIpFieldNumber;
const int NetworkData::kEndIpFieldNumber;
const int NetworkData::kNodesCountNetworkFieldNumber;
const int NetworkData::kNodesFieldNumber;
#endif  // !_MSC_VER

NetworkData::NetworkData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NetworkData::InitAsDefaultInstance() {
}

NetworkData::NetworkData(const NetworkData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NetworkData::SharedCtor() {
  _cached_size_ = 0;
  start_ip_ = 0;
  end_ip_ = 0;
  nodes_count_network_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkData::~NetworkData() {
  SharedDtor();
}

void NetworkData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NetworkData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkData_descriptor_;
}

const NetworkData& NetworkData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

NetworkData* NetworkData::default_instance_ = NULL;

NetworkData* NetworkData::New() const {
  return new NetworkData;
}

void NetworkData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_ip_ = 0;
    end_ip_ = 0;
    nodes_count_network_ = 0;
  }
  nodes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetworkData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 start_ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_ip_)));
          set_has_start_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_end_ip;
        break;
      }
      
      // required int32 end_ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_ip_)));
          set_has_end_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nodes_count_network;
        break;
      }
      
      // optional int32 nodes_count_network = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nodes_count_network:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nodes_count_network_)));
          set_has_nodes_count_network();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nodes;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.AgentData nodes = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_nodes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodes()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_nodes;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NetworkData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 start_ip = 1;
  if (has_start_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start_ip(), output);
  }
  
  // required int32 end_ip = 2;
  if (has_end_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->end_ip(), output);
  }
  
  // optional int32 nodes_count_network = 3;
  if (has_nodes_count_network()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->nodes_count_network(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.AgentData nodes = 4;
  for (int i = 0; i < this->nodes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->nodes(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NetworkData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 start_ip = 1;
  if (has_start_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->start_ip(), target);
  }
  
  // required int32 end_ip = 2;
  if (has_end_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->end_ip(), target);
  }
  
  // optional int32 nodes_count_network = 3;
  if (has_nodes_count_network()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->nodes_count_network(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.AgentData nodes = 4;
  for (int i = 0; i < this->nodes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->nodes(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NetworkData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 start_ip = 1;
    if (has_start_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_ip());
    }
    
    // required int32 end_ip = 2;
    if (has_end_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_ip());
    }
    
    // optional int32 nodes_count_network = 3;
    if (has_nodes_count_network()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nodes_count_network());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.AgentData nodes = 4;
  total_size += 1 * this->nodes_size();
  for (int i = 0; i < this->nodes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodes(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetworkData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetworkData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetworkData::MergeFrom(const NetworkData& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodes_.MergeFrom(from.nodes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_ip()) {
      set_start_ip(from.start_ip());
    }
    if (from.has_end_ip()) {
      set_end_ip(from.end_ip());
    }
    if (from.has_nodes_count_network()) {
      set_nodes_count_network(from.nodes_count_network());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetworkData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkData::CopyFrom(const NetworkData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < nodes_size(); i++) {
    if (!this->nodes(i).IsInitialized()) return false;
  }
  return true;
}

void NetworkData::Swap(NetworkData* other) {
  if (other != this) {
    std::swap(start_ip_, other->start_ip_);
    std::swap(end_ip_, other->end_ip_);
    std::swap(nodes_count_network_, other->nodes_count_network_);
    nodes_.Swap(&other->nodes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetworkData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkData_descriptor_;
  metadata.reflection = NetworkData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BannedNetworkData::kStartIpFieldNumber;
const int BannedNetworkData::kEndIpFieldNumber;
const int BannedNetworkData::kNodesCountFieldNumber;
const int BannedNetworkData::kFlagsFieldNumber;
#endif  // !_MSC_VER

BannedNetworkData::BannedNetworkData()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void BannedNetworkData::InitAsDefaultInstance() {
}

BannedNetworkData::BannedNetworkData(const BannedNetworkData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void BannedNetworkData::SharedCtor() {
  _cached_size_ = 0;
  start_ip_ = 0;
  end_ip_ = 0;
  nodes_count_ = 0;
  flags_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BannedNetworkData::~BannedNetworkData() {
  SharedDtor();
}

void BannedNetworkData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BannedNetworkData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BannedNetworkData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BannedNetworkData_descriptor_;
}

const BannedNetworkData& BannedNetworkData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

BannedNetworkData* BannedNetworkData::default_instance_ = NULL;

BannedNetworkData* BannedNetworkData::New() const {
  return new BannedNetworkData;
}

void BannedNetworkData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    start_ip_ = 0;
    end_ip_ = 0;
    nodes_count_ = 0;
    flags_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BannedNetworkData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 start_ip = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_ip_)));
          set_has_start_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_end_ip;
        break;
      }
      
      // required int32 end_ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_ip_)));
          set_has_end_ip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_nodes_count;
        break;
      }
      
      // optional int32 nodes_count = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nodes_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nodes_count_)));
          set_has_nodes_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_flags;
        break;
      }
      
      // required int32 flags = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BannedNetworkData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 start_ip = 1;
  if (has_start_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start_ip(), output);
  }
  
  // required int32 end_ip = 2;
  if (has_end_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->end_ip(), output);
  }
  
  // optional int32 nodes_count = 3;
  if (has_nodes_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->nodes_count(), output);
  }
  
  // required int32 flags = 4;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->flags(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* BannedNetworkData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 start_ip = 1;
  if (has_start_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->start_ip(), target);
  }
  
  // required int32 end_ip = 2;
  if (has_end_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->end_ip(), target);
  }
  
  // optional int32 nodes_count = 3;
  if (has_nodes_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->nodes_count(), target);
  }
  
  // required int32 flags = 4;
  if (has_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->flags(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int BannedNetworkData::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 start_ip = 1;
    if (has_start_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start_ip());
    }
    
    // required int32 end_ip = 2;
    if (has_end_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_ip());
    }
    
    // optional int32 nodes_count = 3;
    if (has_nodes_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nodes_count());
    }
    
    // required int32 flags = 4;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->flags());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BannedNetworkData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BannedNetworkData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BannedNetworkData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BannedNetworkData::MergeFrom(const BannedNetworkData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start_ip()) {
      set_start_ip(from.start_ip());
    }
    if (from.has_end_ip()) {
      set_end_ip(from.end_ip());
    }
    if (from.has_nodes_count()) {
      set_nodes_count(from.nodes_count());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BannedNetworkData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BannedNetworkData::CopyFrom(const BannedNetworkData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BannedNetworkData::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000b) != 0x0000000b) return false;
  
  return true;
}

void BannedNetworkData::Swap(BannedNetworkData* other) {
  if (other != this) {
    std::swap(start_ip_, other->start_ip_);
    std::swap(end_ip_, other->end_ip_);
    std::swap(nodes_count_, other->nodes_count_);
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BannedNetworkData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BannedNetworkData_descriptor_;
  metadata.reflection = BannedNetworkData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetNetlistResponse::kHeaderFieldNumber;
const int GetNetlistResponse::kNetworksFieldNumber;
#endif  // !_MSC_VER

GetNetlistResponse::GetNetlistResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetNetlistResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

GetNetlistResponse::GetNetlistResponse(const GetNetlistResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetNetlistResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetNetlistResponse::~GetNetlistResponse() {
  SharedDtor();
}

void GetNetlistResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetNetlistResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetNetlistResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetNetlistResponse_descriptor_;
}

const GetNetlistResponse& GetNetlistResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetNetlistResponse* GetNetlistResponse::default_instance_ = NULL;

GetNetlistResponse* GetNetlistResponse::New() const {
  return new GetNetlistResponse;
}

void GetNetlistResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  networks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetNetlistResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_networks;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.NetworkData networks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_networks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_networks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_networks;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetNetlistResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.NetworkData networks = 2;
  for (int i = 0; i < this->networks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->networks(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetNetlistResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.NetworkData networks = 2;
  for (int i = 0; i < this->networks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->networks(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetNetlistResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.NetworkData networks = 2;
  total_size += 1 * this->networks_size();
  for (int i = 0; i < this->networks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->networks(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetNetlistResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetNetlistResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetNetlistResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetNetlistResponse::MergeFrom(const GetNetlistResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  networks_.MergeFrom(from.networks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetNetlistResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetNetlistResponse::CopyFrom(const GetNetlistResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetNetlistResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < networks_size(); i++) {
    if (!this->networks(i).IsInitialized()) return false;
  }
  return true;
}

void GetNetlistResponse::Swap(GetNetlistResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    networks_.Swap(&other->networks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetNetlistResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetNetlistResponse_descriptor_;
  metadata.reflection = GetNetlistResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetBanlist::kCountFieldNumber;
#endif  // !_MSC_VER

GetBanlist::GetBanlist()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetBanlist::InitAsDefaultInstance() {
}

GetBanlist::GetBanlist(const GetBanlist& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetBanlist::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetBanlist::~GetBanlist() {
  SharedDtor();
}

void GetBanlist::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetBanlist::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetBanlist::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetBanlist_descriptor_;
}

const GetBanlist& GetBanlist::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetBanlist* GetBanlist::default_instance_ = NULL;

GetBanlist* GetBanlist::New() const {
  return new GetBanlist;
}

void GetBanlist::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetBanlist::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetBanlist::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetBanlist::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->count(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetBanlist::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetBanlist::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetBanlist* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetBanlist*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetBanlist::MergeFrom(const GetBanlist& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetBanlist::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetBanlist::CopyFrom(const GetBanlist& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBanlist::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetBanlist::Swap(GetBanlist* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetBanlist::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetBanlist_descriptor_;
  metadata.reflection = GetBanlist_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetBanlistResponse::kHeaderFieldNumber;
const int GetBanlistResponse::kNodesCountFieldNumber;
const int GetBanlistResponse::kAgentIdsFieldNumber;
#endif  // !_MSC_VER

GetBanlistResponse::GetBanlistResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetBanlistResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

GetBanlistResponse::GetBanlistResponse(const GetBanlistResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetBanlistResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  nodes_count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetBanlistResponse::~GetBanlistResponse() {
  SharedDtor();
}

void GetBanlistResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetBanlistResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetBanlistResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetBanlistResponse_descriptor_;
}

const GetBanlistResponse& GetBanlistResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetBanlistResponse* GetBanlistResponse::default_instance_ = NULL;

GetBanlistResponse* GetBanlistResponse::New() const {
  return new GetBanlistResponse;
}

void GetBanlistResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
    nodes_count_ = 0;
  }
  agent_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetBanlistResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_nodes_count;
        break;
      }
      
      // required int32 nodes_count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nodes_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nodes_count_)));
          set_has_nodes_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_agent_ids;
        break;
      }
      
      // repeated int32 agent_ids = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_agent_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 24, input, this->mutable_agent_ids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_agent_ids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_agent_ids;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetBanlistResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // required int32 nodes_count = 2;
  if (has_nodes_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nodes_count(), output);
  }
  
  // repeated int32 agent_ids = 3;
  for (int i = 0; i < this->agent_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      3, this->agent_ids(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetBanlistResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // required int32 nodes_count = 2;
  if (has_nodes_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nodes_count(), target);
  }
  
  // repeated int32 agent_ids = 3;
  for (int i = 0; i < this->agent_ids_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(3, this->agent_ids(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetBanlistResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
    // required int32 nodes_count = 2;
    if (has_nodes_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nodes_count());
    }
    
  }
  // repeated int32 agent_ids = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->agent_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->agent_ids(i));
    }
    total_size += 1 * this->agent_ids_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetBanlistResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetBanlistResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetBanlistResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetBanlistResponse::MergeFrom(const GetBanlistResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  agent_ids_.MergeFrom(from.agent_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
    if (from.has_nodes_count()) {
      set_nodes_count(from.nodes_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetBanlistResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetBanlistResponse::CopyFrom(const GetBanlistResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBanlistResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  return true;
}

void GetBanlistResponse::Swap(GetBanlistResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    std::swap(nodes_count_, other->nodes_count_);
    agent_ids_.Swap(&other->agent_ids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetBanlistResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetBanlistResponse_descriptor_;
  metadata.reflection = GetBanlistResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetBannets::kCountFieldNumber;
#endif  // !_MSC_VER

GetBannets::GetBannets()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetBannets::InitAsDefaultInstance() {
}

GetBannets::GetBannets(const GetBannets& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetBannets::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetBannets::~GetBannets() {
  SharedDtor();
}

void GetBannets::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetBannets::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetBannets::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetBannets_descriptor_;
}

const GetBannets& GetBannets::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetBannets* GetBannets::default_instance_ = NULL;

GetBannets* GetBannets::New() const {
  return new GetBannets;
}

void GetBannets::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetBannets::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetBannets::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->count(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetBannets::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->count(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetBannets::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetBannets::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetBannets* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetBannets*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetBannets::MergeFrom(const GetBannets& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetBannets::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetBannets::CopyFrom(const GetBannets& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBannets::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void GetBannets::Swap(GetBannets* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetBannets::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetBannets_descriptor_;
  metadata.reflection = GetBannets_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetBannetsResponse::kHeaderFieldNumber;
const int GetBannetsResponse::kNetworksFieldNumber;
#endif  // !_MSC_VER

GetBannetsResponse::GetBannetsResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetBannetsResponse::InitAsDefaultInstance() {
  header_ = const_cast< ::org::umit::icm::mobile::proto::ResponseHeader*>(&::org::umit::icm::mobile::proto::ResponseHeader::default_instance());
}

GetBannetsResponse::GetBannetsResponse(const GetBannetsResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetBannetsResponse::SharedCtor() {
  _cached_size_ = 0;
  header_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetBannetsResponse::~GetBannetsResponse() {
  SharedDtor();
}

void GetBannetsResponse::SharedDtor() {
  if (this != default_instance_) {
    delete header_;
  }
}

void GetBannetsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetBannetsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetBannetsResponse_descriptor_;
}

const GetBannetsResponse& GetBannetsResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();  return *default_instance_;
}

GetBannetsResponse* GetBannetsResponse::default_instance_ = NULL;

GetBannetsResponse* GetBannetsResponse::New() const {
  return new GetBannetsResponse;
}

void GetBannetsResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_header()) {
      if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
    }
  }
  networks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetBannetsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_networks;
        break;
      }
      
      // repeated .org.umit.icm.mobile.proto.BannedNetworkData networks = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_networks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_networks()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_networks;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetBannetsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->header(), output);
  }
  
  // repeated .org.umit.icm.mobile.proto.BannedNetworkData networks = 2;
  for (int i = 0; i < this->networks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->networks(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetBannetsResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->header(), target);
  }
  
  // repeated .org.umit.icm.mobile.proto.BannedNetworkData networks = 2;
  for (int i = 0; i < this->networks_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->networks(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetBannetsResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->header());
    }
    
  }
  // repeated .org.umit.icm.mobile.proto.BannedNetworkData networks = 2;
  total_size += 1 * this->networks_size();
  for (int i = 0; i < this->networks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->networks(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetBannetsResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetBannetsResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetBannetsResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetBannetsResponse::MergeFrom(const GetBannetsResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  networks_.MergeFrom(from.networks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::org::umit::icm::mobile::proto::ResponseHeader::MergeFrom(from.header());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetBannetsResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetBannetsResponse::CopyFrom(const GetBannetsResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetBannetsResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  if (has_header()) {
    if (!this->header().IsInitialized()) return false;
  }
  for (int i = 0; i < networks_size(); i++) {
    if (!this->networks(i).IsInitialized()) return false;
  }
  return true;
}

void GetBannetsResponse::Swap(GetBannetsResponse* other) {
  if (other != this) {
    std::swap(header_, other->header_);
    networks_.Swap(&other->networks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetBannetsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetBannetsResponse_descriptor_;
  metadata.reflection = GetBannetsResponse_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace mobile
}  // namespace icm
}  // namespace umit
}  // namespace org

// @@protoc_insertion_point(global_scope)
