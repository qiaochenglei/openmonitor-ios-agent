// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace org {
namespace umit {
namespace icm {
namespace mobile {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Trace;
class TraceRoute;
class ICMReport;
class WebsiteReportDetail;
class WebsiteReport;
class ServiceReportDetail;
class ServiceReport;
class RequestHeader;
class ResponseHeader;
class RegisterAgent;
class RegisterAgentResponse;
class RSAKey;
class CheckAggregator;
class CheckAggregatorResponse;
class Login;
class LoginStep1;
class LoginStep2;
class LoginResponse;
class Logout;
class LogoutResponse;
class GetPeerList;
class AgentData;
class GetPeerListResponse;
class GetSuperPeerList;
class GetSuperPeerListResponse;
class Location;
class GetEvents;
class Event;
class GetEventsResponse;
class SendWebsiteReport;
class SendServiceReport;
class SendReportResponse;
class NewVersion;
class NewVersionResponse;
class NewTests;
class Website;
class Service;
class Test;
class NewTestsResponse;
class AssignTask;
class AssignTaskResponse;
class UpgradeToSuper;
class UpgradeToSuperResponse;
class WebsiteSuggestion;
class ServiceSuggestion;
class TestSuggestionResponse;
class AuthenticatePeer;
class AuthenticatePeerResponse;
class P2PGetSuperPeerList;
class P2PGetSuperPeerListResponse;
class P2PGetPeerList;
class P2PGetPeerListResponse;
class AgentUpdate;
class AgentUpdateResponse;
class TestModuleUpdate;
class TestModuleUpdateResponse;
class ForwardingMessage;
class ForwardingMessageResponse;
class LoginCredentials;
class GetNetlist;
class NetworkData;
class BannedNetworkData;
class GetNetlistResponse;
class GetBanlist;
class GetBanlistResponse;
class GetBannets;
class GetBannetsResponse;

// ===================================================================

class Trace : public ::google::protobuf::Message {
 public:
  Trace();
  virtual ~Trace();
  
  Trace(const Trace& from);
  
  inline Trace& operator=(const Trace& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trace& default_instance();
  
  void Swap(Trace* other);
  
  // implements Message ----------------------------------------------
  
  Trace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Trace& from);
  void MergeFrom(const Trace& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 hop = 1;
  inline bool has_hop() const;
  inline void clear_hop();
  static const int kHopFieldNumber = 1;
  inline ::google::protobuf::int32 hop() const;
  inline void set_hop(::google::protobuf::int32 value);
  
  // required string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // repeated int32 packetsTiming = 3;
  inline int packetstiming_size() const;
  inline void clear_packetstiming();
  static const int kPacketsTimingFieldNumber = 3;
  inline ::google::protobuf::int32 packetstiming(int index) const;
  inline void set_packetstiming(int index, ::google::protobuf::int32 value);
  inline void add_packetstiming(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      packetstiming() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_packetstiming();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Trace)
 private:
  inline void set_has_hop();
  inline void clear_has_hop();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* ip_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > packetstiming_;
  ::google::protobuf::int32 hop_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Trace* default_instance_;
};
// -------------------------------------------------------------------

class TraceRoute : public ::google::protobuf::Message {
 public:
  TraceRoute();
  virtual ~TraceRoute();
  
  TraceRoute(const TraceRoute& from);
  
  inline TraceRoute& operator=(const TraceRoute& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraceRoute& default_instance();
  
  void Swap(TraceRoute* other);
  
  // implements Message ----------------------------------------------
  
  TraceRoute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TraceRoute& from);
  void MergeFrom(const TraceRoute& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string target = 1;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 1;
  inline const ::std::string& target() const;
  inline void set_target(const ::std::string& value);
  inline void set_target(const char* value);
  inline void set_target(const char* value, size_t size);
  inline ::std::string* mutable_target();
  inline ::std::string* release_target();
  
  // required int32 hops = 2;
  inline bool has_hops() const;
  inline void clear_hops();
  static const int kHopsFieldNumber = 2;
  inline ::google::protobuf::int32 hops() const;
  inline void set_hops(::google::protobuf::int32 value);
  
  // required int32 packetSize = 3;
  inline bool has_packetsize() const;
  inline void clear_packetsize();
  static const int kPacketSizeFieldNumber = 3;
  inline ::google::protobuf::int32 packetsize() const;
  inline void set_packetsize(::google::protobuf::int32 value);
  
  // repeated .org.umit.icm.mobile.proto.Trace traces = 4;
  inline int traces_size() const;
  inline void clear_traces();
  static const int kTracesFieldNumber = 4;
  inline const ::org::umit::icm::mobile::proto::Trace& traces(int index) const;
  inline ::org::umit::icm::mobile::proto::Trace* mutable_traces(int index);
  inline ::org::umit::icm::mobile::proto::Trace* add_traces();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Trace >&
      traces() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Trace >*
      mutable_traces();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.TraceRoute)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_hops();
  inline void clear_has_hops();
  inline void set_has_packetsize();
  inline void clear_has_packetsize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* target_;
  ::google::protobuf::int32 hops_;
  ::google::protobuf::int32 packetsize_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Trace > traces_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static TraceRoute* default_instance_;
};
// -------------------------------------------------------------------

class ICMReport : public ::google::protobuf::Message {
 public:
  ICMReport();
  virtual ~ICMReport();
  
  ICMReport(const ICMReport& from);
  
  inline ICMReport& operator=(const ICMReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ICMReport& default_instance();
  
  void Swap(ICMReport* other);
  
  // implements Message ----------------------------------------------
  
  ICMReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ICMReport& from);
  void MergeFrom(const ICMReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string reportID = 1;
  inline bool has_reportid() const;
  inline void clear_reportid();
  static const int kReportIDFieldNumber = 1;
  inline const ::std::string& reportid() const;
  inline void set_reportid(const ::std::string& value);
  inline void set_reportid(const char* value);
  inline void set_reportid(const char* value, size_t size);
  inline ::std::string* mutable_reportid();
  inline ::std::string* release_reportid();
  
  // required string agentID = 2;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 2;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // required int64 testID = 3;
  inline bool has_testid() const;
  inline void clear_testid();
  static const int kTestIDFieldNumber = 3;
  inline ::google::protobuf::int64 testid() const;
  inline void set_testid(::google::protobuf::int64 value);
  
  // required int32 timeZone = 4;
  inline bool has_timezone() const;
  inline void clear_timezone();
  static const int kTimeZoneFieldNumber = 4;
  inline ::google::protobuf::int32 timezone() const;
  inline void set_timezone(::google::protobuf::int32 value);
  
  // required int64 timeUTC = 5;
  inline bool has_timeutc() const;
  inline void clear_timeutc();
  static const int kTimeUTCFieldNumber = 5;
  inline ::google::protobuf::int64 timeutc() const;
  inline void set_timeutc(::google::protobuf::int64 value);
  
  // repeated string passedNode = 6;
  inline int passednode_size() const;
  inline void clear_passednode();
  static const int kPassedNodeFieldNumber = 6;
  inline const ::std::string& passednode(int index) const;
  inline ::std::string* mutable_passednode(int index);
  inline void set_passednode(int index, const ::std::string& value);
  inline void set_passednode(int index, const char* value);
  inline void set_passednode(int index, const char* value, size_t size);
  inline ::std::string* add_passednode();
  inline void add_passednode(const ::std::string& value);
  inline void add_passednode(const char* value);
  inline void add_passednode(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& passednode() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_passednode();
  
  // optional .org.umit.icm.mobile.proto.TraceRoute traceroute = 7;
  inline bool has_traceroute() const;
  inline void clear_traceroute();
  static const int kTracerouteFieldNumber = 7;
  inline const ::org::umit::icm::mobile::proto::TraceRoute& traceroute() const;
  inline ::org::umit::icm::mobile::proto::TraceRoute* mutable_traceroute();
  inline ::org::umit::icm::mobile::proto::TraceRoute* release_traceroute();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ICMReport)
 private:
  inline void set_has_reportid();
  inline void clear_has_reportid();
  inline void set_has_agentid();
  inline void clear_has_agentid();
  inline void set_has_testid();
  inline void clear_has_testid();
  inline void set_has_timezone();
  inline void clear_has_timezone();
  inline void set_has_timeutc();
  inline void clear_has_timeutc();
  inline void set_has_traceroute();
  inline void clear_has_traceroute();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* reportid_;
  ::std::string* agentid_;
  ::google::protobuf::int64 testid_;
  ::google::protobuf::int64 timeutc_;
  ::google::protobuf::RepeatedPtrField< ::std::string> passednode_;
  ::org::umit::icm::mobile::proto::TraceRoute* traceroute_;
  ::google::protobuf::int32 timezone_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ICMReport* default_instance_;
};
// -------------------------------------------------------------------

class WebsiteReportDetail : public ::google::protobuf::Message {
 public:
  WebsiteReportDetail();
  virtual ~WebsiteReportDetail();
  
  WebsiteReportDetail(const WebsiteReportDetail& from);
  
  inline WebsiteReportDetail& operator=(const WebsiteReportDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebsiteReportDetail& default_instance();
  
  void Swap(WebsiteReportDetail* other);
  
  // implements Message ----------------------------------------------
  
  WebsiteReportDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebsiteReportDetail& from);
  void MergeFrom(const WebsiteReportDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string websiteURL = 1;
  inline bool has_websiteurl() const;
  inline void clear_websiteurl();
  static const int kWebsiteURLFieldNumber = 1;
  inline const ::std::string& websiteurl() const;
  inline void set_websiteurl(const ::std::string& value);
  inline void set_websiteurl(const char* value);
  inline void set_websiteurl(const char* value, size_t size);
  inline ::std::string* mutable_websiteurl();
  inline ::std::string* release_websiteurl();
  
  // required int32 statusCode = 2;
  inline bool has_statuscode() const;
  inline void clear_statuscode();
  static const int kStatusCodeFieldNumber = 2;
  inline ::google::protobuf::int32 statuscode() const;
  inline void set_statuscode(::google::protobuf::int32 value);
  
  // optional int32 responseTime = 3;
  inline bool has_responsetime() const;
  inline void clear_responsetime();
  static const int kResponseTimeFieldNumber = 3;
  inline ::google::protobuf::int32 responsetime() const;
  inline void set_responsetime(::google::protobuf::int32 value);
  
  // optional int32 bandwidth = 4;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 4;
  inline ::google::protobuf::int32 bandwidth() const;
  inline void set_bandwidth(::google::protobuf::int32 value);
  
  // optional string redirectLink = 5;
  inline bool has_redirectlink() const;
  inline void clear_redirectlink();
  static const int kRedirectLinkFieldNumber = 5;
  inline const ::std::string& redirectlink() const;
  inline void set_redirectlink(const ::std::string& value);
  inline void set_redirectlink(const char* value);
  inline void set_redirectlink(const char* value, size_t size);
  inline ::std::string* mutable_redirectlink();
  inline ::std::string* release_redirectlink();
  
  // optional string htmlResponse = 6;
  inline bool has_htmlresponse() const;
  inline void clear_htmlresponse();
  static const int kHtmlResponseFieldNumber = 6;
  inline const ::std::string& htmlresponse() const;
  inline void set_htmlresponse(const ::std::string& value);
  inline void set_htmlresponse(const char* value);
  inline void set_htmlresponse(const char* value, size_t size);
  inline ::std::string* mutable_htmlresponse();
  inline ::std::string* release_htmlresponse();
  
  // optional bytes htmlMedia = 7;
  inline bool has_htmlmedia() const;
  inline void clear_htmlmedia();
  static const int kHtmlMediaFieldNumber = 7;
  inline const ::std::string& htmlmedia() const;
  inline void set_htmlmedia(const ::std::string& value);
  inline void set_htmlmedia(const char* value);
  inline void set_htmlmedia(const void* value, size_t size);
  inline ::std::string* mutable_htmlmedia();
  inline ::std::string* release_htmlmedia();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.WebsiteReportDetail)
 private:
  inline void set_has_websiteurl();
  inline void clear_has_websiteurl();
  inline void set_has_statuscode();
  inline void clear_has_statuscode();
  inline void set_has_responsetime();
  inline void clear_has_responsetime();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  inline void set_has_redirectlink();
  inline void clear_has_redirectlink();
  inline void set_has_htmlresponse();
  inline void clear_has_htmlresponse();
  inline void set_has_htmlmedia();
  inline void clear_has_htmlmedia();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* websiteurl_;
  ::google::protobuf::int32 statuscode_;
  ::google::protobuf::int32 responsetime_;
  ::std::string* redirectlink_;
  ::std::string* htmlresponse_;
  ::std::string* htmlmedia_;
  ::google::protobuf::int32 bandwidth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static WebsiteReportDetail* default_instance_;
};
// -------------------------------------------------------------------

class WebsiteReport : public ::google::protobuf::Message {
 public:
  WebsiteReport();
  virtual ~WebsiteReport();
  
  WebsiteReport(const WebsiteReport& from);
  
  inline WebsiteReport& operator=(const WebsiteReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebsiteReport& default_instance();
  
  void Swap(WebsiteReport* other);
  
  // implements Message ----------------------------------------------
  
  WebsiteReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebsiteReport& from);
  void MergeFrom(const WebsiteReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ICMReport header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ICMReport& header() const;
  inline ::org::umit::icm::mobile::proto::ICMReport* mutable_header();
  inline ::org::umit::icm::mobile::proto::ICMReport* release_header();
  
  // required .org.umit.icm.mobile.proto.WebsiteReportDetail report = 2;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::WebsiteReportDetail& report() const;
  inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* mutable_report();
  inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* release_report();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.WebsiteReport)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_report();
  inline void clear_has_report();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ICMReport* header_;
  ::org::umit::icm::mobile::proto::WebsiteReportDetail* report_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static WebsiteReport* default_instance_;
};
// -------------------------------------------------------------------

class ServiceReportDetail : public ::google::protobuf::Message {
 public:
  ServiceReportDetail();
  virtual ~ServiceReportDetail();
  
  ServiceReportDetail(const ServiceReportDetail& from);
  
  inline ServiceReportDetail& operator=(const ServiceReportDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReportDetail& default_instance();
  
  void Swap(ServiceReportDetail* other);
  
  // implements Message ----------------------------------------------
  
  ServiceReportDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceReportDetail& from);
  void MergeFrom(const ServiceReportDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string serviceName = 1;
  inline bool has_servicename() const;
  inline void clear_servicename();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& servicename() const;
  inline void set_servicename(const ::std::string& value);
  inline void set_servicename(const char* value);
  inline void set_servicename(const char* value, size_t size);
  inline ::std::string* mutable_servicename();
  inline ::std::string* release_servicename();
  
  // required int32 statusCode = 2;
  inline bool has_statuscode() const;
  inline void clear_statuscode();
  static const int kStatusCodeFieldNumber = 2;
  inline ::google::protobuf::int32 statuscode() const;
  inline void set_statuscode(::google::protobuf::int32 value);
  
  // required int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional double responseTime = 4;
  inline bool has_responsetime() const;
  inline void clear_responsetime();
  static const int kResponseTimeFieldNumber = 4;
  inline double responsetime() const;
  inline void set_responsetime(double value);
  
  // optional double bandwidth = 5;
  inline bool has_bandwidth() const;
  inline void clear_bandwidth();
  static const int kBandwidthFieldNumber = 5;
  inline double bandwidth() const;
  inline void set_bandwidth(double value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ServiceReportDetail)
 private:
  inline void set_has_servicename();
  inline void clear_has_servicename();
  inline void set_has_statuscode();
  inline void clear_has_statuscode();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_responsetime();
  inline void clear_has_responsetime();
  inline void set_has_bandwidth();
  inline void clear_has_bandwidth();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* servicename_;
  ::google::protobuf::int32 statuscode_;
  ::google::protobuf::int32 port_;
  double responsetime_;
  double bandwidth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ServiceReportDetail* default_instance_;
};
// -------------------------------------------------------------------

class ServiceReport : public ::google::protobuf::Message {
 public:
  ServiceReport();
  virtual ~ServiceReport();
  
  ServiceReport(const ServiceReport& from);
  
  inline ServiceReport& operator=(const ServiceReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceReport& default_instance();
  
  void Swap(ServiceReport* other);
  
  // implements Message ----------------------------------------------
  
  ServiceReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceReport& from);
  void MergeFrom(const ServiceReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ICMReport header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ICMReport& header() const;
  inline ::org::umit::icm::mobile::proto::ICMReport* mutable_header();
  inline ::org::umit::icm::mobile::proto::ICMReport* release_header();
  
  // required .org.umit.icm.mobile.proto.ServiceReportDetail report = 2;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::ServiceReportDetail& report() const;
  inline ::org::umit::icm::mobile::proto::ServiceReportDetail* mutable_report();
  inline ::org::umit::icm::mobile::proto::ServiceReportDetail* release_report();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ServiceReport)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_report();
  inline void clear_has_report();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ICMReport* header_;
  ::org::umit::icm::mobile::proto::ServiceReportDetail* report_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ServiceReport* default_instance_;
};
// -------------------------------------------------------------------

class RequestHeader : public ::google::protobuf::Message {
 public:
  RequestHeader();
  virtual ~RequestHeader();
  
  RequestHeader(const RequestHeader& from);
  
  inline RequestHeader& operator=(const RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestHeader& default_instance();
  
  void Swap(RequestHeader* other);
  
  // implements Message ----------------------------------------------
  
  RequestHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestHeader& from);
  void MergeFrom(const RequestHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string agentID = 1;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 1;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.RequestHeader)
 private:
  inline void set_has_agentid();
  inline void clear_has_agentid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agentid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static RequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class ResponseHeader : public ::google::protobuf::Message {
 public:
  ResponseHeader();
  virtual ~ResponseHeader();
  
  ResponseHeader(const ResponseHeader& from);
  
  inline ResponseHeader& operator=(const ResponseHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseHeader& default_instance();
  
  void Swap(ResponseHeader* other);
  
  // implements Message ----------------------------------------------
  
  ResponseHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseHeader& from);
  void MergeFrom(const ResponseHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 currentVersionNo = 1;
  inline bool has_currentversionno() const;
  inline void clear_currentversionno();
  static const int kCurrentVersionNoFieldNumber = 1;
  inline ::google::protobuf::int32 currentversionno() const;
  inline void set_currentversionno(::google::protobuf::int32 value);
  
  // required int32 currentTestVersionNo = 2;
  inline bool has_currenttestversionno() const;
  inline void clear_currenttestversionno();
  static const int kCurrentTestVersionNoFieldNumber = 2;
  inline ::google::protobuf::int32 currenttestversionno() const;
  inline void set_currenttestversionno(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ResponseHeader)
 private:
  inline void set_has_currentversionno();
  inline void clear_has_currentversionno();
  inline void set_has_currenttestversionno();
  inline void clear_has_currenttestversionno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 currentversionno_;
  ::google::protobuf::int32 currenttestversionno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseHeader* default_instance_;
};
// -------------------------------------------------------------------

class RegisterAgent : public ::google::protobuf::Message {
 public:
  RegisterAgent();
  virtual ~RegisterAgent();
  
  RegisterAgent(const RegisterAgent& from);
  
  inline RegisterAgent& operator=(const RegisterAgent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAgent& default_instance();
  
  void Swap(RegisterAgent* other);
  
  // implements Message ----------------------------------------------
  
  RegisterAgent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterAgent& from);
  void MergeFrom(const RegisterAgent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 versionNo = 1;
  inline bool has_versionno() const;
  inline void clear_versionno();
  static const int kVersionNoFieldNumber = 1;
  inline ::google::protobuf::int32 versionno() const;
  inline void set_versionno(::google::protobuf::int32 value);
  
  // required string agentType = 2;
  inline bool has_agenttype() const;
  inline void clear_agenttype();
  static const int kAgentTypeFieldNumber = 2;
  inline const ::std::string& agenttype() const;
  inline void set_agenttype(const ::std::string& value);
  inline void set_agenttype(const char* value);
  inline void set_agenttype(const char* value, size_t size);
  inline ::std::string* mutable_agenttype();
  inline ::std::string* release_agenttype();
  
  // required .org.umit.icm.mobile.proto.LoginCredentials credentials = 3;
  inline bool has_credentials() const;
  inline void clear_credentials();
  static const int kCredentialsFieldNumber = 3;
  inline const ::org::umit::icm::mobile::proto::LoginCredentials& credentials() const;
  inline ::org::umit::icm::mobile::proto::LoginCredentials* mutable_credentials();
  inline ::org::umit::icm::mobile::proto::LoginCredentials* release_credentials();
  
  // required .org.umit.icm.mobile.proto.RSAKey agentPublicKey = 4;
  inline bool has_agentpublickey() const;
  inline void clear_agentpublickey();
  static const int kAgentPublicKeyFieldNumber = 4;
  inline const ::org::umit::icm::mobile::proto::RSAKey& agentpublickey() const;
  inline ::org::umit::icm::mobile::proto::RSAKey* mutable_agentpublickey();
  inline ::org::umit::icm::mobile::proto::RSAKey* release_agentpublickey();
  
  // optional string ip = 5;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 5;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.RegisterAgent)
 private:
  inline void set_has_versionno();
  inline void clear_has_versionno();
  inline void set_has_agenttype();
  inline void clear_has_agenttype();
  inline void set_has_credentials();
  inline void clear_has_credentials();
  inline void set_has_agentpublickey();
  inline void clear_has_agentpublickey();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agenttype_;
  ::org::umit::icm::mobile::proto::LoginCredentials* credentials_;
  ::org::umit::icm::mobile::proto::RSAKey* agentpublickey_;
  ::std::string* ip_;
  ::google::protobuf::int32 versionno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static RegisterAgent* default_instance_;
};
// -------------------------------------------------------------------

class RegisterAgentResponse : public ::google::protobuf::Message {
 public:
  RegisterAgentResponse();
  virtual ~RegisterAgentResponse();
  
  RegisterAgentResponse(const RegisterAgentResponse& from);
  
  inline RegisterAgentResponse& operator=(const RegisterAgentResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterAgentResponse& default_instance();
  
  void Swap(RegisterAgentResponse* other);
  
  // implements Message ----------------------------------------------
  
  RegisterAgentResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterAgentResponse& from);
  void MergeFrom(const RegisterAgentResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // required string agentID = 2;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 2;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // required string publicKeyHash = 3;
  inline bool has_publickeyhash() const;
  inline void clear_publickeyhash();
  static const int kPublicKeyHashFieldNumber = 3;
  inline const ::std::string& publickeyhash() const;
  inline void set_publickeyhash(const ::std::string& value);
  inline void set_publickeyhash(const char* value);
  inline void set_publickeyhash(const char* value, size_t size);
  inline ::std::string* mutable_publickeyhash();
  inline ::std::string* release_publickeyhash();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.RegisterAgentResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_agentid();
  inline void clear_has_agentid();
  inline void set_has_publickeyhash();
  inline void clear_has_publickeyhash();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::std::string* agentid_;
  ::std::string* publickeyhash_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static RegisterAgentResponse* default_instance_;
};
// -------------------------------------------------------------------

class RSAKey : public ::google::protobuf::Message {
 public:
  RSAKey();
  virtual ~RSAKey();
  
  RSAKey(const RSAKey& from);
  
  inline RSAKey& operator=(const RSAKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RSAKey& default_instance();
  
  void Swap(RSAKey* other);
  
  // implements Message ----------------------------------------------
  
  RSAKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RSAKey& from);
  void MergeFrom(const RSAKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mod = 1;
  inline bool has_mod() const;
  inline void clear_mod();
  static const int kModFieldNumber = 1;
  inline const ::std::string& mod() const;
  inline void set_mod(const ::std::string& value);
  inline void set_mod(const char* value);
  inline void set_mod(const char* value, size_t size);
  inline ::std::string* mutable_mod();
  inline ::std::string* release_mod();
  
  // required string exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline const ::std::string& exp() const;
  inline void set_exp(const ::std::string& value);
  inline void set_exp(const char* value);
  inline void set_exp(const char* value, size_t size);
  inline ::std::string* mutable_exp();
  inline ::std::string* release_exp();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.RSAKey)
 private:
  inline void set_has_mod();
  inline void clear_has_mod();
  inline void set_has_exp();
  inline void clear_has_exp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* mod_;
  ::std::string* exp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static RSAKey* default_instance_;
};
// -------------------------------------------------------------------

class CheckAggregator : public ::google::protobuf::Message {
 public:
  CheckAggregator();
  virtual ~CheckAggregator();
  
  CheckAggregator(const CheckAggregator& from);
  
  inline CheckAggregator& operator=(const CheckAggregator& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckAggregator& default_instance();
  
  void Swap(CheckAggregator* other);
  
  // implements Message ----------------------------------------------
  
  CheckAggregator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckAggregator& from);
  void MergeFrom(const CheckAggregator& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string agentType = 1;
  inline bool has_agenttype() const;
  inline void clear_agenttype();
  static const int kAgentTypeFieldNumber = 1;
  inline const ::std::string& agenttype() const;
  inline void set_agenttype(const ::std::string& value);
  inline void set_agenttype(const char* value);
  inline void set_agenttype(const char* value, size_t size);
  inline ::std::string* mutable_agenttype();
  inline ::std::string* release_agenttype();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.CheckAggregator)
 private:
  inline void set_has_agenttype();
  inline void clear_has_agenttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agenttype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static CheckAggregator* default_instance_;
};
// -------------------------------------------------------------------

class CheckAggregatorResponse : public ::google::protobuf::Message {
 public:
  CheckAggregatorResponse();
  virtual ~CheckAggregatorResponse();
  
  CheckAggregatorResponse(const CheckAggregatorResponse& from);
  
  inline CheckAggregatorResponse& operator=(const CheckAggregatorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckAggregatorResponse& default_instance();
  
  void Swap(CheckAggregatorResponse* other);
  
  // implements Message ----------------------------------------------
  
  CheckAggregatorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckAggregatorResponse& from);
  void MergeFrom(const CheckAggregatorResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // required string status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.CheckAggregatorResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::std::string* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static CheckAggregatorResponse* default_instance_;
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();
  
  Login(const Login& from);
  
  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();
  
  void Swap(Login* other);
  
  // implements Message ----------------------------------------------
  
  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string agentID = 1;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 1;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // required string challenge = 2;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 2;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const char* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  
  // required int64 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int64 port() const;
  inline void set_port(::google::protobuf::int64 value);
  
  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Login)
 private:
  inline void set_has_agentid();
  inline void clear_has_agentid();
  inline void set_has_challenge();
  inline void clear_has_challenge();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agentid_;
  ::std::string* challenge_;
  ::google::protobuf::int64 port_;
  ::std::string* ip_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class LoginStep1 : public ::google::protobuf::Message {
 public:
  LoginStep1();
  virtual ~LoginStep1();
  
  LoginStep1(const LoginStep1& from);
  
  inline LoginStep1& operator=(const LoginStep1& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginStep1& default_instance();
  
  void Swap(LoginStep1* other);
  
  // implements Message ----------------------------------------------
  
  LoginStep1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginStep1& from);
  void MergeFrom(const LoginStep1& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string processID = 1;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  inline const ::std::string& processid() const;
  inline void set_processid(const ::std::string& value);
  inline void set_processid(const char* value);
  inline void set_processid(const char* value, size_t size);
  inline ::std::string* mutable_processid();
  inline ::std::string* release_processid();
  
  // required string cipheredChallenge = 2;
  inline bool has_cipheredchallenge() const;
  inline void clear_cipheredchallenge();
  static const int kCipheredChallengeFieldNumber = 2;
  inline const ::std::string& cipheredchallenge() const;
  inline void set_cipheredchallenge(const ::std::string& value);
  inline void set_cipheredchallenge(const char* value);
  inline void set_cipheredchallenge(const char* value, size_t size);
  inline ::std::string* mutable_cipheredchallenge();
  inline ::std::string* release_cipheredchallenge();
  
  // required string challenge = 3;
  inline bool has_challenge() const;
  inline void clear_challenge();
  static const int kChallengeFieldNumber = 3;
  inline const ::std::string& challenge() const;
  inline void set_challenge(const ::std::string& value);
  inline void set_challenge(const char* value);
  inline void set_challenge(const char* value, size_t size);
  inline ::std::string* mutable_challenge();
  inline ::std::string* release_challenge();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.LoginStep1)
 private:
  inline void set_has_processid();
  inline void clear_has_processid();
  inline void set_has_cipheredchallenge();
  inline void clear_has_cipheredchallenge();
  inline void set_has_challenge();
  inline void clear_has_challenge();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* processid_;
  ::std::string* cipheredchallenge_;
  ::std::string* challenge_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginStep1* default_instance_;
};
// -------------------------------------------------------------------

class LoginStep2 : public ::google::protobuf::Message {
 public:
  LoginStep2();
  virtual ~LoginStep2();
  
  LoginStep2(const LoginStep2& from);
  
  inline LoginStep2& operator=(const LoginStep2& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginStep2& default_instance();
  
  void Swap(LoginStep2* other);
  
  // implements Message ----------------------------------------------
  
  LoginStep2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginStep2& from);
  void MergeFrom(const LoginStep2& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string processID = 1;
  inline bool has_processid() const;
  inline void clear_processid();
  static const int kProcessIDFieldNumber = 1;
  inline const ::std::string& processid() const;
  inline void set_processid(const ::std::string& value);
  inline void set_processid(const char* value);
  inline void set_processid(const char* value, size_t size);
  inline ::std::string* mutable_processid();
  inline ::std::string* release_processid();
  
  // required string cipheredChallenge = 2;
  inline bool has_cipheredchallenge() const;
  inline void clear_cipheredchallenge();
  static const int kCipheredChallengeFieldNumber = 2;
  inline const ::std::string& cipheredchallenge() const;
  inline void set_cipheredchallenge(const ::std::string& value);
  inline void set_cipheredchallenge(const char* value);
  inline void set_cipheredchallenge(const char* value, size_t size);
  inline ::std::string* mutable_cipheredchallenge();
  inline ::std::string* release_cipheredchallenge();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.LoginStep2)
 private:
  inline void set_has_processid();
  inline void clear_has_processid();
  inline void set_has_cipheredchallenge();
  inline void clear_has_cipheredchallenge();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* processid_;
  ::std::string* cipheredchallenge_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginStep2* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();
  
  LoginResponse(const LoginResponse& from);
  
  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();
  
  void Swap(LoginResponse* other);
  
  // implements Message ----------------------------------------------
  
  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.LoginResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class Logout : public ::google::protobuf::Message {
 public:
  Logout();
  virtual ~Logout();
  
  Logout(const Logout& from);
  
  inline Logout& operator=(const Logout& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Logout& default_instance();
  
  void Swap(Logout* other);
  
  // implements Message ----------------------------------------------
  
  Logout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Logout& from);
  void MergeFrom(const Logout& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string agentID = 1;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 1;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Logout)
 private:
  inline void set_has_agentid();
  inline void clear_has_agentid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agentid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Logout* default_instance_;
};
// -------------------------------------------------------------------

class LogoutResponse : public ::google::protobuf::Message {
 public:
  LogoutResponse();
  virtual ~LogoutResponse();
  
  LogoutResponse(const LogoutResponse& from);
  
  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutResponse& default_instance();
  
  void Swap(LogoutResponse* other);
  
  // implements Message ----------------------------------------------
  
  LogoutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutResponse& from);
  void MergeFrom(const LogoutResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.LogoutResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LogoutResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetPeerList : public ::google::protobuf::Message {
 public:
  GetPeerList();
  virtual ~GetPeerList();
  
  GetPeerList(const GetPeerList& from);
  
  inline GetPeerList& operator=(const GetPeerList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPeerList& default_instance();
  
  void Swap(GetPeerList* other);
  
  // implements Message ----------------------------------------------
  
  GetPeerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPeerList& from);
  void MergeFrom(const GetPeerList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetPeerList)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetPeerList* default_instance_;
};
// -------------------------------------------------------------------

class AgentData : public ::google::protobuf::Message {
 public:
  AgentData();
  virtual ~AgentData();
  
  AgentData(const AgentData& from);
  
  inline AgentData& operator=(const AgentData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentData& default_instance();
  
  void Swap(AgentData* other);
  
  // implements Message ----------------------------------------------
  
  AgentData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentData& from);
  void MergeFrom(const AgentData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string agentID = 1;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 1;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // required string agentIP = 2;
  inline bool has_agentip() const;
  inline void clear_agentip();
  static const int kAgentIPFieldNumber = 2;
  inline const ::std::string& agentip() const;
  inline void set_agentip(const ::std::string& value);
  inline void set_agentip(const char* value);
  inline void set_agentip(const char* value, size_t size);
  inline ::std::string* mutable_agentip();
  inline ::std::string* release_agentip();
  
  // required int32 agentPort = 3;
  inline bool has_agentport() const;
  inline void clear_agentport();
  static const int kAgentPortFieldNumber = 3;
  inline ::google::protobuf::int32 agentport() const;
  inline void set_agentport(::google::protobuf::int32 value);
  
  // required string token = 4;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 4;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // required .org.umit.icm.mobile.proto.RSAKey publicKey = 5;
  inline bool has_publickey() const;
  inline void clear_publickey();
  static const int kPublicKeyFieldNumber = 5;
  inline const ::org::umit::icm::mobile::proto::RSAKey& publickey() const;
  inline ::org::umit::icm::mobile::proto::RSAKey* mutable_publickey();
  inline ::org::umit::icm::mobile::proto::RSAKey* release_publickey();
  
  // required string peerStatus = 6;
  inline bool has_peerstatus() const;
  inline void clear_peerstatus();
  static const int kPeerStatusFieldNumber = 6;
  inline const ::std::string& peerstatus() const;
  inline void set_peerstatus(const ::std::string& value);
  inline void set_peerstatus(const char* value);
  inline void set_peerstatus(const char* value, size_t size);
  inline ::std::string* mutable_peerstatus();
  inline ::std::string* release_peerstatus();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AgentData)
 private:
  inline void set_has_agentid();
  inline void clear_has_agentid();
  inline void set_has_agentip();
  inline void clear_has_agentip();
  inline void set_has_agentport();
  inline void clear_has_agentport();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_publickey();
  inline void clear_has_publickey();
  inline void set_has_peerstatus();
  inline void clear_has_peerstatus();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agentid_;
  ::std::string* agentip_;
  ::std::string* token_;
  ::org::umit::icm::mobile::proto::RSAKey* publickey_;
  ::std::string* peerstatus_;
  ::google::protobuf::int32 agentport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AgentData* default_instance_;
};
// -------------------------------------------------------------------

class GetPeerListResponse : public ::google::protobuf::Message {
 public:
  GetPeerListResponse();
  virtual ~GetPeerListResponse();
  
  GetPeerListResponse(const GetPeerListResponse& from);
  
  inline GetPeerListResponse& operator=(const GetPeerListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPeerListResponse& default_instance();
  
  void Swap(GetPeerListResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetPeerListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPeerListResponse& from);
  void MergeFrom(const GetPeerListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.AgentData knownPeers = 2;
  inline int knownpeers_size() const;
  inline void clear_knownpeers();
  static const int kKnownPeersFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::AgentData& knownpeers(int index) const;
  inline ::org::umit::icm::mobile::proto::AgentData* mutable_knownpeers(int index);
  inline ::org::umit::icm::mobile::proto::AgentData* add_knownpeers();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
      knownpeers() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
      mutable_knownpeers();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetPeerListResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData > knownpeers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetPeerListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetSuperPeerList : public ::google::protobuf::Message {
 public:
  GetSuperPeerList();
  virtual ~GetSuperPeerList();
  
  GetSuperPeerList(const GetSuperPeerList& from);
  
  inline GetSuperPeerList& operator=(const GetSuperPeerList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSuperPeerList& default_instance();
  
  void Swap(GetSuperPeerList* other);
  
  // implements Message ----------------------------------------------
  
  GetSuperPeerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSuperPeerList& from);
  void MergeFrom(const GetSuperPeerList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetSuperPeerList)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetSuperPeerList* default_instance_;
};
// -------------------------------------------------------------------

class GetSuperPeerListResponse : public ::google::protobuf::Message {
 public:
  GetSuperPeerListResponse();
  virtual ~GetSuperPeerListResponse();
  
  GetSuperPeerListResponse(const GetSuperPeerListResponse& from);
  
  inline GetSuperPeerListResponse& operator=(const GetSuperPeerListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSuperPeerListResponse& default_instance();
  
  void Swap(GetSuperPeerListResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetSuperPeerListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetSuperPeerListResponse& from);
  void MergeFrom(const GetSuperPeerListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.AgentData knownSuperPeers = 2;
  inline int knownsuperpeers_size() const;
  inline void clear_knownsuperpeers();
  static const int kKnownSuperPeersFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::AgentData& knownsuperpeers(int index) const;
  inline ::org::umit::icm::mobile::proto::AgentData* mutable_knownsuperpeers(int index);
  inline ::org::umit::icm::mobile::proto::AgentData* add_knownsuperpeers();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
      knownsuperpeers() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
      mutable_knownsuperpeers();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetSuperPeerListResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData > knownsuperpeers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetSuperPeerListResponse* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message {
 public:
  Location();
  virtual ~Location();
  
  Location(const Location& from);
  
  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();
  
  void Swap(Location* other);
  
  // implements Message ----------------------------------------------
  
  Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double longitude = 1;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // required double latitude = 2;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Location)
 private:
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double longitude_;
  double latitude_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class GetEvents : public ::google::protobuf::Message {
 public:
  GetEvents();
  virtual ~GetEvents();
  
  GetEvents(const GetEvents& from);
  
  inline GetEvents& operator=(const GetEvents& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEvents& default_instance();
  
  void Swap(GetEvents* other);
  
  // implements Message ----------------------------------------------
  
  GetEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEvents& from);
  void MergeFrom(const GetEvents& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .org.umit.icm.mobile.proto.Location locations = 1;
  inline int locations_size() const;
  inline void clear_locations();
  static const int kLocationsFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::Location& locations(int index) const;
  inline ::org::umit::icm::mobile::proto::Location* mutable_locations(int index);
  inline ::org::umit::icm::mobile::proto::Location* add_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >&
      locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >*
      mutable_locations();
  
  // optional .org.umit.icm.mobile.proto.Location agentLocation = 2;
  inline bool has_agentlocation() const;
  inline void clear_agentlocation();
  static const int kAgentLocationFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::Location& agentlocation() const;
  inline ::org::umit::icm::mobile::proto::Location* mutable_agentlocation();
  inline ::org::umit::icm::mobile::proto::Location* release_agentlocation();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetEvents)
 private:
  inline void set_has_agentlocation();
  inline void clear_has_agentlocation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location > locations_;
  ::org::umit::icm::mobile::proto::Location* agentlocation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetEvents* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();
  
  Event(const Event& from);
  
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();
  
  void Swap(Event* other);
  
  // implements Message ----------------------------------------------
  
  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string testType = 1;
  inline bool has_testtype() const;
  inline void clear_testtype();
  static const int kTestTypeFieldNumber = 1;
  inline const ::std::string& testtype() const;
  inline void set_testtype(const ::std::string& value);
  inline void set_testtype(const char* value);
  inline void set_testtype(const char* value, size_t size);
  inline ::std::string* mutable_testtype();
  inline ::std::string* release_testtype();
  
  // required string eventType = 2;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline const ::std::string& eventtype() const;
  inline void set_eventtype(const ::std::string& value);
  inline void set_eventtype(const char* value);
  inline void set_eventtype(const char* value, size_t size);
  inline ::std::string* mutable_eventtype();
  inline ::std::string* release_eventtype();
  
  // required int64 timeUTC = 3;
  inline bool has_timeutc() const;
  inline void clear_timeutc();
  static const int kTimeUTCFieldNumber = 3;
  inline ::google::protobuf::int64 timeutc() const;
  inline void set_timeutc(::google::protobuf::int64 value);
  
  // required int64 sinceTimeUTC = 4;
  inline bool has_sincetimeutc() const;
  inline void clear_sincetimeutc();
  static const int kSinceTimeUTCFieldNumber = 4;
  inline ::google::protobuf::int64 sincetimeutc() const;
  inline void set_sincetimeutc(::google::protobuf::int64 value);
  
  // repeated .org.umit.icm.mobile.proto.Location locations = 5;
  inline int locations_size() const;
  inline void clear_locations();
  static const int kLocationsFieldNumber = 5;
  inline const ::org::umit::icm::mobile::proto::Location& locations(int index) const;
  inline ::org::umit::icm::mobile::proto::Location* mutable_locations(int index);
  inline ::org::umit::icm::mobile::proto::Location* add_locations();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >&
      locations() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >*
      mutable_locations();
  
  // optional .org.umit.icm.mobile.proto.WebsiteReportDetail websiteReport = 6;
  inline bool has_websitereport() const;
  inline void clear_websitereport();
  static const int kWebsiteReportFieldNumber = 6;
  inline const ::org::umit::icm::mobile::proto::WebsiteReportDetail& websitereport() const;
  inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* mutable_websitereport();
  inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* release_websitereport();
  
  // optional .org.umit.icm.mobile.proto.ServiceReportDetail serviceReport = 7;
  inline bool has_servicereport() const;
  inline void clear_servicereport();
  static const int kServiceReportFieldNumber = 7;
  inline const ::org::umit::icm::mobile::proto::ServiceReportDetail& servicereport() const;
  inline ::org::umit::icm::mobile::proto::ServiceReportDetail* mutable_servicereport();
  inline ::org::umit::icm::mobile::proto::ServiceReportDetail* release_servicereport();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Event)
 private:
  inline void set_has_testtype();
  inline void clear_has_testtype();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_timeutc();
  inline void clear_has_timeutc();
  inline void set_has_sincetimeutc();
  inline void clear_has_sincetimeutc();
  inline void set_has_websitereport();
  inline void clear_has_websitereport();
  inline void set_has_servicereport();
  inline void clear_has_servicereport();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* testtype_;
  ::std::string* eventtype_;
  ::google::protobuf::int64 timeutc_;
  ::google::protobuf::int64 sincetimeutc_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location > locations_;
  ::org::umit::icm::mobile::proto::WebsiteReportDetail* websitereport_;
  ::org::umit::icm::mobile::proto::ServiceReportDetail* servicereport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class GetEventsResponse : public ::google::protobuf::Message {
 public:
  GetEventsResponse();
  virtual ~GetEventsResponse();
  
  GetEventsResponse(const GetEventsResponse& from);
  
  inline GetEventsResponse& operator=(const GetEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEventsResponse& default_instance();
  
  void Swap(GetEventsResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetEventsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEventsResponse& from);
  void MergeFrom(const GetEventsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.Event events = 2;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::Event& events(int index) const;
  inline ::org::umit::icm::mobile::proto::Event* mutable_events(int index);
  inline ::org::umit::icm::mobile::proto::Event* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Event >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Event >*
      mutable_events();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetEventsResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Event > events_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetEventsResponse* default_instance_;
};
// -------------------------------------------------------------------

class SendWebsiteReport : public ::google::protobuf::Message {
 public:
  SendWebsiteReport();
  virtual ~SendWebsiteReport();
  
  SendWebsiteReport(const SendWebsiteReport& from);
  
  inline SendWebsiteReport& operator=(const SendWebsiteReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendWebsiteReport& default_instance();
  
  void Swap(SendWebsiteReport* other);
  
  // implements Message ----------------------------------------------
  
  SendWebsiteReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendWebsiteReport& from);
  void MergeFrom(const SendWebsiteReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.WebsiteReport report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::WebsiteReport& report() const;
  inline ::org::umit::icm::mobile::proto::WebsiteReport* mutable_report();
  inline ::org::umit::icm::mobile::proto::WebsiteReport* release_report();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.SendWebsiteReport)
 private:
  inline void set_has_report();
  inline void clear_has_report();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::WebsiteReport* report_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static SendWebsiteReport* default_instance_;
};
// -------------------------------------------------------------------

class SendServiceReport : public ::google::protobuf::Message {
 public:
  SendServiceReport();
  virtual ~SendServiceReport();
  
  SendServiceReport(const SendServiceReport& from);
  
  inline SendServiceReport& operator=(const SendServiceReport& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendServiceReport& default_instance();
  
  void Swap(SendServiceReport* other);
  
  // implements Message ----------------------------------------------
  
  SendServiceReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendServiceReport& from);
  void MergeFrom(const SendServiceReport& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ServiceReport report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ServiceReport& report() const;
  inline ::org::umit::icm::mobile::proto::ServiceReport* mutable_report();
  inline ::org::umit::icm::mobile::proto::ServiceReport* release_report();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.SendServiceReport)
 private:
  inline void set_has_report();
  inline void clear_has_report();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ServiceReport* report_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static SendServiceReport* default_instance_;
};
// -------------------------------------------------------------------

class SendReportResponse : public ::google::protobuf::Message {
 public:
  SendReportResponse();
  virtual ~SendReportResponse();
  
  SendReportResponse(const SendReportResponse& from);
  
  inline SendReportResponse& operator=(const SendReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SendReportResponse& default_instance();
  
  void Swap(SendReportResponse* other);
  
  // implements Message ----------------------------------------------
  
  SendReportResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendReportResponse& from);
  void MergeFrom(const SendReportResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.SendReportResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static SendReportResponse* default_instance_;
};
// -------------------------------------------------------------------

class NewVersion : public ::google::protobuf::Message {
 public:
  NewVersion();
  virtual ~NewVersion();
  
  NewVersion(const NewVersion& from);
  
  inline NewVersion& operator=(const NewVersion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewVersion& default_instance();
  
  void Swap(NewVersion* other);
  
  // implements Message ----------------------------------------------
  
  NewVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewVersion& from);
  void MergeFrom(const NewVersion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 agentVersionNo = 1;
  inline bool has_agentversionno() const;
  inline void clear_agentversionno();
  static const int kAgentVersionNoFieldNumber = 1;
  inline ::google::protobuf::int32 agentversionno() const;
  inline void set_agentversionno(::google::protobuf::int32 value);
  
  // required string agentType = 2;
  inline bool has_agenttype() const;
  inline void clear_agenttype();
  static const int kAgentTypeFieldNumber = 2;
  inline const ::std::string& agenttype() const;
  inline void set_agenttype(const ::std::string& value);
  inline void set_agenttype(const char* value);
  inline void set_agenttype(const char* value, size_t size);
  inline ::std::string* mutable_agenttype();
  inline ::std::string* release_agenttype();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.NewVersion)
 private:
  inline void set_has_agentversionno();
  inline void clear_has_agentversionno();
  inline void set_has_agenttype();
  inline void clear_has_agenttype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agenttype_;
  ::google::protobuf::int32 agentversionno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static NewVersion* default_instance_;
};
// -------------------------------------------------------------------

class NewVersionResponse : public ::google::protobuf::Message {
 public:
  NewVersionResponse();
  virtual ~NewVersionResponse();
  
  NewVersionResponse(const NewVersionResponse& from);
  
  inline NewVersionResponse& operator=(const NewVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewVersionResponse& default_instance();
  
  void Swap(NewVersionResponse* other);
  
  // implements Message ----------------------------------------------
  
  NewVersionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewVersionResponse& from);
  void MergeFrom(const NewVersionResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // optional string downloadURL = 2;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadURLFieldNumber = 2;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // optional bytes update = 3;
  inline bool has_update() const;
  inline void clear_update();
  static const int kUpdateFieldNumber = 3;
  inline const ::std::string& update() const;
  inline void set_update(const ::std::string& value);
  inline void set_update(const char* value);
  inline void set_update(const void* value, size_t size);
  inline ::std::string* mutable_update();
  inline ::std::string* release_update();
  
  // required int32 versionNo = 4;
  inline bool has_versionno() const;
  inline void clear_versionno();
  static const int kVersionNoFieldNumber = 4;
  inline ::google::protobuf::int32 versionno() const;
  inline void set_versionno(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.NewVersionResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_update();
  inline void clear_has_update();
  inline void set_has_versionno();
  inline void clear_has_versionno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::std::string* downloadurl_;
  ::std::string* update_;
  ::google::protobuf::int32 versionno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static NewVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class NewTests : public ::google::protobuf::Message {
 public:
  NewTests();
  virtual ~NewTests();
  
  NewTests(const NewTests& from);
  
  inline NewTests& operator=(const NewTests& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewTests& default_instance();
  
  void Swap(NewTests* other);
  
  // implements Message ----------------------------------------------
  
  NewTests* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewTests& from);
  void MergeFrom(const NewTests& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 currentTestVersionNo = 1;
  inline bool has_currenttestversionno() const;
  inline void clear_currenttestversionno();
  static const int kCurrentTestVersionNoFieldNumber = 1;
  inline ::google::protobuf::int32 currenttestversionno() const;
  inline void set_currenttestversionno(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.NewTests)
 private:
  inline void set_has_currenttestversionno();
  inline void clear_has_currenttestversionno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 currenttestversionno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static NewTests* default_instance_;
};
// -------------------------------------------------------------------

class Website : public ::google::protobuf::Message {
 public:
  Website();
  virtual ~Website();
  
  Website(const Website& from);
  
  inline Website& operator=(const Website& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Website& default_instance();
  
  void Swap(Website* other);
  
  // implements Message ----------------------------------------------
  
  Website* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Website& from);
  void MergeFrom(const Website& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Website)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Website* default_instance_;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message {
 public:
  Service();
  virtual ~Service();
  
  Service(const Service& from);
  
  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();
  
  void Swap(Service* other);
  
  // implements Message ----------------------------------------------
  
  Service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Service)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_ip();
  inline void clear_has_ip();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::Message {
 public:
  Test();
  virtual ~Test();
  
  Test(const Test& from);
  
  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Test& default_instance();
  
  void Swap(Test* other);
  
  // implements Message ----------------------------------------------
  
  Test* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string testID = 1;
  inline bool has_testid() const;
  inline void clear_testid();
  static const int kTestIDFieldNumber = 1;
  inline const ::std::string& testid() const;
  inline void set_testid(const ::std::string& value);
  inline void set_testid(const char* value);
  inline void set_testid(const char* value, size_t size);
  inline ::std::string* mutable_testid();
  inline ::std::string* release_testid();
  
  // optional .org.umit.icm.mobile.proto.Website website = 2;
  inline bool has_website() const;
  inline void clear_website();
  static const int kWebsiteFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::Website& website() const;
  inline ::org::umit::icm::mobile::proto::Website* mutable_website();
  inline ::org::umit::icm::mobile::proto::Website* release_website();
  
  // optional .org.umit.icm.mobile.proto.Service service = 3;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 3;
  inline const ::org::umit::icm::mobile::proto::Service& service() const;
  inline ::org::umit::icm::mobile::proto::Service* mutable_service();
  inline ::org::umit::icm::mobile::proto::Service* release_service();
  
  // optional int64 executeAtTimeUTC = 4;
  inline bool has_executeattimeutc() const;
  inline void clear_executeattimeutc();
  static const int kExecuteAtTimeUTCFieldNumber = 4;
  inline ::google::protobuf::int64 executeattimeutc() const;
  inline void set_executeattimeutc(::google::protobuf::int64 value);
  
  // required int32 testType = 5;
  inline bool has_testtype() const;
  inline void clear_testtype();
  static const int kTestTypeFieldNumber = 5;
  inline ::google::protobuf::int32 testtype() const;
  inline void set_testtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.Test)
 private:
  inline void set_has_testid();
  inline void clear_has_testid();
  inline void set_has_website();
  inline void clear_has_website();
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_executeattimeutc();
  inline void clear_has_executeattimeutc();
  inline void set_has_testtype();
  inline void clear_has_testtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* testid_;
  ::org::umit::icm::mobile::proto::Website* website_;
  ::org::umit::icm::mobile::proto::Service* service_;
  ::google::protobuf::int64 executeattimeutc_;
  ::google::protobuf::int32 testtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// -------------------------------------------------------------------

class NewTestsResponse : public ::google::protobuf::Message {
 public:
  NewTestsResponse();
  virtual ~NewTestsResponse();
  
  NewTestsResponse(const NewTestsResponse& from);
  
  inline NewTestsResponse& operator=(const NewTestsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewTestsResponse& default_instance();
  
  void Swap(NewTestsResponse* other);
  
  // implements Message ----------------------------------------------
  
  NewTestsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewTestsResponse& from);
  void MergeFrom(const NewTestsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  inline int tests_size() const;
  inline void clear_tests();
  static const int kTestsFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::Test& tests(int index) const;
  inline ::org::umit::icm::mobile::proto::Test* mutable_tests(int index);
  inline ::org::umit::icm::mobile::proto::Test* add_tests();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >&
      tests() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >*
      mutable_tests();
  
  // required int32 testVersionNo = 3;
  inline bool has_testversionno() const;
  inline void clear_testversionno();
  static const int kTestVersionNoFieldNumber = 3;
  inline ::google::protobuf::int32 testversionno() const;
  inline void set_testversionno(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.NewTestsResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_testversionno();
  inline void clear_has_testversionno();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test > tests_;
  ::google::protobuf::int32 testversionno_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static NewTestsResponse* default_instance_;
};
// -------------------------------------------------------------------

class AssignTask : public ::google::protobuf::Message {
 public:
  AssignTask();
  virtual ~AssignTask();
  
  AssignTask(const AssignTask& from);
  
  inline AssignTask& operator=(const AssignTask& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignTask& default_instance();
  
  void Swap(AssignTask* other);
  
  // implements Message ----------------------------------------------
  
  AssignTask* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignTask& from);
  void MergeFrom(const AssignTask& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::RequestHeader& header() const;
  inline ::org::umit::icm::mobile::proto::RequestHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::RequestHeader* release_header();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AssignTask)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::RequestHeader* header_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AssignTask* default_instance_;
};
// -------------------------------------------------------------------

class AssignTaskResponse : public ::google::protobuf::Message {
 public:
  AssignTaskResponse();
  virtual ~AssignTaskResponse();
  
  AssignTaskResponse(const AssignTaskResponse& from);
  
  inline AssignTaskResponse& operator=(const AssignTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignTaskResponse& default_instance();
  
  void Swap(AssignTaskResponse* other);
  
  // implements Message ----------------------------------------------
  
  AssignTaskResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssignTaskResponse& from);
  void MergeFrom(const AssignTaskResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.Test tests = 2;
  inline int tests_size() const;
  inline void clear_tests();
  static const int kTestsFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::Test& tests(int index) const;
  inline ::org::umit::icm::mobile::proto::Test* mutable_tests(int index);
  inline ::org::umit::icm::mobile::proto::Test* add_tests();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >&
      tests() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >*
      mutable_tests();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AssignTaskResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test > tests_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AssignTaskResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeToSuper : public ::google::protobuf::Message {
 public:
  UpgradeToSuper();
  virtual ~UpgradeToSuper();
  
  UpgradeToSuper(const UpgradeToSuper& from);
  
  inline UpgradeToSuper& operator=(const UpgradeToSuper& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeToSuper& default_instance();
  
  void Swap(UpgradeToSuper* other);
  
  // implements Message ----------------------------------------------
  
  UpgradeToSuper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeToSuper& from);
  void MergeFrom(const UpgradeToSuper& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.RequestHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::RequestHeader& header() const;
  inline ::org::umit::icm::mobile::proto::RequestHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::RequestHeader* release_header();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.UpgradeToSuper)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::RequestHeader* header_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static UpgradeToSuper* default_instance_;
};
// -------------------------------------------------------------------

class UpgradeToSuperResponse : public ::google::protobuf::Message {
 public:
  UpgradeToSuperResponse();
  virtual ~UpgradeToSuperResponse();
  
  UpgradeToSuperResponse(const UpgradeToSuperResponse& from);
  
  inline UpgradeToSuperResponse& operator=(const UpgradeToSuperResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeToSuperResponse& default_instance();
  
  void Swap(UpgradeToSuperResponse* other);
  
  // implements Message ----------------------------------------------
  
  UpgradeToSuperResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeToSuperResponse& from);
  void MergeFrom(const UpgradeToSuperResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // required string newToken = 2;
  inline bool has_newtoken() const;
  inline void clear_newtoken();
  static const int kNewTokenFieldNumber = 2;
  inline const ::std::string& newtoken() const;
  inline void set_newtoken(const ::std::string& value);
  inline void set_newtoken(const char* value);
  inline void set_newtoken(const char* value, size_t size);
  inline ::std::string* mutable_newtoken();
  inline ::std::string* release_newtoken();
  
  // required .org.umit.icm.mobile.proto.RSAKey newPrivateKey = 3;
  inline bool has_newprivatekey() const;
  inline void clear_newprivatekey();
  static const int kNewPrivateKeyFieldNumber = 3;
  inline const ::org::umit::icm::mobile::proto::RSAKey& newprivatekey() const;
  inline ::org::umit::icm::mobile::proto::RSAKey* mutable_newprivatekey();
  inline ::org::umit::icm::mobile::proto::RSAKey* release_newprivatekey();
  
  // required .org.umit.icm.mobile.proto.RSAKey newPublicKey = 4;
  inline bool has_newpublickey() const;
  inline void clear_newpublickey();
  static const int kNewPublicKeyFieldNumber = 4;
  inline const ::org::umit::icm::mobile::proto::RSAKey& newpublickey() const;
  inline ::org::umit::icm::mobile::proto::RSAKey* mutable_newpublickey();
  inline ::org::umit::icm::mobile::proto::RSAKey* release_newpublickey();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.UpgradeToSuperResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_newtoken();
  inline void clear_has_newtoken();
  inline void set_has_newprivatekey();
  inline void clear_has_newprivatekey();
  inline void set_has_newpublickey();
  inline void clear_has_newpublickey();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::std::string* newtoken_;
  ::org::umit::icm::mobile::proto::RSAKey* newprivatekey_;
  ::org::umit::icm::mobile::proto::RSAKey* newpublickey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static UpgradeToSuperResponse* default_instance_;
};
// -------------------------------------------------------------------

class WebsiteSuggestion : public ::google::protobuf::Message {
 public:
  WebsiteSuggestion();
  virtual ~WebsiteSuggestion();
  
  WebsiteSuggestion(const WebsiteSuggestion& from);
  
  inline WebsiteSuggestion& operator=(const WebsiteSuggestion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WebsiteSuggestion& default_instance();
  
  void Swap(WebsiteSuggestion* other);
  
  // implements Message ----------------------------------------------
  
  WebsiteSuggestion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WebsiteSuggestion& from);
  void MergeFrom(const WebsiteSuggestion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string websiteURL = 1;
  inline bool has_websiteurl() const;
  inline void clear_websiteurl();
  static const int kWebsiteURLFieldNumber = 1;
  inline const ::std::string& websiteurl() const;
  inline void set_websiteurl(const ::std::string& value);
  inline void set_websiteurl(const char* value);
  inline void set_websiteurl(const char* value, size_t size);
  inline ::std::string* mutable_websiteurl();
  inline ::std::string* release_websiteurl();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.WebsiteSuggestion)
 private:
  inline void set_has_websiteurl();
  inline void clear_has_websiteurl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* websiteurl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static WebsiteSuggestion* default_instance_;
};
// -------------------------------------------------------------------

class ServiceSuggestion : public ::google::protobuf::Message {
 public:
  ServiceSuggestion();
  virtual ~ServiceSuggestion();
  
  ServiceSuggestion(const ServiceSuggestion& from);
  
  inline ServiceSuggestion& operator=(const ServiceSuggestion& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceSuggestion& default_instance();
  
  void Swap(ServiceSuggestion* other);
  
  // implements Message ----------------------------------------------
  
  ServiceSuggestion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceSuggestion& from);
  void MergeFrom(const ServiceSuggestion& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string serviceName = 1;
  inline bool has_servicename() const;
  inline void clear_servicename();
  static const int kServiceNameFieldNumber = 1;
  inline const ::std::string& servicename() const;
  inline void set_servicename(const ::std::string& value);
  inline void set_servicename(const char* value);
  inline void set_servicename(const char* value, size_t size);
  inline ::std::string* mutable_servicename();
  inline ::std::string* release_servicename();
  
  // required string hostName = 2;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostNameFieldNumber = 2;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  
  // required string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  
  // required int64 port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline ::google::protobuf::int64 port() const;
  inline void set_port(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ServiceSuggestion)
 private:
  inline void set_has_servicename();
  inline void clear_has_servicename();
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* servicename_;
  ::std::string* hostname_;
  ::std::string* ip_;
  ::google::protobuf::int64 port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ServiceSuggestion* default_instance_;
};
// -------------------------------------------------------------------

class TestSuggestionResponse : public ::google::protobuf::Message {
 public:
  TestSuggestionResponse();
  virtual ~TestSuggestionResponse();
  
  TestSuggestionResponse(const TestSuggestionResponse& from);
  
  inline TestSuggestionResponse& operator=(const TestSuggestionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestSuggestionResponse& default_instance();
  
  void Swap(TestSuggestionResponse* other);
  
  // implements Message ----------------------------------------------
  
  TestSuggestionResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestSuggestionResponse& from);
  void MergeFrom(const TestSuggestionResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.TestSuggestionResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static TestSuggestionResponse* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticatePeer : public ::google::protobuf::Message {
 public:
  AuthenticatePeer();
  virtual ~AuthenticatePeer();
  
  AuthenticatePeer(const AuthenticatePeer& from);
  
  inline AuthenticatePeer& operator=(const AuthenticatePeer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticatePeer& default_instance();
  
  void Swap(AuthenticatePeer* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticatePeer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticatePeer& from);
  void MergeFrom(const AuthenticatePeer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 agentType = 1;
  inline bool has_agenttype() const;
  inline void clear_agenttype();
  static const int kAgentTypeFieldNumber = 1;
  inline ::google::protobuf::int32 agenttype() const;
  inline void set_agenttype(::google::protobuf::int32 value);
  
  // required string agentID = 2;
  inline bool has_agentid() const;
  inline void clear_agentid();
  static const int kAgentIDFieldNumber = 2;
  inline const ::std::string& agentid() const;
  inline void set_agentid(const ::std::string& value);
  inline void set_agentid(const char* value);
  inline void set_agentid(const char* value, size_t size);
  inline ::std::string* mutable_agentid();
  inline ::std::string* release_agentid();
  
  // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 3;
  inline bool has_cipheredpublickey() const;
  inline void clear_cipheredpublickey();
  static const int kCipheredPublicKeyFieldNumber = 3;
  inline const ::org::umit::icm::mobile::proto::RSAKey& cipheredpublickey() const;
  inline ::org::umit::icm::mobile::proto::RSAKey* mutable_cipheredpublickey();
  inline ::org::umit::icm::mobile::proto::RSAKey* release_cipheredpublickey();
  
  // optional int32 agentPort = 4;
  inline bool has_agentport() const;
  inline void clear_agentport();
  static const int kAgentPortFieldNumber = 4;
  inline ::google::protobuf::int32 agentport() const;
  inline void set_agentport(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AuthenticatePeer)
 private:
  inline void set_has_agenttype();
  inline void clear_has_agenttype();
  inline void set_has_agentid();
  inline void clear_has_agentid();
  inline void set_has_cipheredpublickey();
  inline void clear_has_cipheredpublickey();
  inline void set_has_agentport();
  inline void clear_has_agentport();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agentid_;
  ::google::protobuf::int32 agenttype_;
  ::google::protobuf::int32 agentport_;
  ::org::umit::icm::mobile::proto::RSAKey* cipheredpublickey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AuthenticatePeer* default_instance_;
};
// -------------------------------------------------------------------

class AuthenticatePeerResponse : public ::google::protobuf::Message {
 public:
  AuthenticatePeerResponse();
  virtual ~AuthenticatePeerResponse();
  
  AuthenticatePeerResponse(const AuthenticatePeerResponse& from);
  
  inline AuthenticatePeerResponse& operator=(const AuthenticatePeerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthenticatePeerResponse& default_instance();
  
  void Swap(AuthenticatePeerResponse* other);
  
  // implements Message ----------------------------------------------
  
  AuthenticatePeerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthenticatePeerResponse& from);
  void MergeFrom(const AuthenticatePeerResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 1;
  inline bool has_cipheredpublickey() const;
  inline void clear_cipheredpublickey();
  static const int kCipheredPublicKeyFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::RSAKey& cipheredpublickey() const;
  inline ::org::umit::icm::mobile::proto::RSAKey* mutable_cipheredpublickey();
  inline ::org::umit::icm::mobile::proto::RSAKey* release_cipheredpublickey();
  
  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AuthenticatePeerResponse)
 private:
  inline void set_has_cipheredpublickey();
  inline void clear_has_cipheredpublickey();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::RSAKey* cipheredpublickey_;
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AuthenticatePeerResponse* default_instance_;
};
// -------------------------------------------------------------------

class P2PGetSuperPeerList : public ::google::protobuf::Message {
 public:
  P2PGetSuperPeerList();
  virtual ~P2PGetSuperPeerList();
  
  P2PGetSuperPeerList(const P2PGetSuperPeerList& from);
  
  inline P2PGetSuperPeerList& operator=(const P2PGetSuperPeerList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PGetSuperPeerList& default_instance();
  
  void Swap(P2PGetSuperPeerList* other);
  
  // implements Message ----------------------------------------------
  
  P2PGetSuperPeerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P2PGetSuperPeerList& from);
  void MergeFrom(const P2PGetSuperPeerList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.P2PGetSuperPeerList)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static P2PGetSuperPeerList* default_instance_;
};
// -------------------------------------------------------------------

class P2PGetSuperPeerListResponse : public ::google::protobuf::Message {
 public:
  P2PGetSuperPeerListResponse();
  virtual ~P2PGetSuperPeerListResponse();
  
  P2PGetSuperPeerListResponse(const P2PGetSuperPeerListResponse& from);
  
  inline P2PGetSuperPeerListResponse& operator=(const P2PGetSuperPeerListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PGetSuperPeerListResponse& default_instance();
  
  void Swap(P2PGetSuperPeerListResponse* other);
  
  // implements Message ----------------------------------------------
  
  P2PGetSuperPeerListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P2PGetSuperPeerListResponse& from);
  void MergeFrom(const P2PGetSuperPeerListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  inline int peers_size() const;
  inline void clear_peers();
  static const int kPeersFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::AgentData& peers(int index) const;
  inline ::org::umit::icm::mobile::proto::AgentData* mutable_peers(int index);
  inline ::org::umit::icm::mobile::proto::AgentData* add_peers();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
      peers() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
      mutable_peers();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.P2PGetSuperPeerListResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData > peers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static P2PGetSuperPeerListResponse* default_instance_;
};
// -------------------------------------------------------------------

class P2PGetPeerList : public ::google::protobuf::Message {
 public:
  P2PGetPeerList();
  virtual ~P2PGetPeerList();
  
  P2PGetPeerList(const P2PGetPeerList& from);
  
  inline P2PGetPeerList& operator=(const P2PGetPeerList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PGetPeerList& default_instance();
  
  void Swap(P2PGetPeerList* other);
  
  // implements Message ----------------------------------------------
  
  P2PGetPeerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P2PGetPeerList& from);
  void MergeFrom(const P2PGetPeerList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.P2PGetPeerList)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static P2PGetPeerList* default_instance_;
};
// -------------------------------------------------------------------

class P2PGetPeerListResponse : public ::google::protobuf::Message {
 public:
  P2PGetPeerListResponse();
  virtual ~P2PGetPeerListResponse();
  
  P2PGetPeerListResponse(const P2PGetPeerListResponse& from);
  
  inline P2PGetPeerListResponse& operator=(const P2PGetPeerListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const P2PGetPeerListResponse& default_instance();
  
  void Swap(P2PGetPeerListResponse* other);
  
  // implements Message ----------------------------------------------
  
  P2PGetPeerListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const P2PGetPeerListResponse& from);
  void MergeFrom(const P2PGetPeerListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
  inline int peers_size() const;
  inline void clear_peers();
  static const int kPeersFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::AgentData& peers(int index) const;
  inline ::org::umit::icm::mobile::proto::AgentData* mutable_peers(int index);
  inline ::org::umit::icm::mobile::proto::AgentData* add_peers();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
      peers() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
      mutable_peers();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.P2PGetPeerListResponse)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData > peers_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static P2PGetPeerListResponse* default_instance_;
};
// -------------------------------------------------------------------

class AgentUpdate : public ::google::protobuf::Message {
 public:
  AgentUpdate();
  virtual ~AgentUpdate();
  
  AgentUpdate(const AgentUpdate& from);
  
  inline AgentUpdate& operator=(const AgentUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentUpdate& default_instance();
  
  void Swap(AgentUpdate* other);
  
  // implements Message ----------------------------------------------
  
  AgentUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentUpdate& from);
  void MergeFrom(const AgentUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required string downloadURL = 2;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadURLFieldNumber = 2;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // optional int32 checkCode = 3;
  inline bool has_checkcode() const;
  inline void clear_checkcode();
  static const int kCheckCodeFieldNumber = 3;
  inline ::google::protobuf::int32 checkcode() const;
  inline void set_checkcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AgentUpdate)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_checkcode();
  inline void clear_has_checkcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::std::string* downloadurl_;
  ::google::protobuf::int32 checkcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AgentUpdate* default_instance_;
};
// -------------------------------------------------------------------

class AgentUpdateResponse : public ::google::protobuf::Message {
 public:
  AgentUpdateResponse();
  virtual ~AgentUpdateResponse();
  
  AgentUpdateResponse(const AgentUpdateResponse& from);
  
  inline AgentUpdateResponse& operator=(const AgentUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AgentUpdateResponse& default_instance();
  
  void Swap(AgentUpdateResponse* other);
  
  // implements Message ----------------------------------------------
  
  AgentUpdateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AgentUpdateResponse& from);
  void MergeFrom(const AgentUpdateResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required string result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const char* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.AgentUpdateResponse)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::std::string* result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static AgentUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class TestModuleUpdate : public ::google::protobuf::Message {
 public:
  TestModuleUpdate();
  virtual ~TestModuleUpdate();
  
  TestModuleUpdate(const TestModuleUpdate& from);
  
  inline TestModuleUpdate& operator=(const TestModuleUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestModuleUpdate& default_instance();
  
  void Swap(TestModuleUpdate* other);
  
  // implements Message ----------------------------------------------
  
  TestModuleUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestModuleUpdate& from);
  void MergeFrom(const TestModuleUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required string downloadURL = 2;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadURLFieldNumber = 2;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  
  // optional int32 checkCode = 3;
  inline bool has_checkcode() const;
  inline void clear_checkcode();
  static const int kCheckCodeFieldNumber = 3;
  inline ::google::protobuf::int32 checkcode() const;
  inline void set_checkcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.TestModuleUpdate)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_checkcode();
  inline void clear_has_checkcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::std::string* downloadurl_;
  ::google::protobuf::int32 checkcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static TestModuleUpdate* default_instance_;
};
// -------------------------------------------------------------------

class TestModuleUpdateResponse : public ::google::protobuf::Message {
 public:
  TestModuleUpdateResponse();
  virtual ~TestModuleUpdateResponse();
  
  TestModuleUpdateResponse(const TestModuleUpdateResponse& from);
  
  inline TestModuleUpdateResponse& operator=(const TestModuleUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TestModuleUpdateResponse& default_instance();
  
  void Swap(TestModuleUpdateResponse* other);
  
  // implements Message ----------------------------------------------
  
  TestModuleUpdateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestModuleUpdateResponse& from);
  void MergeFrom(const TestModuleUpdateResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  
  // required string result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::std::string& result() const;
  inline void set_result(const ::std::string& value);
  inline void set_result(const char* value);
  inline void set_result(const char* value, size_t size);
  inline ::std::string* mutable_result();
  inline ::std::string* release_result();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.TestModuleUpdateResponse)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* version_;
  ::std::string* result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static TestModuleUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class ForwardingMessage : public ::google::protobuf::Message {
 public:
  ForwardingMessage();
  virtual ~ForwardingMessage();
  
  ForwardingMessage(const ForwardingMessage& from);
  
  inline ForwardingMessage& operator=(const ForwardingMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForwardingMessage& default_instance();
  
  void Swap(ForwardingMessage* other);
  
  // implements Message ----------------------------------------------
  
  ForwardingMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForwardingMessage& from);
  void MergeFrom(const ForwardingMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 destination = 1;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 1;
  inline ::google::protobuf::int64 destination() const;
  inline void set_destination(::google::protobuf::int64 value);
  
  // required string identifier = 2;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 2;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // required string encodedMessage = 3;
  inline bool has_encodedmessage() const;
  inline void clear_encodedmessage();
  static const int kEncodedMessageFieldNumber = 3;
  inline const ::std::string& encodedmessage() const;
  inline void set_encodedmessage(const ::std::string& value);
  inline void set_encodedmessage(const char* value);
  inline void set_encodedmessage(const char* value, size_t size);
  inline ::std::string* mutable_encodedmessage();
  inline ::std::string* release_encodedmessage();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ForwardingMessage)
 private:
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_encodedmessage();
  inline void clear_has_encodedmessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 destination_;
  ::std::string* identifier_;
  ::std::string* encodedmessage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ForwardingMessage* default_instance_;
};
// -------------------------------------------------------------------

class ForwardingMessageResponse : public ::google::protobuf::Message {
 public:
  ForwardingMessageResponse();
  virtual ~ForwardingMessageResponse();
  
  ForwardingMessageResponse(const ForwardingMessageResponse& from);
  
  inline ForwardingMessageResponse& operator=(const ForwardingMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForwardingMessageResponse& default_instance();
  
  void Swap(ForwardingMessageResponse* other);
  
  // implements Message ----------------------------------------------
  
  ForwardingMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ForwardingMessageResponse& from);
  void MergeFrom(const ForwardingMessageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::std::string& identifier() const;
  inline void set_identifier(const ::std::string& value);
  inline void set_identifier(const char* value);
  inline void set_identifier(const char* value, size_t size);
  inline ::std::string* mutable_identifier();
  inline ::std::string* release_identifier();
  
  // required string encodedMessage = 2;
  inline bool has_encodedmessage() const;
  inline void clear_encodedmessage();
  static const int kEncodedMessageFieldNumber = 2;
  inline const ::std::string& encodedmessage() const;
  inline void set_encodedmessage(const ::std::string& value);
  inline void set_encodedmessage(const char* value);
  inline void set_encodedmessage(const char* value, size_t size);
  inline ::std::string* mutable_encodedmessage();
  inline ::std::string* release_encodedmessage();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.ForwardingMessageResponse)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_encodedmessage();
  inline void clear_has_encodedmessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* identifier_;
  ::std::string* encodedmessage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static ForwardingMessageResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginCredentials : public ::google::protobuf::Message {
 public:
  LoginCredentials();
  virtual ~LoginCredentials();
  
  LoginCredentials(const LoginCredentials& from);
  
  inline LoginCredentials& operator=(const LoginCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginCredentials& default_instance();
  
  void Swap(LoginCredentials* other);
  
  // implements Message ----------------------------------------------
  
  LoginCredentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginCredentials& from);
  void MergeFrom(const LoginCredentials& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.LoginCredentials)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* username_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static LoginCredentials* default_instance_;
};
// -------------------------------------------------------------------

class GetNetlist : public ::google::protobuf::Message {
 public:
  GetNetlist();
  virtual ~GetNetlist();
  
  GetNetlist(const GetNetlist& from);
  
  inline GetNetlist& operator=(const GetNetlist& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNetlist& default_instance();
  
  void Swap(GetNetlist* other);
  
  // implements Message ----------------------------------------------
  
  GetNetlist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNetlist& from);
  void MergeFrom(const GetNetlist& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 list = 1;
  inline bool has_list() const;
  inline void clear_list();
  static const int kListFieldNumber = 1;
  inline ::google::protobuf::int32 list() const;
  inline void set_list(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetNetlist)
 private:
  inline void set_has_list();
  inline void clear_has_list();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 list_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetNetlist* default_instance_;
};
// -------------------------------------------------------------------

class NetworkData : public ::google::protobuf::Message {
 public:
  NetworkData();
  virtual ~NetworkData();
  
  NetworkData(const NetworkData& from);
  
  inline NetworkData& operator=(const NetworkData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NetworkData& default_instance();
  
  void Swap(NetworkData* other);
  
  // implements Message ----------------------------------------------
  
  NetworkData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetworkData& from);
  void MergeFrom(const NetworkData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 start_ip = 1;
  inline bool has_start_ip() const;
  inline void clear_start_ip();
  static const int kStartIpFieldNumber = 1;
  inline ::google::protobuf::int32 start_ip() const;
  inline void set_start_ip(::google::protobuf::int32 value);
  
  // required int32 end_ip = 2;
  inline bool has_end_ip() const;
  inline void clear_end_ip();
  static const int kEndIpFieldNumber = 2;
  inline ::google::protobuf::int32 end_ip() const;
  inline void set_end_ip(::google::protobuf::int32 value);
  
  // optional int32 nodes_count_network = 3;
  inline bool has_nodes_count_network() const;
  inline void clear_nodes_count_network();
  static const int kNodesCountNetworkFieldNumber = 3;
  inline ::google::protobuf::int32 nodes_count_network() const;
  inline void set_nodes_count_network(::google::protobuf::int32 value);
  
  // repeated .org.umit.icm.mobile.proto.AgentData nodes = 4;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 4;
  inline const ::org::umit::icm::mobile::proto::AgentData& nodes(int index) const;
  inline ::org::umit::icm::mobile::proto::AgentData* mutable_nodes(int index);
  inline ::org::umit::icm::mobile::proto::AgentData* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
      mutable_nodes();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.NetworkData)
 private:
  inline void set_has_start_ip();
  inline void clear_has_start_ip();
  inline void set_has_end_ip();
  inline void clear_has_end_ip();
  inline void set_has_nodes_count_network();
  inline void clear_has_nodes_count_network();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 start_ip_;
  ::google::protobuf::int32 end_ip_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData > nodes_;
  ::google::protobuf::int32 nodes_count_network_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static NetworkData* default_instance_;
};
// -------------------------------------------------------------------

class BannedNetworkData : public ::google::protobuf::Message {
 public:
  BannedNetworkData();
  virtual ~BannedNetworkData();
  
  BannedNetworkData(const BannedNetworkData& from);
  
  inline BannedNetworkData& operator=(const BannedNetworkData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BannedNetworkData& default_instance();
  
  void Swap(BannedNetworkData* other);
  
  // implements Message ----------------------------------------------
  
  BannedNetworkData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BannedNetworkData& from);
  void MergeFrom(const BannedNetworkData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 start_ip = 1;
  inline bool has_start_ip() const;
  inline void clear_start_ip();
  static const int kStartIpFieldNumber = 1;
  inline ::google::protobuf::int32 start_ip() const;
  inline void set_start_ip(::google::protobuf::int32 value);
  
  // required int32 end_ip = 2;
  inline bool has_end_ip() const;
  inline void clear_end_ip();
  static const int kEndIpFieldNumber = 2;
  inline ::google::protobuf::int32 end_ip() const;
  inline void set_end_ip(::google::protobuf::int32 value);
  
  // optional int32 nodes_count = 3;
  inline bool has_nodes_count() const;
  inline void clear_nodes_count();
  static const int kNodesCountFieldNumber = 3;
  inline ::google::protobuf::int32 nodes_count() const;
  inline void set_nodes_count(::google::protobuf::int32 value);
  
  // required int32 flags = 4;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 4;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.BannedNetworkData)
 private:
  inline void set_has_start_ip();
  inline void clear_has_start_ip();
  inline void set_has_end_ip();
  inline void clear_has_end_ip();
  inline void set_has_nodes_count();
  inline void clear_has_nodes_count();
  inline void set_has_flags();
  inline void clear_has_flags();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 start_ip_;
  ::google::protobuf::int32 end_ip_;
  ::google::protobuf::int32 nodes_count_;
  ::google::protobuf::int32 flags_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static BannedNetworkData* default_instance_;
};
// -------------------------------------------------------------------

class GetNetlistResponse : public ::google::protobuf::Message {
 public:
  GetNetlistResponse();
  virtual ~GetNetlistResponse();
  
  GetNetlistResponse(const GetNetlistResponse& from);
  
  inline GetNetlistResponse& operator=(const GetNetlistResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetNetlistResponse& default_instance();
  
  void Swap(GetNetlistResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetNetlistResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetNetlistResponse& from);
  void MergeFrom(const GetNetlistResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.NetworkData networks = 2;
  inline int networks_size() const;
  inline void clear_networks();
  static const int kNetworksFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::NetworkData& networks(int index) const;
  inline ::org::umit::icm::mobile::proto::NetworkData* mutable_networks(int index);
  inline ::org::umit::icm::mobile::proto::NetworkData* add_networks();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::NetworkData >&
      networks() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::NetworkData >*
      mutable_networks();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetNetlistResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::NetworkData > networks_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetNetlistResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetBanlist : public ::google::protobuf::Message {
 public:
  GetBanlist();
  virtual ~GetBanlist();
  
  GetBanlist(const GetBanlist& from);
  
  inline GetBanlist& operator=(const GetBanlist& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBanlist& default_instance();
  
  void Swap(GetBanlist* other);
  
  // implements Message ----------------------------------------------
  
  GetBanlist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBanlist& from);
  void MergeFrom(const GetBanlist& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetBanlist)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetBanlist* default_instance_;
};
// -------------------------------------------------------------------

class GetBanlistResponse : public ::google::protobuf::Message {
 public:
  GetBanlistResponse();
  virtual ~GetBanlistResponse();
  
  GetBanlistResponse(const GetBanlistResponse& from);
  
  inline GetBanlistResponse& operator=(const GetBanlistResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBanlistResponse& default_instance();
  
  void Swap(GetBanlistResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetBanlistResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBanlistResponse& from);
  void MergeFrom(const GetBanlistResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // required int32 nodes_count = 2;
  inline bool has_nodes_count() const;
  inline void clear_nodes_count();
  static const int kNodesCountFieldNumber = 2;
  inline ::google::protobuf::int32 nodes_count() const;
  inline void set_nodes_count(::google::protobuf::int32 value);
  
  // repeated string agent_ids = 3;
  inline int agent_ids_size() const;
  inline void clear_agent_ids();
  static const int kAgentIdsFieldNumber = 3;
  inline const ::std::string& agent_ids(int index) const;
  inline ::std::string* mutable_agent_ids(int index);
  inline void set_agent_ids(int index, const ::std::string& value);
  inline void set_agent_ids(int index, const char* value);
  inline void set_agent_ids(int index, const char* value, size_t size);
  inline ::std::string* add_agent_ids();
  inline void add_agent_ids(const ::std::string& value);
  inline void add_agent_ids(const char* value);
  inline void add_agent_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& agent_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_agent_ids();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetBanlistResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_nodes_count();
  inline void clear_has_nodes_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::std::string> agent_ids_;
  ::google::protobuf::int32 nodes_count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetBanlistResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetBannets : public ::google::protobuf::Message {
 public:
  GetBannets();
  virtual ~GetBannets();
  
  GetBannets(const GetBannets& from);
  
  inline GetBannets& operator=(const GetBannets& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBannets& default_instance();
  
  void Swap(GetBannets* other);
  
  // implements Message ----------------------------------------------
  
  GetBannets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBannets& from);
  void MergeFrom(const GetBannets& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetBannets)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetBannets* default_instance_;
};
// -------------------------------------------------------------------

class GetBannetsResponse : public ::google::protobuf::Message {
 public:
  GetBannetsResponse();
  virtual ~GetBannetsResponse();
  
  GetBannetsResponse(const GetBannetsResponse& from);
  
  inline GetBannetsResponse& operator=(const GetBannetsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBannetsResponse& default_instance();
  
  void Swap(GetBannetsResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetBannetsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBannetsResponse& from);
  void MergeFrom(const GetBannetsResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::org::umit::icm::mobile::proto::ResponseHeader& header() const;
  inline ::org::umit::icm::mobile::proto::ResponseHeader* mutable_header();
  inline ::org::umit::icm::mobile::proto::ResponseHeader* release_header();
  
  // repeated .org.umit.icm.mobile.proto.BannedNetworkData networks = 2;
  inline int networks_size() const;
  inline void clear_networks();
  static const int kNetworksFieldNumber = 2;
  inline const ::org::umit::icm::mobile::proto::BannedNetworkData& networks(int index) const;
  inline ::org::umit::icm::mobile::proto::BannedNetworkData* mutable_networks(int index);
  inline ::org::umit::icm::mobile::proto::BannedNetworkData* add_networks();
  inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::BannedNetworkData >&
      networks() const;
  inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::BannedNetworkData >*
      mutable_networks();
  
  // @@protoc_insertion_point(class_scope:org.umit.icm.mobile.proto.GetBannetsResponse)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::org::umit::icm::mobile::proto::ResponseHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::BannedNetworkData > networks_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();
  
  void InitAsDefaultInstance();
  static GetBannetsResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Trace

// required int32 hop = 1;
inline bool Trace::has_hop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trace::set_has_hop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trace::clear_has_hop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trace::clear_hop() {
  hop_ = 0;
  clear_has_hop();
}
inline ::google::protobuf::int32 Trace::hop() const {
  return hop_;
}
inline void Trace::set_hop(::google::protobuf::int32 value) {
  set_has_hop();
  hop_ = value;
}

// required string ip = 2;
inline bool Trace::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trace::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trace::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trace::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Trace::ip() const {
  return *ip_;
}
inline void Trace::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Trace::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Trace::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Trace::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Trace::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 packetsTiming = 3;
inline int Trace::packetstiming_size() const {
  return packetstiming_.size();
}
inline void Trace::clear_packetstiming() {
  packetstiming_.Clear();
}
inline ::google::protobuf::int32 Trace::packetstiming(int index) const {
  return packetstiming_.Get(index);
}
inline void Trace::set_packetstiming(int index, ::google::protobuf::int32 value) {
  packetstiming_.Set(index, value);
}
inline void Trace::add_packetstiming(::google::protobuf::int32 value) {
  packetstiming_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Trace::packetstiming() const {
  return packetstiming_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Trace::mutable_packetstiming() {
  return &packetstiming_;
}

// -------------------------------------------------------------------

// TraceRoute

// required string target = 1;
inline bool TraceRoute::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceRoute::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceRoute::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceRoute::clear_target() {
  if (target_ != &::google::protobuf::internal::kEmptyString) {
    target_->clear();
  }
  clear_has_target();
}
inline const ::std::string& TraceRoute::target() const {
  return *target_;
}
inline void TraceRoute::set_target(const ::std::string& value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TraceRoute::set_target(const char* value) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(value);
}
inline void TraceRoute::set_target(const char* value, size_t size) {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  target_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TraceRoute::mutable_target() {
  set_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    target_ = new ::std::string;
  }
  return target_;
}
inline ::std::string* TraceRoute::release_target() {
  clear_has_target();
  if (target_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_;
    target_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 hops = 2;
inline bool TraceRoute::has_hops() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceRoute::set_has_hops() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceRoute::clear_has_hops() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceRoute::clear_hops() {
  hops_ = 0;
  clear_has_hops();
}
inline ::google::protobuf::int32 TraceRoute::hops() const {
  return hops_;
}
inline void TraceRoute::set_hops(::google::protobuf::int32 value) {
  set_has_hops();
  hops_ = value;
}

// required int32 packetSize = 3;
inline bool TraceRoute::has_packetsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceRoute::set_has_packetsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceRoute::clear_has_packetsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceRoute::clear_packetsize() {
  packetsize_ = 0;
  clear_has_packetsize();
}
inline ::google::protobuf::int32 TraceRoute::packetsize() const {
  return packetsize_;
}
inline void TraceRoute::set_packetsize(::google::protobuf::int32 value) {
  set_has_packetsize();
  packetsize_ = value;
}

// repeated .org.umit.icm.mobile.proto.Trace traces = 4;
inline int TraceRoute::traces_size() const {
  return traces_.size();
}
inline void TraceRoute::clear_traces() {
  traces_.Clear();
}
inline const ::org::umit::icm::mobile::proto::Trace& TraceRoute::traces(int index) const {
  return traces_.Get(index);
}
inline ::org::umit::icm::mobile::proto::Trace* TraceRoute::mutable_traces(int index) {
  return traces_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::Trace* TraceRoute::add_traces() {
  return traces_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Trace >&
TraceRoute::traces() const {
  return traces_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Trace >*
TraceRoute::mutable_traces() {
  return &traces_;
}

// -------------------------------------------------------------------

// ICMReport

// optional string reportID = 1;
inline bool ICMReport::has_reportid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ICMReport::set_has_reportid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ICMReport::clear_has_reportid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ICMReport::clear_reportid() {
  if (reportid_ != &::google::protobuf::internal::kEmptyString) {
    reportid_->clear();
  }
  clear_has_reportid();
}
inline const ::std::string& ICMReport::reportid() const {
  return *reportid_;
}
inline void ICMReport::set_reportid(const ::std::string& value) {
  set_has_reportid();
  if (reportid_ == &::google::protobuf::internal::kEmptyString) {
    reportid_ = new ::std::string;
  }
  reportid_->assign(value);
}
inline void ICMReport::set_reportid(const char* value) {
  set_has_reportid();
  if (reportid_ == &::google::protobuf::internal::kEmptyString) {
    reportid_ = new ::std::string;
  }
  reportid_->assign(value);
}
inline void ICMReport::set_reportid(const char* value, size_t size) {
  set_has_reportid();
  if (reportid_ == &::google::protobuf::internal::kEmptyString) {
    reportid_ = new ::std::string;
  }
  reportid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICMReport::mutable_reportid() {
  set_has_reportid();
  if (reportid_ == &::google::protobuf::internal::kEmptyString) {
    reportid_ = new ::std::string;
  }
  return reportid_;
}
inline ::std::string* ICMReport::release_reportid() {
  clear_has_reportid();
  if (reportid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reportid_;
    reportid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string agentID = 2;
inline bool ICMReport::has_agentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ICMReport::set_has_agentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ICMReport::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ICMReport::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& ICMReport::agentid() const {
  return *agentid_;
}
inline void ICMReport::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void ICMReport::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void ICMReport::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICMReport::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* ICMReport::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 testID = 3;
inline bool ICMReport::has_testid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ICMReport::set_has_testid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ICMReport::clear_has_testid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ICMReport::clear_testid() {
  testid_ = GOOGLE_LONGLONG(0);
  clear_has_testid();
}
inline ::google::protobuf::int64 ICMReport::testid() const {
  return testid_;
}
inline void ICMReport::set_testid(::google::protobuf::int64 value) {
  set_has_testid();
  testid_ = value;
}

// required int32 timeZone = 4;
inline bool ICMReport::has_timezone() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ICMReport::set_has_timezone() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ICMReport::clear_has_timezone() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ICMReport::clear_timezone() {
  timezone_ = 0;
  clear_has_timezone();
}
inline ::google::protobuf::int32 ICMReport::timezone() const {
  return timezone_;
}
inline void ICMReport::set_timezone(::google::protobuf::int32 value) {
  set_has_timezone();
  timezone_ = value;
}

// required int64 timeUTC = 5;
inline bool ICMReport::has_timeutc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ICMReport::set_has_timeutc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ICMReport::clear_has_timeutc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ICMReport::clear_timeutc() {
  timeutc_ = GOOGLE_LONGLONG(0);
  clear_has_timeutc();
}
inline ::google::protobuf::int64 ICMReport::timeutc() const {
  return timeutc_;
}
inline void ICMReport::set_timeutc(::google::protobuf::int64 value) {
  set_has_timeutc();
  timeutc_ = value;
}

// repeated string passedNode = 6;
inline int ICMReport::passednode_size() const {
  return passednode_.size();
}
inline void ICMReport::clear_passednode() {
  passednode_.Clear();
}
inline const ::std::string& ICMReport::passednode(int index) const {
  return passednode_.Get(index);
}
inline ::std::string* ICMReport::mutable_passednode(int index) {
  return passednode_.Mutable(index);
}
inline void ICMReport::set_passednode(int index, const ::std::string& value) {
  passednode_.Mutable(index)->assign(value);
}
inline void ICMReport::set_passednode(int index, const char* value) {
  passednode_.Mutable(index)->assign(value);
}
inline void ICMReport::set_passednode(int index, const char* value, size_t size) {
  passednode_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ICMReport::add_passednode() {
  return passednode_.Add();
}
inline void ICMReport::add_passednode(const ::std::string& value) {
  passednode_.Add()->assign(value);
}
inline void ICMReport::add_passednode(const char* value) {
  passednode_.Add()->assign(value);
}
inline void ICMReport::add_passednode(const char* value, size_t size) {
  passednode_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ICMReport::passednode() const {
  return passednode_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ICMReport::mutable_passednode() {
  return &passednode_;
}

// optional .org.umit.icm.mobile.proto.TraceRoute traceroute = 7;
inline bool ICMReport::has_traceroute() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ICMReport::set_has_traceroute() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ICMReport::clear_has_traceroute() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ICMReport::clear_traceroute() {
  if (traceroute_ != NULL) traceroute_->::org::umit::icm::mobile::proto::TraceRoute::Clear();
  clear_has_traceroute();
}
inline const ::org::umit::icm::mobile::proto::TraceRoute& ICMReport::traceroute() const {
  return traceroute_ != NULL ? *traceroute_ : *default_instance_->traceroute_;
}
inline ::org::umit::icm::mobile::proto::TraceRoute* ICMReport::mutable_traceroute() {
  set_has_traceroute();
  if (traceroute_ == NULL) traceroute_ = new ::org::umit::icm::mobile::proto::TraceRoute;
  return traceroute_;
}
inline ::org::umit::icm::mobile::proto::TraceRoute* ICMReport::release_traceroute() {
  clear_has_traceroute();
  ::org::umit::icm::mobile::proto::TraceRoute* temp = traceroute_;
  traceroute_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// WebsiteReportDetail

// required string websiteURL = 1;
inline bool WebsiteReportDetail::has_websiteurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebsiteReportDetail::set_has_websiteurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebsiteReportDetail::clear_has_websiteurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebsiteReportDetail::clear_websiteurl() {
  if (websiteurl_ != &::google::protobuf::internal::kEmptyString) {
    websiteurl_->clear();
  }
  clear_has_websiteurl();
}
inline const ::std::string& WebsiteReportDetail::websiteurl() const {
  return *websiteurl_;
}
inline void WebsiteReportDetail::set_websiteurl(const ::std::string& value) {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  websiteurl_->assign(value);
}
inline void WebsiteReportDetail::set_websiteurl(const char* value) {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  websiteurl_->assign(value);
}
inline void WebsiteReportDetail::set_websiteurl(const char* value, size_t size) {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  websiteurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebsiteReportDetail::mutable_websiteurl() {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  return websiteurl_;
}
inline ::std::string* WebsiteReportDetail::release_websiteurl() {
  clear_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = websiteurl_;
    websiteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 statusCode = 2;
inline bool WebsiteReportDetail::has_statuscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebsiteReportDetail::set_has_statuscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebsiteReportDetail::clear_has_statuscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebsiteReportDetail::clear_statuscode() {
  statuscode_ = 0;
  clear_has_statuscode();
}
inline ::google::protobuf::int32 WebsiteReportDetail::statuscode() const {
  return statuscode_;
}
inline void WebsiteReportDetail::set_statuscode(::google::protobuf::int32 value) {
  set_has_statuscode();
  statuscode_ = value;
}

// optional int32 responseTime = 3;
inline bool WebsiteReportDetail::has_responsetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebsiteReportDetail::set_has_responsetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebsiteReportDetail::clear_has_responsetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebsiteReportDetail::clear_responsetime() {
  responsetime_ = 0;
  clear_has_responsetime();
}
inline ::google::protobuf::int32 WebsiteReportDetail::responsetime() const {
  return responsetime_;
}
inline void WebsiteReportDetail::set_responsetime(::google::protobuf::int32 value) {
  set_has_responsetime();
  responsetime_ = value;
}

// optional int32 bandwidth = 4;
inline bool WebsiteReportDetail::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WebsiteReportDetail::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WebsiteReportDetail::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WebsiteReportDetail::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline ::google::protobuf::int32 WebsiteReportDetail::bandwidth() const {
  return bandwidth_;
}
inline void WebsiteReportDetail::set_bandwidth(::google::protobuf::int32 value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// optional string redirectLink = 5;
inline bool WebsiteReportDetail::has_redirectlink() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WebsiteReportDetail::set_has_redirectlink() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WebsiteReportDetail::clear_has_redirectlink() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WebsiteReportDetail::clear_redirectlink() {
  if (redirectlink_ != &::google::protobuf::internal::kEmptyString) {
    redirectlink_->clear();
  }
  clear_has_redirectlink();
}
inline const ::std::string& WebsiteReportDetail::redirectlink() const {
  return *redirectlink_;
}
inline void WebsiteReportDetail::set_redirectlink(const ::std::string& value) {
  set_has_redirectlink();
  if (redirectlink_ == &::google::protobuf::internal::kEmptyString) {
    redirectlink_ = new ::std::string;
  }
  redirectlink_->assign(value);
}
inline void WebsiteReportDetail::set_redirectlink(const char* value) {
  set_has_redirectlink();
  if (redirectlink_ == &::google::protobuf::internal::kEmptyString) {
    redirectlink_ = new ::std::string;
  }
  redirectlink_->assign(value);
}
inline void WebsiteReportDetail::set_redirectlink(const char* value, size_t size) {
  set_has_redirectlink();
  if (redirectlink_ == &::google::protobuf::internal::kEmptyString) {
    redirectlink_ = new ::std::string;
  }
  redirectlink_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebsiteReportDetail::mutable_redirectlink() {
  set_has_redirectlink();
  if (redirectlink_ == &::google::protobuf::internal::kEmptyString) {
    redirectlink_ = new ::std::string;
  }
  return redirectlink_;
}
inline ::std::string* WebsiteReportDetail::release_redirectlink() {
  clear_has_redirectlink();
  if (redirectlink_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redirectlink_;
    redirectlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string htmlResponse = 6;
inline bool WebsiteReportDetail::has_htmlresponse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WebsiteReportDetail::set_has_htmlresponse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WebsiteReportDetail::clear_has_htmlresponse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WebsiteReportDetail::clear_htmlresponse() {
  if (htmlresponse_ != &::google::protobuf::internal::kEmptyString) {
    htmlresponse_->clear();
  }
  clear_has_htmlresponse();
}
inline const ::std::string& WebsiteReportDetail::htmlresponse() const {
  return *htmlresponse_;
}
inline void WebsiteReportDetail::set_htmlresponse(const ::std::string& value) {
  set_has_htmlresponse();
  if (htmlresponse_ == &::google::protobuf::internal::kEmptyString) {
    htmlresponse_ = new ::std::string;
  }
  htmlresponse_->assign(value);
}
inline void WebsiteReportDetail::set_htmlresponse(const char* value) {
  set_has_htmlresponse();
  if (htmlresponse_ == &::google::protobuf::internal::kEmptyString) {
    htmlresponse_ = new ::std::string;
  }
  htmlresponse_->assign(value);
}
inline void WebsiteReportDetail::set_htmlresponse(const char* value, size_t size) {
  set_has_htmlresponse();
  if (htmlresponse_ == &::google::protobuf::internal::kEmptyString) {
    htmlresponse_ = new ::std::string;
  }
  htmlresponse_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebsiteReportDetail::mutable_htmlresponse() {
  set_has_htmlresponse();
  if (htmlresponse_ == &::google::protobuf::internal::kEmptyString) {
    htmlresponse_ = new ::std::string;
  }
  return htmlresponse_;
}
inline ::std::string* WebsiteReportDetail::release_htmlresponse() {
  clear_has_htmlresponse();
  if (htmlresponse_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = htmlresponse_;
    htmlresponse_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes htmlMedia = 7;
inline bool WebsiteReportDetail::has_htmlmedia() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WebsiteReportDetail::set_has_htmlmedia() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WebsiteReportDetail::clear_has_htmlmedia() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WebsiteReportDetail::clear_htmlmedia() {
  if (htmlmedia_ != &::google::protobuf::internal::kEmptyString) {
    htmlmedia_->clear();
  }
  clear_has_htmlmedia();
}
inline const ::std::string& WebsiteReportDetail::htmlmedia() const {
  return *htmlmedia_;
}
inline void WebsiteReportDetail::set_htmlmedia(const ::std::string& value) {
  set_has_htmlmedia();
  if (htmlmedia_ == &::google::protobuf::internal::kEmptyString) {
    htmlmedia_ = new ::std::string;
  }
  htmlmedia_->assign(value);
}
inline void WebsiteReportDetail::set_htmlmedia(const char* value) {
  set_has_htmlmedia();
  if (htmlmedia_ == &::google::protobuf::internal::kEmptyString) {
    htmlmedia_ = new ::std::string;
  }
  htmlmedia_->assign(value);
}
inline void WebsiteReportDetail::set_htmlmedia(const void* value, size_t size) {
  set_has_htmlmedia();
  if (htmlmedia_ == &::google::protobuf::internal::kEmptyString) {
    htmlmedia_ = new ::std::string;
  }
  htmlmedia_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebsiteReportDetail::mutable_htmlmedia() {
  set_has_htmlmedia();
  if (htmlmedia_ == &::google::protobuf::internal::kEmptyString) {
    htmlmedia_ = new ::std::string;
  }
  return htmlmedia_;
}
inline ::std::string* WebsiteReportDetail::release_htmlmedia() {
  clear_has_htmlmedia();
  if (htmlmedia_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = htmlmedia_;
    htmlmedia_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// WebsiteReport

// required .org.umit.icm.mobile.proto.ICMReport header = 1;
inline bool WebsiteReport::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebsiteReport::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebsiteReport::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebsiteReport::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ICMReport::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ICMReport& WebsiteReport::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ICMReport* WebsiteReport::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ICMReport;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ICMReport* WebsiteReport::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ICMReport* temp = header_;
  header_ = NULL;
  return temp;
}

// required .org.umit.icm.mobile.proto.WebsiteReportDetail report = 2;
inline bool WebsiteReport::has_report() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebsiteReport::set_has_report() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebsiteReport::clear_has_report() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebsiteReport::clear_report() {
  if (report_ != NULL) report_->::org::umit::icm::mobile::proto::WebsiteReportDetail::Clear();
  clear_has_report();
}
inline const ::org::umit::icm::mobile::proto::WebsiteReportDetail& WebsiteReport::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* WebsiteReport::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::org::umit::icm::mobile::proto::WebsiteReportDetail;
  return report_;
}
inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* WebsiteReport::release_report() {
  clear_has_report();
  ::org::umit::icm::mobile::proto::WebsiteReportDetail* temp = report_;
  report_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ServiceReportDetail

// required string serviceName = 1;
inline bool ServiceReportDetail::has_servicename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReportDetail::set_has_servicename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReportDetail::clear_has_servicename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReportDetail::clear_servicename() {
  if (servicename_ != &::google::protobuf::internal::kEmptyString) {
    servicename_->clear();
  }
  clear_has_servicename();
}
inline const ::std::string& ServiceReportDetail::servicename() const {
  return *servicename_;
}
inline void ServiceReportDetail::set_servicename(const ::std::string& value) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(value);
}
inline void ServiceReportDetail::set_servicename(const char* value) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(value);
}
inline void ServiceReportDetail::set_servicename(const char* value, size_t size) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceReportDetail::mutable_servicename() {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  return servicename_;
}
inline ::std::string* ServiceReportDetail::release_servicename() {
  clear_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servicename_;
    servicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 statusCode = 2;
inline bool ServiceReportDetail::has_statuscode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceReportDetail::set_has_statuscode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceReportDetail::clear_has_statuscode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceReportDetail::clear_statuscode() {
  statuscode_ = 0;
  clear_has_statuscode();
}
inline ::google::protobuf::int32 ServiceReportDetail::statuscode() const {
  return statuscode_;
}
inline void ServiceReportDetail::set_statuscode(::google::protobuf::int32 value) {
  set_has_statuscode();
  statuscode_ = value;
}

// required int32 port = 3;
inline bool ServiceReportDetail::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceReportDetail::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceReportDetail::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceReportDetail::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 ServiceReportDetail::port() const {
  return port_;
}
inline void ServiceReportDetail::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional double responseTime = 4;
inline bool ServiceReportDetail::has_responsetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceReportDetail::set_has_responsetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceReportDetail::clear_has_responsetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceReportDetail::clear_responsetime() {
  responsetime_ = 0;
  clear_has_responsetime();
}
inline double ServiceReportDetail::responsetime() const {
  return responsetime_;
}
inline void ServiceReportDetail::set_responsetime(double value) {
  set_has_responsetime();
  responsetime_ = value;
}

// optional double bandwidth = 5;
inline bool ServiceReportDetail::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServiceReportDetail::set_has_bandwidth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServiceReportDetail::clear_has_bandwidth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServiceReportDetail::clear_bandwidth() {
  bandwidth_ = 0;
  clear_has_bandwidth();
}
inline double ServiceReportDetail::bandwidth() const {
  return bandwidth_;
}
inline void ServiceReportDetail::set_bandwidth(double value) {
  set_has_bandwidth();
  bandwidth_ = value;
}

// -------------------------------------------------------------------

// ServiceReport

// required .org.umit.icm.mobile.proto.ICMReport header = 1;
inline bool ServiceReport::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceReport::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceReport::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceReport::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ICMReport::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ICMReport& ServiceReport::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ICMReport* ServiceReport::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ICMReport;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ICMReport* ServiceReport::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ICMReport* temp = header_;
  header_ = NULL;
  return temp;
}

// required .org.umit.icm.mobile.proto.ServiceReportDetail report = 2;
inline bool ServiceReport::has_report() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceReport::set_has_report() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceReport::clear_has_report() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceReport::clear_report() {
  if (report_ != NULL) report_->::org::umit::icm::mobile::proto::ServiceReportDetail::Clear();
  clear_has_report();
}
inline const ::org::umit::icm::mobile::proto::ServiceReportDetail& ServiceReport::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::org::umit::icm::mobile::proto::ServiceReportDetail* ServiceReport::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::org::umit::icm::mobile::proto::ServiceReportDetail;
  return report_;
}
inline ::org::umit::icm::mobile::proto::ServiceReportDetail* ServiceReport::release_report() {
  clear_has_report();
  ::org::umit::icm::mobile::proto::ServiceReportDetail* temp = report_;
  report_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestHeader

// required string agentID = 1;
inline bool RequestHeader::has_agentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestHeader::set_has_agentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestHeader::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestHeader::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& RequestHeader::agentid() const {
  return *agentid_;
}
inline void RequestHeader::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void RequestHeader::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void RequestHeader::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestHeader::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* RequestHeader::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseHeader

// required int32 currentVersionNo = 1;
inline bool ResponseHeader::has_currentversionno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseHeader::set_has_currentversionno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseHeader::clear_has_currentversionno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseHeader::clear_currentversionno() {
  currentversionno_ = 0;
  clear_has_currentversionno();
}
inline ::google::protobuf::int32 ResponseHeader::currentversionno() const {
  return currentversionno_;
}
inline void ResponseHeader::set_currentversionno(::google::protobuf::int32 value) {
  set_has_currentversionno();
  currentversionno_ = value;
}

// required int32 currentTestVersionNo = 2;
inline bool ResponseHeader::has_currenttestversionno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseHeader::set_has_currenttestversionno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseHeader::clear_has_currenttestversionno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseHeader::clear_currenttestversionno() {
  currenttestversionno_ = 0;
  clear_has_currenttestversionno();
}
inline ::google::protobuf::int32 ResponseHeader::currenttestversionno() const {
  return currenttestversionno_;
}
inline void ResponseHeader::set_currenttestversionno(::google::protobuf::int32 value) {
  set_has_currenttestversionno();
  currenttestversionno_ = value;
}

// -------------------------------------------------------------------

// RegisterAgent

// required int32 versionNo = 1;
inline bool RegisterAgent::has_versionno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterAgent::set_has_versionno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterAgent::clear_has_versionno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterAgent::clear_versionno() {
  versionno_ = 0;
  clear_has_versionno();
}
inline ::google::protobuf::int32 RegisterAgent::versionno() const {
  return versionno_;
}
inline void RegisterAgent::set_versionno(::google::protobuf::int32 value) {
  set_has_versionno();
  versionno_ = value;
}

// required string agentType = 2;
inline bool RegisterAgent::has_agenttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterAgent::set_has_agenttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterAgent::clear_has_agenttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterAgent::clear_agenttype() {
  if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
    agenttype_->clear();
  }
  clear_has_agenttype();
}
inline const ::std::string& RegisterAgent::agenttype() const {
  return *agenttype_;
}
inline void RegisterAgent::set_agenttype(const ::std::string& value) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(value);
}
inline void RegisterAgent::set_agenttype(const char* value) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(value);
}
inline void RegisterAgent::set_agenttype(const char* value, size_t size) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterAgent::mutable_agenttype() {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  return agenttype_;
}
inline ::std::string* RegisterAgent::release_agenttype() {
  clear_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agenttype_;
    agenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .org.umit.icm.mobile.proto.LoginCredentials credentials = 3;
inline bool RegisterAgent::has_credentials() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterAgent::set_has_credentials() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterAgent::clear_has_credentials() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterAgent::clear_credentials() {
  if (credentials_ != NULL) credentials_->::org::umit::icm::mobile::proto::LoginCredentials::Clear();
  clear_has_credentials();
}
inline const ::org::umit::icm::mobile::proto::LoginCredentials& RegisterAgent::credentials() const {
  return credentials_ != NULL ? *credentials_ : *default_instance_->credentials_;
}
inline ::org::umit::icm::mobile::proto::LoginCredentials* RegisterAgent::mutable_credentials() {
  set_has_credentials();
  if (credentials_ == NULL) credentials_ = new ::org::umit::icm::mobile::proto::LoginCredentials;
  return credentials_;
}
inline ::org::umit::icm::mobile::proto::LoginCredentials* RegisterAgent::release_credentials() {
  clear_has_credentials();
  ::org::umit::icm::mobile::proto::LoginCredentials* temp = credentials_;
  credentials_ = NULL;
  return temp;
}

// required .org.umit.icm.mobile.proto.RSAKey agentPublicKey = 4;
inline bool RegisterAgent::has_agentpublickey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterAgent::set_has_agentpublickey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegisterAgent::clear_has_agentpublickey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegisterAgent::clear_agentpublickey() {
  if (agentpublickey_ != NULL) agentpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
  clear_has_agentpublickey();
}
inline const ::org::umit::icm::mobile::proto::RSAKey& RegisterAgent::agentpublickey() const {
  return agentpublickey_ != NULL ? *agentpublickey_ : *default_instance_->agentpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* RegisterAgent::mutable_agentpublickey() {
  set_has_agentpublickey();
  if (agentpublickey_ == NULL) agentpublickey_ = new ::org::umit::icm::mobile::proto::RSAKey;
  return agentpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* RegisterAgent::release_agentpublickey() {
  clear_has_agentpublickey();
  ::org::umit::icm::mobile::proto::RSAKey* temp = agentpublickey_;
  agentpublickey_ = NULL;
  return temp;
}

// optional string ip = 5;
inline bool RegisterAgent::has_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegisterAgent::set_has_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RegisterAgent::clear_has_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RegisterAgent::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RegisterAgent::ip() const {
  return *ip_;
}
inline void RegisterAgent::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegisterAgent::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RegisterAgent::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterAgent::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RegisterAgent::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RegisterAgentResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool RegisterAgentResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterAgentResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterAgentResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterAgentResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& RegisterAgentResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* RegisterAgentResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* RegisterAgentResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required string agentID = 2;
inline bool RegisterAgentResponse::has_agentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterAgentResponse::set_has_agentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterAgentResponse::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterAgentResponse::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& RegisterAgentResponse::agentid() const {
  return *agentid_;
}
inline void RegisterAgentResponse::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void RegisterAgentResponse::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void RegisterAgentResponse::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterAgentResponse::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* RegisterAgentResponse::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string publicKeyHash = 3;
inline bool RegisterAgentResponse::has_publickeyhash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterAgentResponse::set_has_publickeyhash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterAgentResponse::clear_has_publickeyhash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterAgentResponse::clear_publickeyhash() {
  if (publickeyhash_ != &::google::protobuf::internal::kEmptyString) {
    publickeyhash_->clear();
  }
  clear_has_publickeyhash();
}
inline const ::std::string& RegisterAgentResponse::publickeyhash() const {
  return *publickeyhash_;
}
inline void RegisterAgentResponse::set_publickeyhash(const ::std::string& value) {
  set_has_publickeyhash();
  if (publickeyhash_ == &::google::protobuf::internal::kEmptyString) {
    publickeyhash_ = new ::std::string;
  }
  publickeyhash_->assign(value);
}
inline void RegisterAgentResponse::set_publickeyhash(const char* value) {
  set_has_publickeyhash();
  if (publickeyhash_ == &::google::protobuf::internal::kEmptyString) {
    publickeyhash_ = new ::std::string;
  }
  publickeyhash_->assign(value);
}
inline void RegisterAgentResponse::set_publickeyhash(const char* value, size_t size) {
  set_has_publickeyhash();
  if (publickeyhash_ == &::google::protobuf::internal::kEmptyString) {
    publickeyhash_ = new ::std::string;
  }
  publickeyhash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterAgentResponse::mutable_publickeyhash() {
  set_has_publickeyhash();
  if (publickeyhash_ == &::google::protobuf::internal::kEmptyString) {
    publickeyhash_ = new ::std::string;
  }
  return publickeyhash_;
}
inline ::std::string* RegisterAgentResponse::release_publickeyhash() {
  clear_has_publickeyhash();
  if (publickeyhash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = publickeyhash_;
    publickeyhash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RSAKey

// required string mod = 1;
inline bool RSAKey::has_mod() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RSAKey::set_has_mod() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RSAKey::clear_has_mod() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RSAKey::clear_mod() {
  if (mod_ != &::google::protobuf::internal::kEmptyString) {
    mod_->clear();
  }
  clear_has_mod();
}
inline const ::std::string& RSAKey::mod() const {
  return *mod_;
}
inline void RSAKey::set_mod(const ::std::string& value) {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  mod_->assign(value);
}
inline void RSAKey::set_mod(const char* value) {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  mod_->assign(value);
}
inline void RSAKey::set_mod(const char* value, size_t size) {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  mod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RSAKey::mutable_mod() {
  set_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    mod_ = new ::std::string;
  }
  return mod_;
}
inline ::std::string* RSAKey::release_mod() {
  clear_has_mod();
  if (mod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mod_;
    mod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string exp = 2;
inline bool RSAKey::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RSAKey::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RSAKey::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RSAKey::clear_exp() {
  if (exp_ != &::google::protobuf::internal::kEmptyString) {
    exp_->clear();
  }
  clear_has_exp();
}
inline const ::std::string& RSAKey::exp() const {
  return *exp_;
}
inline void RSAKey::set_exp(const ::std::string& value) {
  set_has_exp();
  if (exp_ == &::google::protobuf::internal::kEmptyString) {
    exp_ = new ::std::string;
  }
  exp_->assign(value);
}
inline void RSAKey::set_exp(const char* value) {
  set_has_exp();
  if (exp_ == &::google::protobuf::internal::kEmptyString) {
    exp_ = new ::std::string;
  }
  exp_->assign(value);
}
inline void RSAKey::set_exp(const char* value, size_t size) {
  set_has_exp();
  if (exp_ == &::google::protobuf::internal::kEmptyString) {
    exp_ = new ::std::string;
  }
  exp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RSAKey::mutable_exp() {
  set_has_exp();
  if (exp_ == &::google::protobuf::internal::kEmptyString) {
    exp_ = new ::std::string;
  }
  return exp_;
}
inline ::std::string* RSAKey::release_exp() {
  clear_has_exp();
  if (exp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exp_;
    exp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CheckAggregator

// required string agentType = 1;
inline bool CheckAggregator::has_agenttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckAggregator::set_has_agenttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckAggregator::clear_has_agenttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckAggregator::clear_agenttype() {
  if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
    agenttype_->clear();
  }
  clear_has_agenttype();
}
inline const ::std::string& CheckAggregator::agenttype() const {
  return *agenttype_;
}
inline void CheckAggregator::set_agenttype(const ::std::string& value) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(value);
}
inline void CheckAggregator::set_agenttype(const char* value) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(value);
}
inline void CheckAggregator::set_agenttype(const char* value, size_t size) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckAggregator::mutable_agenttype() {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  return agenttype_;
}
inline ::std::string* CheckAggregator::release_agenttype() {
  clear_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agenttype_;
    agenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CheckAggregatorResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool CheckAggregatorResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckAggregatorResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckAggregatorResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckAggregatorResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& CheckAggregatorResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* CheckAggregatorResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* CheckAggregatorResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required string status = 2;
inline bool CheckAggregatorResponse::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckAggregatorResponse::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckAggregatorResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckAggregatorResponse::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& CheckAggregatorResponse::status() const {
  return *status_;
}
inline void CheckAggregatorResponse::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void CheckAggregatorResponse::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void CheckAggregatorResponse::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckAggregatorResponse::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* CheckAggregatorResponse::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Login

// required string agentID = 1;
inline bool Login::has_agentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_agentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& Login::agentid() const {
  return *agentid_;
}
inline void Login::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void Login::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void Login::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* Login::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string challenge = 2;
inline bool Login::has_challenge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_challenge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& Login::challenge() const {
  return *challenge_;
}
inline void Login::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void Login::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void Login::set_challenge(const char* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  return challenge_;
}
inline ::std::string* Login::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 port = 3;
inline bool Login::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_port() {
  port_ = GOOGLE_LONGLONG(0);
  clear_has_port();
}
inline ::google::protobuf::int64 Login::port() const {
  return port_;
}
inline void Login::set_port(::google::protobuf::int64 value) {
  set_has_port();
  port_ = value;
}

// optional string ip = 4;
inline bool Login::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Login::ip() const {
  return *ip_;
}
inline void Login::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Login::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Login::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Login::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginStep1

// required string processID = 1;
inline bool LoginStep1::has_processid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginStep1::set_has_processid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginStep1::clear_has_processid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginStep1::clear_processid() {
  if (processid_ != &::google::protobuf::internal::kEmptyString) {
    processid_->clear();
  }
  clear_has_processid();
}
inline const ::std::string& LoginStep1::processid() const {
  return *processid_;
}
inline void LoginStep1::set_processid(const ::std::string& value) {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  processid_->assign(value);
}
inline void LoginStep1::set_processid(const char* value) {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  processid_->assign(value);
}
inline void LoginStep1::set_processid(const char* value, size_t size) {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  processid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStep1::mutable_processid() {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  return processid_;
}
inline ::std::string* LoginStep1::release_processid() {
  clear_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processid_;
    processid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string cipheredChallenge = 2;
inline bool LoginStep1::has_cipheredchallenge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginStep1::set_has_cipheredchallenge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginStep1::clear_has_cipheredchallenge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginStep1::clear_cipheredchallenge() {
  if (cipheredchallenge_ != &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_->clear();
  }
  clear_has_cipheredchallenge();
}
inline const ::std::string& LoginStep1::cipheredchallenge() const {
  return *cipheredchallenge_;
}
inline void LoginStep1::set_cipheredchallenge(const ::std::string& value) {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  cipheredchallenge_->assign(value);
}
inline void LoginStep1::set_cipheredchallenge(const char* value) {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  cipheredchallenge_->assign(value);
}
inline void LoginStep1::set_cipheredchallenge(const char* value, size_t size) {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  cipheredchallenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStep1::mutable_cipheredchallenge() {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  return cipheredchallenge_;
}
inline ::std::string* LoginStep1::release_cipheredchallenge() {
  clear_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cipheredchallenge_;
    cipheredchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string challenge = 3;
inline bool LoginStep1::has_challenge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginStep1::set_has_challenge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginStep1::clear_has_challenge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginStep1::clear_challenge() {
  if (challenge_ != &::google::protobuf::internal::kEmptyString) {
    challenge_->clear();
  }
  clear_has_challenge();
}
inline const ::std::string& LoginStep1::challenge() const {
  return *challenge_;
}
inline void LoginStep1::set_challenge(const ::std::string& value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void LoginStep1::set_challenge(const char* value) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(value);
}
inline void LoginStep1::set_challenge(const char* value, size_t size) {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  challenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStep1::mutable_challenge() {
  set_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    challenge_ = new ::std::string;
  }
  return challenge_;
}
inline ::std::string* LoginStep1::release_challenge() {
  clear_has_challenge();
  if (challenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = challenge_;
    challenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginStep2

// required string processID = 1;
inline bool LoginStep2::has_processid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginStep2::set_has_processid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginStep2::clear_has_processid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginStep2::clear_processid() {
  if (processid_ != &::google::protobuf::internal::kEmptyString) {
    processid_->clear();
  }
  clear_has_processid();
}
inline const ::std::string& LoginStep2::processid() const {
  return *processid_;
}
inline void LoginStep2::set_processid(const ::std::string& value) {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  processid_->assign(value);
}
inline void LoginStep2::set_processid(const char* value) {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  processid_->assign(value);
}
inline void LoginStep2::set_processid(const char* value, size_t size) {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  processid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStep2::mutable_processid() {
  set_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    processid_ = new ::std::string;
  }
  return processid_;
}
inline ::std::string* LoginStep2::release_processid() {
  clear_has_processid();
  if (processid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = processid_;
    processid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string cipheredChallenge = 2;
inline bool LoginStep2::has_cipheredchallenge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginStep2::set_has_cipheredchallenge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginStep2::clear_has_cipheredchallenge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginStep2::clear_cipheredchallenge() {
  if (cipheredchallenge_ != &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_->clear();
  }
  clear_has_cipheredchallenge();
}
inline const ::std::string& LoginStep2::cipheredchallenge() const {
  return *cipheredchallenge_;
}
inline void LoginStep2::set_cipheredchallenge(const ::std::string& value) {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  cipheredchallenge_->assign(value);
}
inline void LoginStep2::set_cipheredchallenge(const char* value) {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  cipheredchallenge_->assign(value);
}
inline void LoginStep2::set_cipheredchallenge(const char* value, size_t size) {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  cipheredchallenge_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginStep2::mutable_cipheredchallenge() {
  set_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    cipheredchallenge_ = new ::std::string;
  }
  return cipheredchallenge_;
}
inline ::std::string* LoginStep2::release_cipheredchallenge() {
  clear_has_cipheredchallenge();
  if (cipheredchallenge_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cipheredchallenge_;
    cipheredchallenge_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool LoginResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& LoginResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* LoginResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* LoginResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Logout

// required string agentID = 1;
inline bool Logout::has_agentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Logout::set_has_agentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Logout::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Logout::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& Logout::agentid() const {
  return *agentid_;
}
inline void Logout::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void Logout::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void Logout::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Logout::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* Logout::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogoutResponse

// required string status = 1;
inline bool LogoutResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutResponse::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& LogoutResponse::status() const {
  return *status_;
}
inline void LogoutResponse::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void LogoutResponse::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void LogoutResponse::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogoutResponse::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* LogoutResponse::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetPeerList

// optional int32 count = 1;
inline bool GetPeerList::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPeerList::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPeerList::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPeerList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GetPeerList::count() const {
  return count_;
}
inline void GetPeerList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// AgentData

// required string agentID = 1;
inline bool AgentData::has_agentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentData::set_has_agentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentData::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentData::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& AgentData::agentid() const {
  return *agentid_;
}
inline void AgentData::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void AgentData::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void AgentData::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentData::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* AgentData::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string agentIP = 2;
inline bool AgentData::has_agentip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentData::set_has_agentip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentData::clear_has_agentip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentData::clear_agentip() {
  if (agentip_ != &::google::protobuf::internal::kEmptyString) {
    agentip_->clear();
  }
  clear_has_agentip();
}
inline const ::std::string& AgentData::agentip() const {
  return *agentip_;
}
inline void AgentData::set_agentip(const ::std::string& value) {
  set_has_agentip();
  if (agentip_ == &::google::protobuf::internal::kEmptyString) {
    agentip_ = new ::std::string;
  }
  agentip_->assign(value);
}
inline void AgentData::set_agentip(const char* value) {
  set_has_agentip();
  if (agentip_ == &::google::protobuf::internal::kEmptyString) {
    agentip_ = new ::std::string;
  }
  agentip_->assign(value);
}
inline void AgentData::set_agentip(const char* value, size_t size) {
  set_has_agentip();
  if (agentip_ == &::google::protobuf::internal::kEmptyString) {
    agentip_ = new ::std::string;
  }
  agentip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentData::mutable_agentip() {
  set_has_agentip();
  if (agentip_ == &::google::protobuf::internal::kEmptyString) {
    agentip_ = new ::std::string;
  }
  return agentip_;
}
inline ::std::string* AgentData::release_agentip() {
  clear_has_agentip();
  if (agentip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentip_;
    agentip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 agentPort = 3;
inline bool AgentData::has_agentport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentData::set_has_agentport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentData::clear_has_agentport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentData::clear_agentport() {
  agentport_ = 0;
  clear_has_agentport();
}
inline ::google::protobuf::int32 AgentData::agentport() const {
  return agentport_;
}
inline void AgentData::set_agentport(::google::protobuf::int32 value) {
  set_has_agentport();
  agentport_ = value;
}

// required string token = 4;
inline bool AgentData::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AgentData::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AgentData::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AgentData::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AgentData::token() const {
  return *token_;
}
inline void AgentData::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AgentData::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AgentData::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentData::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AgentData::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .org.umit.icm.mobile.proto.RSAKey publicKey = 5;
inline bool AgentData::has_publickey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AgentData::set_has_publickey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AgentData::clear_has_publickey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AgentData::clear_publickey() {
  if (publickey_ != NULL) publickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
  clear_has_publickey();
}
inline const ::org::umit::icm::mobile::proto::RSAKey& AgentData::publickey() const {
  return publickey_ != NULL ? *publickey_ : *default_instance_->publickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* AgentData::mutable_publickey() {
  set_has_publickey();
  if (publickey_ == NULL) publickey_ = new ::org::umit::icm::mobile::proto::RSAKey;
  return publickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* AgentData::release_publickey() {
  clear_has_publickey();
  ::org::umit::icm::mobile::proto::RSAKey* temp = publickey_;
  publickey_ = NULL;
  return temp;
}

// required string peerStatus = 6;
inline bool AgentData::has_peerstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AgentData::set_has_peerstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AgentData::clear_has_peerstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AgentData::clear_peerstatus() {
  if (peerstatus_ != &::google::protobuf::internal::kEmptyString) {
    peerstatus_->clear();
  }
  clear_has_peerstatus();
}
inline const ::std::string& AgentData::peerstatus() const {
  return *peerstatus_;
}
inline void AgentData::set_peerstatus(const ::std::string& value) {
  set_has_peerstatus();
  if (peerstatus_ == &::google::protobuf::internal::kEmptyString) {
    peerstatus_ = new ::std::string;
  }
  peerstatus_->assign(value);
}
inline void AgentData::set_peerstatus(const char* value) {
  set_has_peerstatus();
  if (peerstatus_ == &::google::protobuf::internal::kEmptyString) {
    peerstatus_ = new ::std::string;
  }
  peerstatus_->assign(value);
}
inline void AgentData::set_peerstatus(const char* value, size_t size) {
  set_has_peerstatus();
  if (peerstatus_ == &::google::protobuf::internal::kEmptyString) {
    peerstatus_ = new ::std::string;
  }
  peerstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentData::mutable_peerstatus() {
  set_has_peerstatus();
  if (peerstatus_ == &::google::protobuf::internal::kEmptyString) {
    peerstatus_ = new ::std::string;
  }
  return peerstatus_;
}
inline ::std::string* AgentData::release_peerstatus() {
  clear_has_peerstatus();
  if (peerstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peerstatus_;
    peerstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetPeerListResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool GetPeerListResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPeerListResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPeerListResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPeerListResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& GetPeerListResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetPeerListResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetPeerListResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.AgentData knownPeers = 2;
inline int GetPeerListResponse::knownpeers_size() const {
  return knownpeers_.size();
}
inline void GetPeerListResponse::clear_knownpeers() {
  knownpeers_.Clear();
}
inline const ::org::umit::icm::mobile::proto::AgentData& GetPeerListResponse::knownpeers(int index) const {
  return knownpeers_.Get(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* GetPeerListResponse::mutable_knownpeers(int index) {
  return knownpeers_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* GetPeerListResponse::add_knownpeers() {
  return knownpeers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
GetPeerListResponse::knownpeers() const {
  return knownpeers_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
GetPeerListResponse::mutable_knownpeers() {
  return &knownpeers_;
}

// -------------------------------------------------------------------

// GetSuperPeerList

// optional int32 count = 1;
inline bool GetSuperPeerList::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSuperPeerList::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSuperPeerList::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSuperPeerList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GetSuperPeerList::count() const {
  return count_;
}
inline void GetSuperPeerList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// GetSuperPeerListResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool GetSuperPeerListResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSuperPeerListResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSuperPeerListResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSuperPeerListResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& GetSuperPeerListResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetSuperPeerListResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetSuperPeerListResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.AgentData knownSuperPeers = 2;
inline int GetSuperPeerListResponse::knownsuperpeers_size() const {
  return knownsuperpeers_.size();
}
inline void GetSuperPeerListResponse::clear_knownsuperpeers() {
  knownsuperpeers_.Clear();
}
inline const ::org::umit::icm::mobile::proto::AgentData& GetSuperPeerListResponse::knownsuperpeers(int index) const {
  return knownsuperpeers_.Get(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* GetSuperPeerListResponse::mutable_knownsuperpeers(int index) {
  return knownsuperpeers_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* GetSuperPeerListResponse::add_knownsuperpeers() {
  return knownsuperpeers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
GetSuperPeerListResponse::knownsuperpeers() const {
  return knownsuperpeers_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
GetSuperPeerListResponse::mutable_knownsuperpeers() {
  return &knownsuperpeers_;
}

// -------------------------------------------------------------------

// Location

// required double longitude = 1;
inline bool Location::has_longitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_longitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double Location::longitude() const {
  return longitude_;
}
inline void Location::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// required double latitude = 2;
inline bool Location::has_latitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_latitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double Location::latitude() const {
  return latitude_;
}
inline void Location::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// -------------------------------------------------------------------

// GetEvents

// repeated .org.umit.icm.mobile.proto.Location locations = 1;
inline int GetEvents::locations_size() const {
  return locations_.size();
}
inline void GetEvents::clear_locations() {
  locations_.Clear();
}
inline const ::org::umit::icm::mobile::proto::Location& GetEvents::locations(int index) const {
  return locations_.Get(index);
}
inline ::org::umit::icm::mobile::proto::Location* GetEvents::mutable_locations(int index) {
  return locations_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::Location* GetEvents::add_locations() {
  return locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >&
GetEvents::locations() const {
  return locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >*
GetEvents::mutable_locations() {
  return &locations_;
}

// optional .org.umit.icm.mobile.proto.Location agentLocation = 2;
inline bool GetEvents::has_agentlocation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetEvents::set_has_agentlocation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetEvents::clear_has_agentlocation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetEvents::clear_agentlocation() {
  if (agentlocation_ != NULL) agentlocation_->::org::umit::icm::mobile::proto::Location::Clear();
  clear_has_agentlocation();
}
inline const ::org::umit::icm::mobile::proto::Location& GetEvents::agentlocation() const {
  return agentlocation_ != NULL ? *agentlocation_ : *default_instance_->agentlocation_;
}
inline ::org::umit::icm::mobile::proto::Location* GetEvents::mutable_agentlocation() {
  set_has_agentlocation();
  if (agentlocation_ == NULL) agentlocation_ = new ::org::umit::icm::mobile::proto::Location;
  return agentlocation_;
}
inline ::org::umit::icm::mobile::proto::Location* GetEvents::release_agentlocation() {
  clear_has_agentlocation();
  ::org::umit::icm::mobile::proto::Location* temp = agentlocation_;
  agentlocation_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Event

// required string testType = 1;
inline bool Event::has_testtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_testtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_testtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_testtype() {
  if (testtype_ != &::google::protobuf::internal::kEmptyString) {
    testtype_->clear();
  }
  clear_has_testtype();
}
inline const ::std::string& Event::testtype() const {
  return *testtype_;
}
inline void Event::set_testtype(const ::std::string& value) {
  set_has_testtype();
  if (testtype_ == &::google::protobuf::internal::kEmptyString) {
    testtype_ = new ::std::string;
  }
  testtype_->assign(value);
}
inline void Event::set_testtype(const char* value) {
  set_has_testtype();
  if (testtype_ == &::google::protobuf::internal::kEmptyString) {
    testtype_ = new ::std::string;
  }
  testtype_->assign(value);
}
inline void Event::set_testtype(const char* value, size_t size) {
  set_has_testtype();
  if (testtype_ == &::google::protobuf::internal::kEmptyString) {
    testtype_ = new ::std::string;
  }
  testtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_testtype() {
  set_has_testtype();
  if (testtype_ == &::google::protobuf::internal::kEmptyString) {
    testtype_ = new ::std::string;
  }
  return testtype_;
}
inline ::std::string* Event::release_testtype() {
  clear_has_testtype();
  if (testtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = testtype_;
    testtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string eventType = 2;
inline bool Event::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_eventtype() {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    eventtype_->clear();
  }
  clear_has_eventtype();
}
inline const ::std::string& Event::eventtype() const {
  return *eventtype_;
}
inline void Event::set_eventtype(const ::std::string& value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void Event::set_eventtype(const char* value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void Event::set_eventtype(const char* value, size_t size) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  return eventtype_;
}
inline ::std::string* Event::release_eventtype() {
  clear_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventtype_;
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 timeUTC = 3;
inline bool Event::has_timeutc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_timeutc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_timeutc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_timeutc() {
  timeutc_ = GOOGLE_LONGLONG(0);
  clear_has_timeutc();
}
inline ::google::protobuf::int64 Event::timeutc() const {
  return timeutc_;
}
inline void Event::set_timeutc(::google::protobuf::int64 value) {
  set_has_timeutc();
  timeutc_ = value;
}

// required int64 sinceTimeUTC = 4;
inline bool Event::has_sincetimeutc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_sincetimeutc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_sincetimeutc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_sincetimeutc() {
  sincetimeutc_ = GOOGLE_LONGLONG(0);
  clear_has_sincetimeutc();
}
inline ::google::protobuf::int64 Event::sincetimeutc() const {
  return sincetimeutc_;
}
inline void Event::set_sincetimeutc(::google::protobuf::int64 value) {
  set_has_sincetimeutc();
  sincetimeutc_ = value;
}

// repeated .org.umit.icm.mobile.proto.Location locations = 5;
inline int Event::locations_size() const {
  return locations_.size();
}
inline void Event::clear_locations() {
  locations_.Clear();
}
inline const ::org::umit::icm::mobile::proto::Location& Event::locations(int index) const {
  return locations_.Get(index);
}
inline ::org::umit::icm::mobile::proto::Location* Event::mutable_locations(int index) {
  return locations_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::Location* Event::add_locations() {
  return locations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >&
Event::locations() const {
  return locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Location >*
Event::mutable_locations() {
  return &locations_;
}

// optional .org.umit.icm.mobile.proto.WebsiteReportDetail websiteReport = 6;
inline bool Event::has_websitereport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_websitereport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_websitereport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_websitereport() {
  if (websitereport_ != NULL) websitereport_->::org::umit::icm::mobile::proto::WebsiteReportDetail::Clear();
  clear_has_websitereport();
}
inline const ::org::umit::icm::mobile::proto::WebsiteReportDetail& Event::websitereport() const {
  return websitereport_ != NULL ? *websitereport_ : *default_instance_->websitereport_;
}
inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* Event::mutable_websitereport() {
  set_has_websitereport();
  if (websitereport_ == NULL) websitereport_ = new ::org::umit::icm::mobile::proto::WebsiteReportDetail;
  return websitereport_;
}
inline ::org::umit::icm::mobile::proto::WebsiteReportDetail* Event::release_websitereport() {
  clear_has_websitereport();
  ::org::umit::icm::mobile::proto::WebsiteReportDetail* temp = websitereport_;
  websitereport_ = NULL;
  return temp;
}

// optional .org.umit.icm.mobile.proto.ServiceReportDetail serviceReport = 7;
inline bool Event::has_servicereport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_servicereport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_servicereport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_servicereport() {
  if (servicereport_ != NULL) servicereport_->::org::umit::icm::mobile::proto::ServiceReportDetail::Clear();
  clear_has_servicereport();
}
inline const ::org::umit::icm::mobile::proto::ServiceReportDetail& Event::servicereport() const {
  return servicereport_ != NULL ? *servicereport_ : *default_instance_->servicereport_;
}
inline ::org::umit::icm::mobile::proto::ServiceReportDetail* Event::mutable_servicereport() {
  set_has_servicereport();
  if (servicereport_ == NULL) servicereport_ = new ::org::umit::icm::mobile::proto::ServiceReportDetail;
  return servicereport_;
}
inline ::org::umit::icm::mobile::proto::ServiceReportDetail* Event::release_servicereport() {
  clear_has_servicereport();
  ::org::umit::icm::mobile::proto::ServiceReportDetail* temp = servicereport_;
  servicereport_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GetEventsResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool GetEventsResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEventsResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEventsResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEventsResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& GetEventsResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetEventsResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetEventsResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.Event events = 2;
inline int GetEventsResponse::events_size() const {
  return events_.size();
}
inline void GetEventsResponse::clear_events() {
  events_.Clear();
}
inline const ::org::umit::icm::mobile::proto::Event& GetEventsResponse::events(int index) const {
  return events_.Get(index);
}
inline ::org::umit::icm::mobile::proto::Event* GetEventsResponse::mutable_events(int index) {
  return events_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::Event* GetEventsResponse::add_events() {
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Event >&
GetEventsResponse::events() const {
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Event >*
GetEventsResponse::mutable_events() {
  return &events_;
}

// -------------------------------------------------------------------

// SendWebsiteReport

// required .org.umit.icm.mobile.proto.WebsiteReport report = 1;
inline bool SendWebsiteReport::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendWebsiteReport::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendWebsiteReport::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendWebsiteReport::clear_report() {
  if (report_ != NULL) report_->::org::umit::icm::mobile::proto::WebsiteReport::Clear();
  clear_has_report();
}
inline const ::org::umit::icm::mobile::proto::WebsiteReport& SendWebsiteReport::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::org::umit::icm::mobile::proto::WebsiteReport* SendWebsiteReport::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::org::umit::icm::mobile::proto::WebsiteReport;
  return report_;
}
inline ::org::umit::icm::mobile::proto::WebsiteReport* SendWebsiteReport::release_report() {
  clear_has_report();
  ::org::umit::icm::mobile::proto::WebsiteReport* temp = report_;
  report_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SendServiceReport

// required .org.umit.icm.mobile.proto.ServiceReport report = 1;
inline bool SendServiceReport::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendServiceReport::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendServiceReport::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendServiceReport::clear_report() {
  if (report_ != NULL) report_->::org::umit::icm::mobile::proto::ServiceReport::Clear();
  clear_has_report();
}
inline const ::org::umit::icm::mobile::proto::ServiceReport& SendServiceReport::report() const {
  return report_ != NULL ? *report_ : *default_instance_->report_;
}
inline ::org::umit::icm::mobile::proto::ServiceReport* SendServiceReport::mutable_report() {
  set_has_report();
  if (report_ == NULL) report_ = new ::org::umit::icm::mobile::proto::ServiceReport;
  return report_;
}
inline ::org::umit::icm::mobile::proto::ServiceReport* SendServiceReport::release_report() {
  clear_has_report();
  ::org::umit::icm::mobile::proto::ServiceReport* temp = report_;
  report_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SendReportResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool SendReportResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendReportResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendReportResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendReportResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& SendReportResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* SendReportResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* SendReportResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NewVersion

// required int32 agentVersionNo = 1;
inline bool NewVersion::has_agentversionno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewVersion::set_has_agentversionno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewVersion::clear_has_agentversionno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewVersion::clear_agentversionno() {
  agentversionno_ = 0;
  clear_has_agentversionno();
}
inline ::google::protobuf::int32 NewVersion::agentversionno() const {
  return agentversionno_;
}
inline void NewVersion::set_agentversionno(::google::protobuf::int32 value) {
  set_has_agentversionno();
  agentversionno_ = value;
}

// required string agentType = 2;
inline bool NewVersion::has_agenttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewVersion::set_has_agenttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewVersion::clear_has_agenttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewVersion::clear_agenttype() {
  if (agenttype_ != &::google::protobuf::internal::kEmptyString) {
    agenttype_->clear();
  }
  clear_has_agenttype();
}
inline const ::std::string& NewVersion::agenttype() const {
  return *agenttype_;
}
inline void NewVersion::set_agenttype(const ::std::string& value) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(value);
}
inline void NewVersion::set_agenttype(const char* value) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(value);
}
inline void NewVersion::set_agenttype(const char* value, size_t size) {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  agenttype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewVersion::mutable_agenttype() {
  set_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    agenttype_ = new ::std::string;
  }
  return agenttype_;
}
inline ::std::string* NewVersion::release_agenttype() {
  clear_has_agenttype();
  if (agenttype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agenttype_;
    agenttype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// NewVersionResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool NewVersionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewVersionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewVersionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewVersionResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& NewVersionResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* NewVersionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* NewVersionResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// optional string downloadURL = 2;
inline bool NewVersionResponse::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewVersionResponse::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewVersionResponse::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewVersionResponse::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& NewVersionResponse::downloadurl() const {
  return *downloadurl_;
}
inline void NewVersionResponse::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void NewVersionResponse::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void NewVersionResponse::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewVersionResponse::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* NewVersionResponse::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes update = 3;
inline bool NewVersionResponse::has_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewVersionResponse::set_has_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewVersionResponse::clear_has_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewVersionResponse::clear_update() {
  if (update_ != &::google::protobuf::internal::kEmptyString) {
    update_->clear();
  }
  clear_has_update();
}
inline const ::std::string& NewVersionResponse::update() const {
  return *update_;
}
inline void NewVersionResponse::set_update(const ::std::string& value) {
  set_has_update();
  if (update_ == &::google::protobuf::internal::kEmptyString) {
    update_ = new ::std::string;
  }
  update_->assign(value);
}
inline void NewVersionResponse::set_update(const char* value) {
  set_has_update();
  if (update_ == &::google::protobuf::internal::kEmptyString) {
    update_ = new ::std::string;
  }
  update_->assign(value);
}
inline void NewVersionResponse::set_update(const void* value, size_t size) {
  set_has_update();
  if (update_ == &::google::protobuf::internal::kEmptyString) {
    update_ = new ::std::string;
  }
  update_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewVersionResponse::mutable_update() {
  set_has_update();
  if (update_ == &::google::protobuf::internal::kEmptyString) {
    update_ = new ::std::string;
  }
  return update_;
}
inline ::std::string* NewVersionResponse::release_update() {
  clear_has_update();
  if (update_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_;
    update_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 versionNo = 4;
inline bool NewVersionResponse::has_versionno() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewVersionResponse::set_has_versionno() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewVersionResponse::clear_has_versionno() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewVersionResponse::clear_versionno() {
  versionno_ = 0;
  clear_has_versionno();
}
inline ::google::protobuf::int32 NewVersionResponse::versionno() const {
  return versionno_;
}
inline void NewVersionResponse::set_versionno(::google::protobuf::int32 value) {
  set_has_versionno();
  versionno_ = value;
}

// -------------------------------------------------------------------

// NewTests

// required int32 currentTestVersionNo = 1;
inline bool NewTests::has_currenttestversionno() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewTests::set_has_currenttestversionno() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewTests::clear_has_currenttestversionno() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewTests::clear_currenttestversionno() {
  currenttestversionno_ = 0;
  clear_has_currenttestversionno();
}
inline ::google::protobuf::int32 NewTests::currenttestversionno() const {
  return currenttestversionno_;
}
inline void NewTests::set_currenttestversionno(::google::protobuf::int32 value) {
  set_has_currenttestversionno();
  currenttestversionno_ = value;
}

// -------------------------------------------------------------------

// Website

// required string url = 1;
inline bool Website::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Website::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Website::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Website::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Website::url() const {
  return *url_;
}
inline void Website::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Website::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Website::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Website::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Website::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Service

// required string name = 1;
inline bool Service::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Service::name() const {
  return *name_;
}
inline void Service::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Service::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Service::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Service::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Service::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 port = 2;
inline bool Service::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Service::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Service::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Service::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Service::port() const {
  return port_;
}
inline void Service::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// required string ip = 3;
inline bool Service::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Service::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Service::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Service::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& Service::ip() const {
  return *ip_;
}
inline void Service::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Service::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Service::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Service::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* Service::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Test

// required string testID = 1;
inline bool Test::has_testid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_testid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_testid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_testid() {
  if (testid_ != &::google::protobuf::internal::kEmptyString) {
    testid_->clear();
  }
  clear_has_testid();
}
inline const ::std::string& Test::testid() const {
  return *testid_;
}
inline void Test::set_testid(const ::std::string& value) {
  set_has_testid();
  if (testid_ == &::google::protobuf::internal::kEmptyString) {
    testid_ = new ::std::string;
  }
  testid_->assign(value);
}
inline void Test::set_testid(const char* value) {
  set_has_testid();
  if (testid_ == &::google::protobuf::internal::kEmptyString) {
    testid_ = new ::std::string;
  }
  testid_->assign(value);
}
inline void Test::set_testid(const char* value, size_t size) {
  set_has_testid();
  if (testid_ == &::google::protobuf::internal::kEmptyString) {
    testid_ = new ::std::string;
  }
  testid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Test::mutable_testid() {
  set_has_testid();
  if (testid_ == &::google::protobuf::internal::kEmptyString) {
    testid_ = new ::std::string;
  }
  return testid_;
}
inline ::std::string* Test::release_testid() {
  clear_has_testid();
  if (testid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = testid_;
    testid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .org.umit.icm.mobile.proto.Website website = 2;
inline bool Test::has_website() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_website() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_website() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_website() {
  if (website_ != NULL) website_->::org::umit::icm::mobile::proto::Website::Clear();
  clear_has_website();
}
inline const ::org::umit::icm::mobile::proto::Website& Test::website() const {
  return website_ != NULL ? *website_ : *default_instance_->website_;
}
inline ::org::umit::icm::mobile::proto::Website* Test::mutable_website() {
  set_has_website();
  if (website_ == NULL) website_ = new ::org::umit::icm::mobile::proto::Website;
  return website_;
}
inline ::org::umit::icm::mobile::proto::Website* Test::release_website() {
  clear_has_website();
  ::org::umit::icm::mobile::proto::Website* temp = website_;
  website_ = NULL;
  return temp;
}

// optional .org.umit.icm.mobile.proto.Service service = 3;
inline bool Test::has_service() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test::set_has_service() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test::clear_has_service() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test::clear_service() {
  if (service_ != NULL) service_->::org::umit::icm::mobile::proto::Service::Clear();
  clear_has_service();
}
inline const ::org::umit::icm::mobile::proto::Service& Test::service() const {
  return service_ != NULL ? *service_ : *default_instance_->service_;
}
inline ::org::umit::icm::mobile::proto::Service* Test::mutable_service() {
  set_has_service();
  if (service_ == NULL) service_ = new ::org::umit::icm::mobile::proto::Service;
  return service_;
}
inline ::org::umit::icm::mobile::proto::Service* Test::release_service() {
  clear_has_service();
  ::org::umit::icm::mobile::proto::Service* temp = service_;
  service_ = NULL;
  return temp;
}

// optional int64 executeAtTimeUTC = 4;
inline bool Test::has_executeattimeutc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::set_has_executeattimeutc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test::clear_has_executeattimeutc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test::clear_executeattimeutc() {
  executeattimeutc_ = GOOGLE_LONGLONG(0);
  clear_has_executeattimeutc();
}
inline ::google::protobuf::int64 Test::executeattimeutc() const {
  return executeattimeutc_;
}
inline void Test::set_executeattimeutc(::google::protobuf::int64 value) {
  set_has_executeattimeutc();
  executeattimeutc_ = value;
}

// required int32 testType = 5;
inline bool Test::has_testtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Test::set_has_testtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Test::clear_has_testtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Test::clear_testtype() {
  testtype_ = 0;
  clear_has_testtype();
}
inline ::google::protobuf::int32 Test::testtype() const {
  return testtype_;
}
inline void Test::set_testtype(::google::protobuf::int32 value) {
  set_has_testtype();
  testtype_ = value;
}

// -------------------------------------------------------------------

// NewTestsResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool NewTestsResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewTestsResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewTestsResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewTestsResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& NewTestsResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* NewTestsResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* NewTestsResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.Test tests = 2;
inline int NewTestsResponse::tests_size() const {
  return tests_.size();
}
inline void NewTestsResponse::clear_tests() {
  tests_.Clear();
}
inline const ::org::umit::icm::mobile::proto::Test& NewTestsResponse::tests(int index) const {
  return tests_.Get(index);
}
inline ::org::umit::icm::mobile::proto::Test* NewTestsResponse::mutable_tests(int index) {
  return tests_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::Test* NewTestsResponse::add_tests() {
  return tests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >&
NewTestsResponse::tests() const {
  return tests_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >*
NewTestsResponse::mutable_tests() {
  return &tests_;
}

// required int32 testVersionNo = 3;
inline bool NewTestsResponse::has_testversionno() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewTestsResponse::set_has_testversionno() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewTestsResponse::clear_has_testversionno() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewTestsResponse::clear_testversionno() {
  testversionno_ = 0;
  clear_has_testversionno();
}
inline ::google::protobuf::int32 NewTestsResponse::testversionno() const {
  return testversionno_;
}
inline void NewTestsResponse::set_testversionno(::google::protobuf::int32 value) {
  set_has_testversionno();
  testversionno_ = value;
}

// -------------------------------------------------------------------

// AssignTask

// required .org.umit.icm.mobile.proto.RequestHeader header = 1;
inline bool AssignTask::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignTask::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignTask::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignTask::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::RequestHeader& AssignTask::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::RequestHeader* AssignTask::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::RequestHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::RequestHeader* AssignTask::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AssignTaskResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool AssignTaskResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssignTaskResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssignTaskResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssignTaskResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& AssignTaskResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* AssignTaskResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* AssignTaskResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.Test tests = 2;
inline int AssignTaskResponse::tests_size() const {
  return tests_.size();
}
inline void AssignTaskResponse::clear_tests() {
  tests_.Clear();
}
inline const ::org::umit::icm::mobile::proto::Test& AssignTaskResponse::tests(int index) const {
  return tests_.Get(index);
}
inline ::org::umit::icm::mobile::proto::Test* AssignTaskResponse::mutable_tests(int index) {
  return tests_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::Test* AssignTaskResponse::add_tests() {
  return tests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >&
AssignTaskResponse::tests() const {
  return tests_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::Test >*
AssignTaskResponse::mutable_tests() {
  return &tests_;
}

// -------------------------------------------------------------------

// UpgradeToSuper

// required .org.umit.icm.mobile.proto.RequestHeader header = 1;
inline bool UpgradeToSuper::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeToSuper::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeToSuper::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeToSuper::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::RequestHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::RequestHeader& UpgradeToSuper::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::RequestHeader* UpgradeToSuper::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::RequestHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::RequestHeader* UpgradeToSuper::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::RequestHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UpgradeToSuperResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool UpgradeToSuperResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeToSuperResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeToSuperResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeToSuperResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& UpgradeToSuperResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* UpgradeToSuperResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* UpgradeToSuperResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required string newToken = 2;
inline bool UpgradeToSuperResponse::has_newtoken() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeToSuperResponse::set_has_newtoken() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeToSuperResponse::clear_has_newtoken() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeToSuperResponse::clear_newtoken() {
  if (newtoken_ != &::google::protobuf::internal::kEmptyString) {
    newtoken_->clear();
  }
  clear_has_newtoken();
}
inline const ::std::string& UpgradeToSuperResponse::newtoken() const {
  return *newtoken_;
}
inline void UpgradeToSuperResponse::set_newtoken(const ::std::string& value) {
  set_has_newtoken();
  if (newtoken_ == &::google::protobuf::internal::kEmptyString) {
    newtoken_ = new ::std::string;
  }
  newtoken_->assign(value);
}
inline void UpgradeToSuperResponse::set_newtoken(const char* value) {
  set_has_newtoken();
  if (newtoken_ == &::google::protobuf::internal::kEmptyString) {
    newtoken_ = new ::std::string;
  }
  newtoken_->assign(value);
}
inline void UpgradeToSuperResponse::set_newtoken(const char* value, size_t size) {
  set_has_newtoken();
  if (newtoken_ == &::google::protobuf::internal::kEmptyString) {
    newtoken_ = new ::std::string;
  }
  newtoken_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpgradeToSuperResponse::mutable_newtoken() {
  set_has_newtoken();
  if (newtoken_ == &::google::protobuf::internal::kEmptyString) {
    newtoken_ = new ::std::string;
  }
  return newtoken_;
}
inline ::std::string* UpgradeToSuperResponse::release_newtoken() {
  clear_has_newtoken();
  if (newtoken_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newtoken_;
    newtoken_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .org.umit.icm.mobile.proto.RSAKey newPrivateKey = 3;
inline bool UpgradeToSuperResponse::has_newprivatekey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeToSuperResponse::set_has_newprivatekey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeToSuperResponse::clear_has_newprivatekey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeToSuperResponse::clear_newprivatekey() {
  if (newprivatekey_ != NULL) newprivatekey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
  clear_has_newprivatekey();
}
inline const ::org::umit::icm::mobile::proto::RSAKey& UpgradeToSuperResponse::newprivatekey() const {
  return newprivatekey_ != NULL ? *newprivatekey_ : *default_instance_->newprivatekey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* UpgradeToSuperResponse::mutable_newprivatekey() {
  set_has_newprivatekey();
  if (newprivatekey_ == NULL) newprivatekey_ = new ::org::umit::icm::mobile::proto::RSAKey;
  return newprivatekey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* UpgradeToSuperResponse::release_newprivatekey() {
  clear_has_newprivatekey();
  ::org::umit::icm::mobile::proto::RSAKey* temp = newprivatekey_;
  newprivatekey_ = NULL;
  return temp;
}

// required .org.umit.icm.mobile.proto.RSAKey newPublicKey = 4;
inline bool UpgradeToSuperResponse::has_newpublickey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeToSuperResponse::set_has_newpublickey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeToSuperResponse::clear_has_newpublickey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeToSuperResponse::clear_newpublickey() {
  if (newpublickey_ != NULL) newpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
  clear_has_newpublickey();
}
inline const ::org::umit::icm::mobile::proto::RSAKey& UpgradeToSuperResponse::newpublickey() const {
  return newpublickey_ != NULL ? *newpublickey_ : *default_instance_->newpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* UpgradeToSuperResponse::mutable_newpublickey() {
  set_has_newpublickey();
  if (newpublickey_ == NULL) newpublickey_ = new ::org::umit::icm::mobile::proto::RSAKey;
  return newpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* UpgradeToSuperResponse::release_newpublickey() {
  clear_has_newpublickey();
  ::org::umit::icm::mobile::proto::RSAKey* temp = newpublickey_;
  newpublickey_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// WebsiteSuggestion

// required string websiteURL = 1;
inline bool WebsiteSuggestion::has_websiteurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebsiteSuggestion::set_has_websiteurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebsiteSuggestion::clear_has_websiteurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebsiteSuggestion::clear_websiteurl() {
  if (websiteurl_ != &::google::protobuf::internal::kEmptyString) {
    websiteurl_->clear();
  }
  clear_has_websiteurl();
}
inline const ::std::string& WebsiteSuggestion::websiteurl() const {
  return *websiteurl_;
}
inline void WebsiteSuggestion::set_websiteurl(const ::std::string& value) {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  websiteurl_->assign(value);
}
inline void WebsiteSuggestion::set_websiteurl(const char* value) {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  websiteurl_->assign(value);
}
inline void WebsiteSuggestion::set_websiteurl(const char* value, size_t size) {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  websiteurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebsiteSuggestion::mutable_websiteurl() {
  set_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    websiteurl_ = new ::std::string;
  }
  return websiteurl_;
}
inline ::std::string* WebsiteSuggestion::release_websiteurl() {
  clear_has_websiteurl();
  if (websiteurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = websiteurl_;
    websiteurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ServiceSuggestion

// required string serviceName = 1;
inline bool ServiceSuggestion::has_servicename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceSuggestion::set_has_servicename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceSuggestion::clear_has_servicename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceSuggestion::clear_servicename() {
  if (servicename_ != &::google::protobuf::internal::kEmptyString) {
    servicename_->clear();
  }
  clear_has_servicename();
}
inline const ::std::string& ServiceSuggestion::servicename() const {
  return *servicename_;
}
inline void ServiceSuggestion::set_servicename(const ::std::string& value) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(value);
}
inline void ServiceSuggestion::set_servicename(const char* value) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(value);
}
inline void ServiceSuggestion::set_servicename(const char* value, size_t size) {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  servicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceSuggestion::mutable_servicename() {
  set_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    servicename_ = new ::std::string;
  }
  return servicename_;
}
inline ::std::string* ServiceSuggestion::release_servicename() {
  clear_has_servicename();
  if (servicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servicename_;
    servicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string hostName = 2;
inline bool ServiceSuggestion::has_hostname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceSuggestion::set_has_hostname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceSuggestion::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceSuggestion::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& ServiceSuggestion::hostname() const {
  return *hostname_;
}
inline void ServiceSuggestion::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ServiceSuggestion::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void ServiceSuggestion::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceSuggestion::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* ServiceSuggestion::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ip = 3;
inline bool ServiceSuggestion::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServiceSuggestion::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServiceSuggestion::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServiceSuggestion::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ServiceSuggestion::ip() const {
  return *ip_;
}
inline void ServiceSuggestion::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ServiceSuggestion::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ServiceSuggestion::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceSuggestion::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* ServiceSuggestion::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 port = 4;
inline bool ServiceSuggestion::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServiceSuggestion::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServiceSuggestion::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServiceSuggestion::clear_port() {
  port_ = GOOGLE_LONGLONG(0);
  clear_has_port();
}
inline ::google::protobuf::int64 ServiceSuggestion::port() const {
  return port_;
}
inline void ServiceSuggestion::set_port(::google::protobuf::int64 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// TestSuggestionResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool TestSuggestionResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestSuggestionResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestSuggestionResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestSuggestionResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& TestSuggestionResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* TestSuggestionResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* TestSuggestionResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AuthenticatePeer

// required int32 agentType = 1;
inline bool AuthenticatePeer::has_agenttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticatePeer::set_has_agenttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticatePeer::clear_has_agenttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticatePeer::clear_agenttype() {
  agenttype_ = 0;
  clear_has_agenttype();
}
inline ::google::protobuf::int32 AuthenticatePeer::agenttype() const {
  return agenttype_;
}
inline void AuthenticatePeer::set_agenttype(::google::protobuf::int32 value) {
  set_has_agenttype();
  agenttype_ = value;
}

// required string agentID = 2;
inline bool AuthenticatePeer::has_agentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticatePeer::set_has_agentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticatePeer::clear_has_agentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticatePeer::clear_agentid() {
  if (agentid_ != &::google::protobuf::internal::kEmptyString) {
    agentid_->clear();
  }
  clear_has_agentid();
}
inline const ::std::string& AuthenticatePeer::agentid() const {
  return *agentid_;
}
inline void AuthenticatePeer::set_agentid(const ::std::string& value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void AuthenticatePeer::set_agentid(const char* value) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(value);
}
inline void AuthenticatePeer::set_agentid(const char* value, size_t size) {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  agentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticatePeer::mutable_agentid() {
  set_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    agentid_ = new ::std::string;
  }
  return agentid_;
}
inline ::std::string* AuthenticatePeer::release_agentid() {
  clear_has_agentid();
  if (agentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agentid_;
    agentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 3;
inline bool AuthenticatePeer::has_cipheredpublickey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuthenticatePeer::set_has_cipheredpublickey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuthenticatePeer::clear_has_cipheredpublickey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuthenticatePeer::clear_cipheredpublickey() {
  if (cipheredpublickey_ != NULL) cipheredpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
  clear_has_cipheredpublickey();
}
inline const ::org::umit::icm::mobile::proto::RSAKey& AuthenticatePeer::cipheredpublickey() const {
  return cipheredpublickey_ != NULL ? *cipheredpublickey_ : *default_instance_->cipheredpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* AuthenticatePeer::mutable_cipheredpublickey() {
  set_has_cipheredpublickey();
  if (cipheredpublickey_ == NULL) cipheredpublickey_ = new ::org::umit::icm::mobile::proto::RSAKey;
  return cipheredpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* AuthenticatePeer::release_cipheredpublickey() {
  clear_has_cipheredpublickey();
  ::org::umit::icm::mobile::proto::RSAKey* temp = cipheredpublickey_;
  cipheredpublickey_ = NULL;
  return temp;
}

// optional int32 agentPort = 4;
inline bool AuthenticatePeer::has_agentport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthenticatePeer::set_has_agentport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthenticatePeer::clear_has_agentport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthenticatePeer::clear_agentport() {
  agentport_ = 0;
  clear_has_agentport();
}
inline ::google::protobuf::int32 AuthenticatePeer::agentport() const {
  return agentport_;
}
inline void AuthenticatePeer::set_agentport(::google::protobuf::int32 value) {
  set_has_agentport();
  agentport_ = value;
}

// -------------------------------------------------------------------

// AuthenticatePeerResponse

// required .org.umit.icm.mobile.proto.RSAKey cipheredPublicKey = 1;
inline bool AuthenticatePeerResponse::has_cipheredpublickey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticatePeerResponse::set_has_cipheredpublickey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticatePeerResponse::clear_has_cipheredpublickey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticatePeerResponse::clear_cipheredpublickey() {
  if (cipheredpublickey_ != NULL) cipheredpublickey_->::org::umit::icm::mobile::proto::RSAKey::Clear();
  clear_has_cipheredpublickey();
}
inline const ::org::umit::icm::mobile::proto::RSAKey& AuthenticatePeerResponse::cipheredpublickey() const {
  return cipheredpublickey_ != NULL ? *cipheredpublickey_ : *default_instance_->cipheredpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* AuthenticatePeerResponse::mutable_cipheredpublickey() {
  set_has_cipheredpublickey();
  if (cipheredpublickey_ == NULL) cipheredpublickey_ = new ::org::umit::icm::mobile::proto::RSAKey;
  return cipheredpublickey_;
}
inline ::org::umit::icm::mobile::proto::RSAKey* AuthenticatePeerResponse::release_cipheredpublickey() {
  clear_has_cipheredpublickey();
  ::org::umit::icm::mobile::proto::RSAKey* temp = cipheredpublickey_;
  cipheredpublickey_ = NULL;
  return temp;
}

// required string token = 2;
inline bool AuthenticatePeerResponse::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthenticatePeerResponse::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthenticatePeerResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthenticatePeerResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AuthenticatePeerResponse::token() const {
  return *token_;
}
inline void AuthenticatePeerResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AuthenticatePeerResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AuthenticatePeerResponse::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticatePeerResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AuthenticatePeerResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// P2PGetSuperPeerList

// required int32 count = 1;
inline bool P2PGetSuperPeerList::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P2PGetSuperPeerList::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P2PGetSuperPeerList::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P2PGetSuperPeerList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 P2PGetSuperPeerList::count() const {
  return count_;
}
inline void P2PGetSuperPeerList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// P2PGetSuperPeerListResponse

// repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
inline int P2PGetSuperPeerListResponse::peers_size() const {
  return peers_.size();
}
inline void P2PGetSuperPeerListResponse::clear_peers() {
  peers_.Clear();
}
inline const ::org::umit::icm::mobile::proto::AgentData& P2PGetSuperPeerListResponse::peers(int index) const {
  return peers_.Get(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* P2PGetSuperPeerListResponse::mutable_peers(int index) {
  return peers_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* P2PGetSuperPeerListResponse::add_peers() {
  return peers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
P2PGetSuperPeerListResponse::peers() const {
  return peers_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
P2PGetSuperPeerListResponse::mutable_peers() {
  return &peers_;
}

// -------------------------------------------------------------------

// P2PGetPeerList

// required int32 count = 1;
inline bool P2PGetPeerList::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void P2PGetPeerList::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void P2PGetPeerList::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void P2PGetPeerList::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 P2PGetPeerList::count() const {
  return count_;
}
inline void P2PGetPeerList::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// P2PGetPeerListResponse

// repeated .org.umit.icm.mobile.proto.AgentData peers = 1;
inline int P2PGetPeerListResponse::peers_size() const {
  return peers_.size();
}
inline void P2PGetPeerListResponse::clear_peers() {
  peers_.Clear();
}
inline const ::org::umit::icm::mobile::proto::AgentData& P2PGetPeerListResponse::peers(int index) const {
  return peers_.Get(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* P2PGetPeerListResponse::mutable_peers(int index) {
  return peers_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* P2PGetPeerListResponse::add_peers() {
  return peers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
P2PGetPeerListResponse::peers() const {
  return peers_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
P2PGetPeerListResponse::mutable_peers() {
  return &peers_;
}

// -------------------------------------------------------------------

// AgentUpdate

// required string version = 1;
inline bool AgentUpdate::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentUpdate::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentUpdate::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentUpdate::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AgentUpdate::version() const {
  return *version_;
}
inline void AgentUpdate::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentUpdate::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentUpdate::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentUpdate::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AgentUpdate::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string downloadURL = 2;
inline bool AgentUpdate::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentUpdate::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentUpdate::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentUpdate::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& AgentUpdate::downloadurl() const {
  return *downloadurl_;
}
inline void AgentUpdate::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void AgentUpdate::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void AgentUpdate::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentUpdate::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* AgentUpdate::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checkCode = 3;
inline bool AgentUpdate::has_checkcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AgentUpdate::set_has_checkcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AgentUpdate::clear_has_checkcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AgentUpdate::clear_checkcode() {
  checkcode_ = 0;
  clear_has_checkcode();
}
inline ::google::protobuf::int32 AgentUpdate::checkcode() const {
  return checkcode_;
}
inline void AgentUpdate::set_checkcode(::google::protobuf::int32 value) {
  set_has_checkcode();
  checkcode_ = value;
}

// -------------------------------------------------------------------

// AgentUpdateResponse

// required string version = 1;
inline bool AgentUpdateResponse::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AgentUpdateResponse::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AgentUpdateResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AgentUpdateResponse::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& AgentUpdateResponse::version() const {
  return *version_;
}
inline void AgentUpdateResponse::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentUpdateResponse::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void AgentUpdateResponse::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentUpdateResponse::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* AgentUpdateResponse::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string result = 2;
inline bool AgentUpdateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AgentUpdateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AgentUpdateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AgentUpdateResponse::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& AgentUpdateResponse::result() const {
  return *result_;
}
inline void AgentUpdateResponse::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentUpdateResponse::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void AgentUpdateResponse::set_result(const char* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AgentUpdateResponse::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* AgentUpdateResponse::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TestModuleUpdate

// required string version = 1;
inline bool TestModuleUpdate::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestModuleUpdate::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestModuleUpdate::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestModuleUpdate::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TestModuleUpdate::version() const {
  return *version_;
}
inline void TestModuleUpdate::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TestModuleUpdate::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TestModuleUpdate::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestModuleUpdate::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TestModuleUpdate::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string downloadURL = 2;
inline bool TestModuleUpdate::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestModuleUpdate::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestModuleUpdate::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestModuleUpdate::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& TestModuleUpdate::downloadurl() const {
  return *downloadurl_;
}
inline void TestModuleUpdate::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void TestModuleUpdate::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void TestModuleUpdate::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestModuleUpdate::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* TestModuleUpdate::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 checkCode = 3;
inline bool TestModuleUpdate::has_checkcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestModuleUpdate::set_has_checkcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestModuleUpdate::clear_has_checkcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestModuleUpdate::clear_checkcode() {
  checkcode_ = 0;
  clear_has_checkcode();
}
inline ::google::protobuf::int32 TestModuleUpdate::checkcode() const {
  return checkcode_;
}
inline void TestModuleUpdate::set_checkcode(::google::protobuf::int32 value) {
  set_has_checkcode();
  checkcode_ = value;
}

// -------------------------------------------------------------------

// TestModuleUpdateResponse

// required string version = 1;
inline bool TestModuleUpdateResponse::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestModuleUpdateResponse::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestModuleUpdateResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestModuleUpdateResponse::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& TestModuleUpdateResponse::version() const {
  return *version_;
}
inline void TestModuleUpdateResponse::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TestModuleUpdateResponse::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void TestModuleUpdateResponse::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestModuleUpdateResponse::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* TestModuleUpdateResponse::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string result = 2;
inline bool TestModuleUpdateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestModuleUpdateResponse::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestModuleUpdateResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestModuleUpdateResponse::clear_result() {
  if (result_ != &::google::protobuf::internal::kEmptyString) {
    result_->clear();
  }
  clear_has_result();
}
inline const ::std::string& TestModuleUpdateResponse::result() const {
  return *result_;
}
inline void TestModuleUpdateResponse::set_result(const ::std::string& value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void TestModuleUpdateResponse::set_result(const char* value) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(value);
}
inline void TestModuleUpdateResponse::set_result(const char* value, size_t size) {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  result_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TestModuleUpdateResponse::mutable_result() {
  set_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    result_ = new ::std::string;
  }
  return result_;
}
inline ::std::string* TestModuleUpdateResponse::release_result() {
  clear_has_result();
  if (result_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = result_;
    result_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ForwardingMessage

// required int64 destination = 1;
inline bool ForwardingMessage::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForwardingMessage::set_has_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForwardingMessage::clear_has_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForwardingMessage::clear_destination() {
  destination_ = GOOGLE_LONGLONG(0);
  clear_has_destination();
}
inline ::google::protobuf::int64 ForwardingMessage::destination() const {
  return destination_;
}
inline void ForwardingMessage::set_destination(::google::protobuf::int64 value) {
  set_has_destination();
  destination_ = value;
}

// required string identifier = 2;
inline bool ForwardingMessage::has_identifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForwardingMessage::set_has_identifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForwardingMessage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForwardingMessage::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& ForwardingMessage::identifier() const {
  return *identifier_;
}
inline void ForwardingMessage::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void ForwardingMessage::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void ForwardingMessage::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForwardingMessage::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* ForwardingMessage::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string encodedMessage = 3;
inline bool ForwardingMessage::has_encodedmessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForwardingMessage::set_has_encodedmessage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForwardingMessage::clear_has_encodedmessage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForwardingMessage::clear_encodedmessage() {
  if (encodedmessage_ != &::google::protobuf::internal::kEmptyString) {
    encodedmessage_->clear();
  }
  clear_has_encodedmessage();
}
inline const ::std::string& ForwardingMessage::encodedmessage() const {
  return *encodedmessage_;
}
inline void ForwardingMessage::set_encodedmessage(const ::std::string& value) {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  encodedmessage_->assign(value);
}
inline void ForwardingMessage::set_encodedmessage(const char* value) {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  encodedmessage_->assign(value);
}
inline void ForwardingMessage::set_encodedmessage(const char* value, size_t size) {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  encodedmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForwardingMessage::mutable_encodedmessage() {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  return encodedmessage_;
}
inline ::std::string* ForwardingMessage::release_encodedmessage() {
  clear_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encodedmessage_;
    encodedmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ForwardingMessageResponse

// required string identifier = 1;
inline bool ForwardingMessageResponse::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ForwardingMessageResponse::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ForwardingMessageResponse::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ForwardingMessageResponse::clear_identifier() {
  if (identifier_ != &::google::protobuf::internal::kEmptyString) {
    identifier_->clear();
  }
  clear_has_identifier();
}
inline const ::std::string& ForwardingMessageResponse::identifier() const {
  return *identifier_;
}
inline void ForwardingMessageResponse::set_identifier(const ::std::string& value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void ForwardingMessageResponse::set_identifier(const char* value) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(value);
}
inline void ForwardingMessageResponse::set_identifier(const char* value, size_t size) {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  identifier_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForwardingMessageResponse::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    identifier_ = new ::std::string;
  }
  return identifier_;
}
inline ::std::string* ForwardingMessageResponse::release_identifier() {
  clear_has_identifier();
  if (identifier_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifier_;
    identifier_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string encodedMessage = 2;
inline bool ForwardingMessageResponse::has_encodedmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ForwardingMessageResponse::set_has_encodedmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ForwardingMessageResponse::clear_has_encodedmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ForwardingMessageResponse::clear_encodedmessage() {
  if (encodedmessage_ != &::google::protobuf::internal::kEmptyString) {
    encodedmessage_->clear();
  }
  clear_has_encodedmessage();
}
inline const ::std::string& ForwardingMessageResponse::encodedmessage() const {
  return *encodedmessage_;
}
inline void ForwardingMessageResponse::set_encodedmessage(const ::std::string& value) {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  encodedmessage_->assign(value);
}
inline void ForwardingMessageResponse::set_encodedmessage(const char* value) {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  encodedmessage_->assign(value);
}
inline void ForwardingMessageResponse::set_encodedmessage(const char* value, size_t size) {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  encodedmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForwardingMessageResponse::mutable_encodedmessage() {
  set_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    encodedmessage_ = new ::std::string;
  }
  return encodedmessage_;
}
inline ::std::string* ForwardingMessageResponse::release_encodedmessage() {
  clear_has_encodedmessage();
  if (encodedmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encodedmessage_;
    encodedmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LoginCredentials

// required string username = 1;
inline bool LoginCredentials::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginCredentials::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginCredentials::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginCredentials::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginCredentials::username() const {
  return *username_;
}
inline void LoginCredentials::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginCredentials::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginCredentials::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCredentials::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginCredentials::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool LoginCredentials::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginCredentials::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginCredentials::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginCredentials::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginCredentials::password() const {
  return *password_;
}
inline void LoginCredentials::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginCredentials::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LoginCredentials::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginCredentials::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LoginCredentials::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GetNetlist

// required int32 list = 1;
inline bool GetNetlist::has_list() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNetlist::set_has_list() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNetlist::clear_has_list() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNetlist::clear_list() {
  list_ = 0;
  clear_has_list();
}
inline ::google::protobuf::int32 GetNetlist::list() const {
  return list_;
}
inline void GetNetlist::set_list(::google::protobuf::int32 value) {
  set_has_list();
  list_ = value;
}

// -------------------------------------------------------------------

// NetworkData

// required int32 start_ip = 1;
inline bool NetworkData::has_start_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetworkData::set_has_start_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetworkData::clear_has_start_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetworkData::clear_start_ip() {
  start_ip_ = 0;
  clear_has_start_ip();
}
inline ::google::protobuf::int32 NetworkData::start_ip() const {
  return start_ip_;
}
inline void NetworkData::set_start_ip(::google::protobuf::int32 value) {
  set_has_start_ip();
  start_ip_ = value;
}

// required int32 end_ip = 2;
inline bool NetworkData::has_end_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetworkData::set_has_end_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetworkData::clear_has_end_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetworkData::clear_end_ip() {
  end_ip_ = 0;
  clear_has_end_ip();
}
inline ::google::protobuf::int32 NetworkData::end_ip() const {
  return end_ip_;
}
inline void NetworkData::set_end_ip(::google::protobuf::int32 value) {
  set_has_end_ip();
  end_ip_ = value;
}

// optional int32 nodes_count_network = 3;
inline bool NetworkData::has_nodes_count_network() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetworkData::set_has_nodes_count_network() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetworkData::clear_has_nodes_count_network() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetworkData::clear_nodes_count_network() {
  nodes_count_network_ = 0;
  clear_has_nodes_count_network();
}
inline ::google::protobuf::int32 NetworkData::nodes_count_network() const {
  return nodes_count_network_;
}
inline void NetworkData::set_nodes_count_network(::google::protobuf::int32 value) {
  set_has_nodes_count_network();
  nodes_count_network_ = value;
}

// repeated .org.umit.icm.mobile.proto.AgentData nodes = 4;
inline int NetworkData::nodes_size() const {
  return nodes_.size();
}
inline void NetworkData::clear_nodes() {
  nodes_.Clear();
}
inline const ::org::umit::icm::mobile::proto::AgentData& NetworkData::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* NetworkData::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::AgentData* NetworkData::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >&
NetworkData::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::AgentData >*
NetworkData::mutable_nodes() {
  return &nodes_;
}

// -------------------------------------------------------------------

// BannedNetworkData

// required int32 start_ip = 1;
inline bool BannedNetworkData::has_start_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BannedNetworkData::set_has_start_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BannedNetworkData::clear_has_start_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BannedNetworkData::clear_start_ip() {
  start_ip_ = 0;
  clear_has_start_ip();
}
inline ::google::protobuf::int32 BannedNetworkData::start_ip() const {
  return start_ip_;
}
inline void BannedNetworkData::set_start_ip(::google::protobuf::int32 value) {
  set_has_start_ip();
  start_ip_ = value;
}

// required int32 end_ip = 2;
inline bool BannedNetworkData::has_end_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BannedNetworkData::set_has_end_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BannedNetworkData::clear_has_end_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BannedNetworkData::clear_end_ip() {
  end_ip_ = 0;
  clear_has_end_ip();
}
inline ::google::protobuf::int32 BannedNetworkData::end_ip() const {
  return end_ip_;
}
inline void BannedNetworkData::set_end_ip(::google::protobuf::int32 value) {
  set_has_end_ip();
  end_ip_ = value;
}

// optional int32 nodes_count = 3;
inline bool BannedNetworkData::has_nodes_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BannedNetworkData::set_has_nodes_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BannedNetworkData::clear_has_nodes_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BannedNetworkData::clear_nodes_count() {
  nodes_count_ = 0;
  clear_has_nodes_count();
}
inline ::google::protobuf::int32 BannedNetworkData::nodes_count() const {
  return nodes_count_;
}
inline void BannedNetworkData::set_nodes_count(::google::protobuf::int32 value) {
  set_has_nodes_count();
  nodes_count_ = value;
}

// required int32 flags = 4;
inline bool BannedNetworkData::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BannedNetworkData::set_has_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BannedNetworkData::clear_has_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BannedNetworkData::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 BannedNetworkData::flags() const {
  return flags_;
}
inline void BannedNetworkData::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// GetNetlistResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool GetNetlistResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetNetlistResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetNetlistResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetNetlistResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& GetNetlistResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetNetlistResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetNetlistResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.NetworkData networks = 2;
inline int GetNetlistResponse::networks_size() const {
  return networks_.size();
}
inline void GetNetlistResponse::clear_networks() {
  networks_.Clear();
}
inline const ::org::umit::icm::mobile::proto::NetworkData& GetNetlistResponse::networks(int index) const {
  return networks_.Get(index);
}
inline ::org::umit::icm::mobile::proto::NetworkData* GetNetlistResponse::mutable_networks(int index) {
  return networks_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::NetworkData* GetNetlistResponse::add_networks() {
  return networks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::NetworkData >&
GetNetlistResponse::networks() const {
  return networks_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::NetworkData >*
GetNetlistResponse::mutable_networks() {
  return &networks_;
}

// -------------------------------------------------------------------

// GetBanlist

// required int32 count = 1;
inline bool GetBanlist::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBanlist::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBanlist::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBanlist::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GetBanlist::count() const {
  return count_;
}
inline void GetBanlist::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// GetBanlistResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool GetBanlistResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBanlistResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBanlistResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBanlistResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& GetBanlistResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetBanlistResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetBanlistResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// required int32 nodes_count = 2;
inline bool GetBanlistResponse::has_nodes_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetBanlistResponse::set_has_nodes_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetBanlistResponse::clear_has_nodes_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetBanlistResponse::clear_nodes_count() {
  nodes_count_ = 0;
  clear_has_nodes_count();
}
inline ::google::protobuf::int32 GetBanlistResponse::nodes_count() const {
  return nodes_count_;
}
inline void GetBanlistResponse::set_nodes_count(::google::protobuf::int32 value) {
  set_has_nodes_count();
  nodes_count_ = value;
}

// repeated string agent_ids = 3;
inline int GetBanlistResponse::agent_ids_size() const {
  return agent_ids_.size();
}
inline void GetBanlistResponse::clear_agent_ids() {
  agent_ids_.Clear();
}
inline const ::std::string& GetBanlistResponse::agent_ids(int index) const {
  return agent_ids_.Get(index);
}
inline ::std::string* GetBanlistResponse::mutable_agent_ids(int index) {
  return agent_ids_.Mutable(index);
}
inline void GetBanlistResponse::set_agent_ids(int index, const ::std::string& value) {
  agent_ids_.Mutable(index)->assign(value);
}
inline void GetBanlistResponse::set_agent_ids(int index, const char* value) {
  agent_ids_.Mutable(index)->assign(value);
}
inline void GetBanlistResponse::set_agent_ids(int index, const char* value, size_t size) {
  agent_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBanlistResponse::add_agent_ids() {
  return agent_ids_.Add();
}
inline void GetBanlistResponse::add_agent_ids(const ::std::string& value) {
  agent_ids_.Add()->assign(value);
}
inline void GetBanlistResponse::add_agent_ids(const char* value) {
  agent_ids_.Add()->assign(value);
}
inline void GetBanlistResponse::add_agent_ids(const char* value, size_t size) {
  agent_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetBanlistResponse::agent_ids() const {
  return agent_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetBanlistResponse::mutable_agent_ids() {
  return &agent_ids_;
}

// -------------------------------------------------------------------

// GetBannets

// required int32 count = 1;
inline bool GetBannets::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBannets::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBannets::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBannets::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 GetBannets::count() const {
  return count_;
}
inline void GetBannets::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// GetBannetsResponse

// required .org.umit.icm.mobile.proto.ResponseHeader header = 1;
inline bool GetBannetsResponse::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetBannetsResponse::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetBannetsResponse::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetBannetsResponse::clear_header() {
  if (header_ != NULL) header_->::org::umit::icm::mobile::proto::ResponseHeader::Clear();
  clear_has_header();
}
inline const ::org::umit::icm::mobile::proto::ResponseHeader& GetBannetsResponse::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetBannetsResponse::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::org::umit::icm::mobile::proto::ResponseHeader;
  return header_;
}
inline ::org::umit::icm::mobile::proto::ResponseHeader* GetBannetsResponse::release_header() {
  clear_has_header();
  ::org::umit::icm::mobile::proto::ResponseHeader* temp = header_;
  header_ = NULL;
  return temp;
}

// repeated .org.umit.icm.mobile.proto.BannedNetworkData networks = 2;
inline int GetBannetsResponse::networks_size() const {
  return networks_.size();
}
inline void GetBannetsResponse::clear_networks() {
  networks_.Clear();
}
inline const ::org::umit::icm::mobile::proto::BannedNetworkData& GetBannetsResponse::networks(int index) const {
  return networks_.Get(index);
}
inline ::org::umit::icm::mobile::proto::BannedNetworkData* GetBannetsResponse::mutable_networks(int index) {
  return networks_.Mutable(index);
}
inline ::org::umit::icm::mobile::proto::BannedNetworkData* GetBannetsResponse::add_networks() {
  return networks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::BannedNetworkData >&
GetBannetsResponse::networks() const {
  return networks_;
}
inline ::google::protobuf::RepeatedPtrField< ::org::umit::icm::mobile::proto::BannedNetworkData >*
GetBannetsResponse::mutable_networks() {
  return &networks_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace mobile
}  // namespace icm
}  // namespace umit
}  // namespace org

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
